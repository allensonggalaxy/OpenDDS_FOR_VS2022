/* Generated by ..\bin\opendds_idl version 3.20.0 (ACE version 6.2a_p23) running on input file DdsDcpsInfoUtils.idl */
#include "DCPS/DdsDcps_pch.h"
#include "DdsDcpsInfoUtilsTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: RepoId */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_RepoId_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(206, 148, 209, 100, 81, 125, 42, 181, 12, 217, 195, 161, 137, 0));
  }
  return ti;
}

static const XTypes::TypeMap& get_minimal_type_map();
template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_RepoId_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: RepoId */


/* Begin STRUCT: MonotonicTime_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_MonotonicTime_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_MonotonicTime_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::MonotonicTime_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"sec",0},{"nanosec",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.sec)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.nanosec)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::MonotonicTime_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("sec");
  value_writer.write_int32(value.sec);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("nanosec");
  value_writer.write_uint32(value.nanosec);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::MonotonicTime_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.sec = 0;
  stru.nanosec = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::MonotonicTime_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.sec);
  primitive_serialized_size(encoding, size, stru.nanosec);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::MonotonicTime_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.sec)
    && (strm << stru.nanosec);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::MonotonicTime_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.sec)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.nanosec)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::MonotonicTime_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.sec);
  primitive_serialized_size(encoding, size, stru.value.nanosec);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::MonotonicTime_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.sec)
    && (strm << stru.value.nanosec);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::MonotonicTime_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.sec)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.nanosec)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::MonotonicTime_t> : MetaStruct {
  typedef  ::OpenDDS::DCPS::MonotonicTime_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("sec", 0),
      std::make_pair("nanosec", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MonotonicTime_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::MonotonicTime_t& typed = *static_cast<const  ::OpenDDS::DCPS::MonotonicTime_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "sec") == 0) {
      return typed.sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return typed.nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MonotonicTime_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "sec") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sec' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sec' could not be skipped");
      }
    }
    if (base_field == "nanosec") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'nanosec' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'nanosec' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sec") == 0) {
      return make_field_cmp(&T::sec, next);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return make_field_cmp(&T::nanosec, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MonotonicTime_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"sec", "nanosec", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      return &static_cast<const T*>(stru)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return &static_cast<const T*>(stru)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MonotonicTime_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sec") == 0) {
      static_cast<T*>(lhs)->sec = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      static_cast<T*>(lhs)->nanosec = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MonotonicTime_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sec") == 0) {
      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MonotonicTime_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::MonotonicTime_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::MonotonicTime_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::MonotonicTime_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: MonotonicTime_t */


/* Begin TYPEDEF: TransportBLOB */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportBLOB_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 184, 244, 149, 52, 65, 12, 119, 163, 176, 63, 222, 239, 135));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportBLOB_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: TransportBLOB */


/* Begin STRUCT: TransportLocator */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportLocator_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 235, 25, 172, 15, 65, 98, 13, 167, 52, 8, 137, 206, 198));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportLocator_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::TransportLocator& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"transport_type",0},{"data",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.transport_type = x.c_str();
      }
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.data);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.data[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::TransportLocator& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("transport_type");
  value_writer.write_string(value.transport_type);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("data");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.data.get_buffer(), value.data.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::TransportLocator& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.transport_type = "";
  stru.data.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::TransportLocator& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.transport_type.in()) + 1;
  serialized_size(encoding, size, stru.data);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::TransportLocator& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.transport_type.in())
    && (strm << stru.data);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TransportLocator& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport_type.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportLocator>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.transport_type.in()) + 1;
  serialized_size(encoding, size, stru.value.data);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportLocator>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.transport_type.in())
    && (strm << stru.value.data);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::TransportLocator>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.transport_type.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::TransportLocator> : MetaStruct {
  typedef  ::OpenDDS::DCPS::TransportLocator T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("transport_type", 0),
      std::make_pair("data", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportLocator)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::TransportLocator& typed = *static_cast<const  ::OpenDDS::DCPS::TransportLocator*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "transport_type") == 0) {
      return typed.transport_type.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportLocator)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "transport_type") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'transport_type' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'transport_type' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'transport_type' contents could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::TransportBLOB*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "transport_type") == 0) {
      return make_field_cmp(&T::transport_type, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportLocator)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"transport_type", "data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "transport_type") == 0) {
      return &static_cast<const T*>(stru)->transport_type;
    }
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportLocator)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "transport_type") == 0) {
      static_cast<T*>(lhs)->transport_type = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data") == 0) {
      static_cast<T*>(lhs)->data = *static_cast<const  ::OpenDDS::DCPS::TransportBLOB*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportLocator)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "transport_type") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->transport_type.in(), static_cast<const T*>(rhs)->transport_type.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportLocator)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::TransportLocator>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::TransportLocator> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TransportLocator*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::TransportLocator>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportLocator */


/* Begin TYPEDEF: TransportLocatorSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportLocatorSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(236, 248, 8, 220, 236, 201, 133, 108, 218, 21, 16, 3, 142, 168));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportLocatorSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::TransportLocatorSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::TransportLocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TransportLocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::TransportLocatorSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::TransportLocatorSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TransportLocatorSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::TransportLocator*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: TransportLocatorSeq */


/* Begin STRUCT: IncompatibleQosStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_IncompatibleQosStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(122, 164, 141, 199, 34, 3, 12, 157, 70, 146, 76, 48, 42, 168));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_IncompatibleQosStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::IncompatibleQosStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"count_since_last_send",1},{"last_policy_id",2},{"policies",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.count_since_last_send)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.last_policy_id)) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.policies);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.policies[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::IncompatibleQosStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("count_since_last_send");
  value_writer.write_int32(value.count_since_last_send);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_policy_id");
  value_writer.write_int32(value.last_policy_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("policies");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.policies.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.policies[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::IncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.count_since_last_send = 0;
  stru.last_policy_id = 0;
  stru.policies.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::IncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.count_since_last_send);
  primitive_serialized_size(encoding, size, stru.last_policy_id);
  serialized_size(encoding, size, stru.policies);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::IncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.count_since_last_send)
    && (strm << stru.last_policy_id)
    && (strm << stru.policies);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::IncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.count_since_last_send)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_policy_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.policies)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::IncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.count_since_last_send);
  primitive_serialized_size(encoding, size, stru.value.last_policy_id);
  serialized_size(encoding, size, stru.value.policies);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::IncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.count_since_last_send)
    && (strm << stru.value.last_policy_id)
    && (strm << stru.value.policies);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::IncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.count_since_last_send)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_policy_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.policies)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::IncompatibleQosStatus> : MetaStruct {
  typedef  ::OpenDDS::DCPS::IncompatibleQosStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("count_since_last_send", 1),
      std::make_pair("last_policy_id", 2),
      std::make_pair("policies", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::IncompatibleQosStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::IncompatibleQosStatus& typed = *static_cast<const  ::OpenDDS::DCPS::IncompatibleQosStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return typed.count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return typed.last_policy_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::IncompatibleQosStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "count_since_last_send") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'count_since_last_send' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'count_since_last_send' could not be skipped");
      }
    }
    if (base_field == "last_policy_id") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_policy_id' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_policy_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::QosPolicyCountSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return make_field_cmp(&T::count_since_last_send, next);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return make_field_cmp(&T::last_policy_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::IncompatibleQosStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "count_since_last_send", "last_policy_id", "policies", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return &static_cast<const T*>(stru)->count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return &static_cast<const T*>(stru)->last_policy_id;
    }
    if (std::strcmp(field, "policies") == 0) {
      return &static_cast<const T*>(stru)->policies;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::IncompatibleQosStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      static_cast<T*>(lhs)->count_since_last_send = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      static_cast<T*>(lhs)->last_policy_id = *static_cast<const  ::DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "policies") == 0) {
      static_cast<T*>(lhs)->policies = *static_cast<const  ::DDS::QosPolicyCountSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::IncompatibleQosStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return static_cast<const T*>(lhs)->count_since_last_send == static_cast<const T*>(rhs)->count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return static_cast<const T*>(lhs)->last_policy_id == static_cast<const T*>(rhs)->last_policy_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::IncompatibleQosStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::IncompatibleQosStatus>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::IncompatibleQosStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::IncompatibleQosStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::IncompatibleQosStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: IncompatibleQosStatus */


/* Begin STRUCT: AddDomainStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_AddDomainStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(34, 31, 35, 130, 77, 65, 129, 167, 192, 171, 71, 167, 106, 34));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_AddDomainStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::AddDomainStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"id",0},{"federated",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.id)) return false;
      break;
    }
    case 1: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.federated = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::AddDomainStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("id");
  vwrite(value_writer, value.id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("federated");
  value_writer.write_boolean(value.federated);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::AddDomainStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.id);
  stru.federated = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::AddDomainStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.id);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.federated));
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::AddDomainStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.id)
    && (strm << ACE_OutputCDR::from_boolean(stru.federated));
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::AddDomainStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.federated))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::AddDomainStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(stru.value.id));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.federated));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::AddDomainStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(stru.value.id))
    && (strm << ACE_OutputCDR::from_boolean(stru.value.federated));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::AddDomainStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::RepoId> stru_value_id_nested_key_only(stru.value.id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.federated))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::AddDomainStatus> : MetaStruct {
  typedef  ::OpenDDS::DCPS::AddDomainStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("id", 0),
      std::make_pair("federated", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::AddDomainStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::AddDomainStatus& typed = *static_cast<const  ::OpenDDS::DCPS::AddDomainStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "id.", 3) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::RepoId>().getValue(&typed.id, field + 3);
    }
    if (std::strcmp(field, "federated") == 0) {
      return typed.federated;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::AddDomainStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'id' could not be skipped");
      }
    }
    if (base_field == "federated") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'federated' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'federated' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "id.", 3) == 0) {
      return make_struct_cmp(&T::id, getMetaStruct< ::OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 3), next);
    }
    if (std::strcmp(field, "federated") == 0) {
      return make_field_cmp(&T::federated, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::AddDomainStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"id", "federated", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "id") == 0) {
      return &static_cast<const T*>(stru)->id;
    }
    if (std::strcmp(field, "federated") == 0) {
      return &static_cast<const T*>(stru)->federated;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::AddDomainStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "id") == 0) {
      static_cast<T*>(lhs)->id = *static_cast<const  ::OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "federated") == 0) {
      static_cast<T*>(lhs)->federated = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::AddDomainStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "federated") == 0) {
      return static_cast<const T*>(lhs)->federated == static_cast<const T*>(rhs)->federated;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::AddDomainStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::AddDomainStatus>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::AddDomainStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::AddDomainStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::AddDomainStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: AddDomainStatus */


/* Begin ENUM: TopicStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TopicStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(170, 8, 164, 71, 199, 171, 74, 67, 145, 50, 111, 104, 167, 217));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TopicStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::TopicStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"CREATED",0},{"ENABLED",1},{"FOUND",2},{"NOT_FOUND",3},{"REMOVED",4},{"CONFLICTING_TYPENAME",5},{"PRECONDITION_NOT_MET",6},{"INTERNAL_ERROR",7},{"TOPIC_DISABLED",8},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::TopicStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case OpenDDS::DCPS::CREATED:
    value_writer.write_enum("CREATED", OpenDDS::DCPS::CREATED);
    break;
  case OpenDDS::DCPS::ENABLED:
    value_writer.write_enum("ENABLED", OpenDDS::DCPS::ENABLED);
    break;
  case OpenDDS::DCPS::FOUND:
    value_writer.write_enum("FOUND", OpenDDS::DCPS::FOUND);
    break;
  case OpenDDS::DCPS::NOT_FOUND:
    value_writer.write_enum("NOT_FOUND", OpenDDS::DCPS::NOT_FOUND);
    break;
  case OpenDDS::DCPS::REMOVED:
    value_writer.write_enum("REMOVED", OpenDDS::DCPS::REMOVED);
    break;
  case OpenDDS::DCPS::CONFLICTING_TYPENAME:
    value_writer.write_enum("CONFLICTING_TYPENAME", OpenDDS::DCPS::CONFLICTING_TYPENAME);
    break;
  case OpenDDS::DCPS::PRECONDITION_NOT_MET:
    value_writer.write_enum("PRECONDITION_NOT_MET", OpenDDS::DCPS::PRECONDITION_NOT_MET);
    break;
  case OpenDDS::DCPS::INTERNAL_ERROR:
    value_writer.write_enum("INTERNAL_ERROR", OpenDDS::DCPS::INTERNAL_ERROR);
    break;
  case OpenDDS::DCPS::TOPIC_DISABLED:
    value_writer.write_enum("TOPIC_DISABLED", OpenDDS::DCPS::TOPIC_DISABLED);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::TopicStatus& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 9) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::OpenDDS::DCPS::TopicStatus (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TopicStatus& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 9) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::OpenDDS::DCPS::TopicStatus>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_TopicStatus_names[] = {
  "CREATED",
  "ENABLED",
  "FOUND",
  "NOT_FOUND",
  "REMOVED",
  "CONFLICTING_TYPENAME",
  "PRECONDITION_NOT_MET",
  "INTERNAL_ERROR",
  "TOPIC_DISABLED"
};
const size_t gen_OpenDDS_DCPS_TopicStatus_names_size = 9;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: TopicStatus */


/* Begin STRUCT: WriterAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_WriterAssociation_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(185, 78, 152, 175, 105, 253, 69, 207, 164, 112, 96, 247, 184, 154));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_WriterAssociation_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::WriterAssociation& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"writerTransInfo",0},{"writerDiscInfo",1},{"transportContext",2},{"writerId",3},{"pubQos",4},{"writerQos",5},{"serializedTypeInfo",6},{"participantDiscoveredAt",7},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.writerTransInfo);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.writerTransInfo[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.writerDiscInfo)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint32(value.transportContext)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.writerId)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.pubQos)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.writerQos)) return false;
      break;
    }
    case 6: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.serializedTypeInfo);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.serializedTypeInfo[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 7: {
      if (!vread(value_reader, value.participantDiscoveredAt)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::WriterAssociation& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("writerTransInfo");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.writerTransInfo.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.writerTransInfo[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerDiscInfo");
  vwrite(value_writer, value.writerDiscInfo);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transportContext");
  value_writer.write_uint32(value.transportContext);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerId");
  vwrite(value_writer, value.writerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("pubQos");
  vwrite(value_writer, value.pubQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerQos");
  vwrite(value_writer, value.writerQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("serializedTypeInfo");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.serializedTypeInfo.get_buffer(), value.serializedTypeInfo.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("participantDiscoveredAt");
  vwrite(value_writer, value.participantDiscoveredAt);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::WriterAssociation& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.writerTransInfo.length(0);
  set_default(stru.writerDiscInfo);
  stru.transportContext = 0;
  set_default(stru.writerId);
  set_default(stru.pubQos);
  set_default(stru.writerQos);
  stru.serializedTypeInfo.length(0);
  set_default(stru.participantDiscoveredAt);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::WriterAssociation& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.writerTransInfo);
  serialized_size(encoding, size, stru.writerDiscInfo);
  primitive_serialized_size(encoding, size, stru.transportContext);
  serialized_size(encoding, size, stru.writerId);
  serialized_size(encoding, size, stru.pubQos);
  serialized_size(encoding, size, stru.writerQos);
  serialized_size(encoding, size, stru.serializedTypeInfo);
  serialized_size(encoding, size, stru.participantDiscoveredAt);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::WriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.writerTransInfo)
    && (strm << stru.writerDiscInfo)
    && (strm << stru.transportContext)
    && (strm << stru.writerId)
    && (strm << stru.pubQos)
    && (strm << stru.writerQos)
    && (strm << stru.serializedTypeInfo)
    && (strm << stru.participantDiscoveredAt);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::WriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerTransInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerDiscInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transportContext)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.pubQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.serializedTypeInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.participantDiscoveredAt)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::WriterAssociation>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.writerTransInfo);
  serialized_size(encoding, size, stru.value.writerDiscInfo);
  primitive_serialized_size(encoding, size, stru.value.transportContext);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(stru.value.writerId));
  serialized_size(encoding, size, stru.value.pubQos);
  serialized_size(encoding, size, stru.value.writerQos);
  serialized_size(encoding, size, stru.value.serializedTypeInfo);
  serialized_size(encoding, size, stru.value.participantDiscoveredAt);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::WriterAssociation>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.writerTransInfo)
    && (strm << stru.value.writerDiscInfo)
    && (strm << stru.value.transportContext)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(stru.value.writerId))
    && (strm << stru.value.pubQos)
    && (strm << stru.value.writerQos)
    && (strm << stru.value.serializedTypeInfo)
    && (strm << stru.value.participantDiscoveredAt);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::WriterAssociation>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::RepoId> stru_value_writerId_nested_key_only(stru.value.writerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.writerTransInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.writerDiscInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.transportContext)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.pubQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.writerQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.serializedTypeInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.participantDiscoveredAt)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::WriterAssociation> : MetaStruct {
  typedef  ::OpenDDS::DCPS::WriterAssociation T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("writerTransInfo", 0),
      std::make_pair("writerDiscInfo", 1),
      std::make_pair("transportContext", 2),
      std::make_pair("writerId", 3),
      std::make_pair("pubQos", 4),
      std::make_pair("writerQos", 5),
      std::make_pair("serializedTypeInfo", 6),
      std::make_pair("participantDiscoveredAt", 7),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 8);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterAssociation)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::WriterAssociation& typed = *static_cast<const  ::OpenDDS::DCPS::WriterAssociation*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "writerDiscInfo.", 15) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::TransportLocator>().getValue(&typed.writerDiscInfo, field + 15);
    }
    if (std::strcmp(field, "transportContext") == 0) {
      return typed.transportContext;
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::RepoId>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "pubQos.", 7) == 0) {
      return getMetaStruct< ::DDS::PublisherQos>().getValue(&typed.pubQos, field + 7);
    }
    if (std::strncmp(field, "writerQos.", 10) == 0) {
      return getMetaStruct< ::DDS::DataWriterQos>().getValue(&typed.writerQos, field + 10);
    }
    if (std::strncmp(field, "participantDiscoveredAt.", 24) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().getValue(&typed.participantDiscoveredAt, field + 24);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterAssociation)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "writerDiscInfo") {
      return getMetaStruct< ::OpenDDS::DCPS::TransportLocator>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::TransportLocator*>(0))) {
        throw std::runtime_error("Field 'writerDiscInfo' could not be skipped");
      }
    }
    if (base_field == "transportContext") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'transportContext' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'transportContext' could not be skipped");
      }
    }
    if (base_field == "writerId") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (base_field == "pubQos") {
      return getMetaStruct< ::DDS::PublisherQos>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PublisherQos*>(0))) {
        throw std::runtime_error("Field 'pubQos' could not be skipped");
      }
    }
    if (base_field == "writerQos") {
      return getMetaStruct< ::DDS::DataWriterQos>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DataWriterQos*>(0))) {
        throw std::runtime_error("Field 'writerQos' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "participantDiscoveredAt") {
      return getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::MonotonicTime_t*>(0))) {
        throw std::runtime_error("Field 'participantDiscoveredAt' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "writerDiscInfo.", 15) == 0) {
      return make_struct_cmp(&T::writerDiscInfo, getMetaStruct< ::OpenDDS::DCPS::TransportLocator>().create_qc_comparator(field + 15), next);
    }
    if (std::strcmp(field, "transportContext") == 0) {
      return make_field_cmp(&T::transportContext, next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct< ::OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "pubQos.", 7) == 0) {
      return make_struct_cmp(&T::pubQos, getMetaStruct< ::DDS::PublisherQos>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "writerQos.", 10) == 0) {
      return make_struct_cmp(&T::writerQos, getMetaStruct< ::DDS::DataWriterQos>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "participantDiscoveredAt.", 24) == 0) {
      return make_struct_cmp(&T::participantDiscoveredAt, getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().create_qc_comparator(field + 24), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterAssociation)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"writerTransInfo", "writerDiscInfo", "transportContext", "writerId", "pubQos", "writerQos", "serializedTypeInfo", "participantDiscoveredAt", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "writerTransInfo") == 0) {
      return &static_cast<const T*>(stru)->writerTransInfo;
    }
    if (std::strcmp(field, "writerDiscInfo") == 0) {
      return &static_cast<const T*>(stru)->writerDiscInfo;
    }
    if (std::strcmp(field, "transportContext") == 0) {
      return &static_cast<const T*>(stru)->transportContext;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "pubQos") == 0) {
      return &static_cast<const T*>(stru)->pubQos;
    }
    if (std::strcmp(field, "writerQos") == 0) {
      return &static_cast<const T*>(stru)->writerQos;
    }
    if (std::strcmp(field, "serializedTypeInfo") == 0) {
      return &static_cast<const T*>(stru)->serializedTypeInfo;
    }
    if (std::strcmp(field, "participantDiscoveredAt") == 0) {
      return &static_cast<const T*>(stru)->participantDiscoveredAt;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "writerTransInfo") == 0) {
      static_cast<T*>(lhs)->writerTransInfo = *static_cast<const  ::OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerDiscInfo") == 0) {
      static_cast<T*>(lhs)->writerDiscInfo = *static_cast<const  ::OpenDDS::DCPS::TransportLocator*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transportContext") == 0) {
      static_cast<T*>(lhs)->transportContext = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const  ::OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pubQos") == 0) {
      static_cast<T*>(lhs)->pubQos = *static_cast<const  ::DDS::PublisherQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerQos") == 0) {
      static_cast<T*>(lhs)->writerQos = *static_cast<const  ::DDS::DataWriterQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "serializedTypeInfo") == 0) {
      static_cast<T*>(lhs)->serializedTypeInfo = *static_cast<const  ::DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participantDiscoveredAt") == 0) {
      static_cast<T*>(lhs)->participantDiscoveredAt = *static_cast<const  ::OpenDDS::DCPS::MonotonicTime_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterAssociation)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "transportContext") == 0) {
      return static_cast<const T*>(lhs)->transportContext == static_cast<const T*>(rhs)->transportContext;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::WriterAssociation>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::WriterAssociation> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::WriterAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::WriterAssociation>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WriterAssociation */


/* Begin STRUCT: ReaderAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ReaderAssociation_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(5, 102, 80, 116, 41, 244, 222, 116, 5, 254, 50, 13, 195, 172));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ReaderAssociation_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ReaderAssociation& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"readerTransInfo",0},{"readerDiscInfo",1},{"transportContext",2},{"readerId",3},{"subQos",4},{"readerQos",5},{"filterClassName",6},{"filterExpression",7},{"exprParams",8},{"serializedTypeInfo",9},{"participantDiscoveredAt",10},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.readerTransInfo);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.readerTransInfo[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.readerDiscInfo)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint32(value.transportContext)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.readerId)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.subQos)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.readerQos)) return false;
      break;
    }
    case 6: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.filterClassName = x.c_str();
      }
      break;
    }
    case 7: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.filterExpression = x.c_str();
      }
      break;
    }
    case 8: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.exprParams);
        if (!value_reader.begin_element()) return false;
        {
          String x;
          if (!value_reader.read_string(x)) return false;
          value.exprParams[i] = x.c_str();
        }
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 9: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.serializedTypeInfo);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.serializedTypeInfo[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 10: {
      if (!vread(value_reader, value.participantDiscoveredAt)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ReaderAssociation& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("readerTransInfo");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.readerTransInfo.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.readerTransInfo[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerDiscInfo");
  vwrite(value_writer, value.readerDiscInfo);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transportContext");
  value_writer.write_uint32(value.transportContext);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerId");
  vwrite(value_writer, value.readerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("subQos");
  vwrite(value_writer, value.subQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerQos");
  vwrite(value_writer, value.readerQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("filterClassName");
  value_writer.write_string(value.filterClassName);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("filterExpression");
  value_writer.write_string(value.filterExpression);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("exprParams");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.exprParams.length(); ++i) {
    value_writer.begin_element(i);
    value_writer.write_string(value.exprParams[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("serializedTypeInfo");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.serializedTypeInfo.get_buffer(), value.serializedTypeInfo.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("participantDiscoveredAt");
  vwrite(value_writer, value.participantDiscoveredAt);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::ReaderAssociation& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.readerTransInfo.length(0);
  set_default(stru.readerDiscInfo);
  stru.transportContext = 0;
  set_default(stru.readerId);
  set_default(stru.subQos);
  set_default(stru.readerQos);
  stru.filterClassName = "";
  stru.filterExpression = "";
  stru.exprParams.length(0);
  stru.serializedTypeInfo.length(0);
  set_default(stru.participantDiscoveredAt);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ReaderAssociation& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.readerTransInfo);
  serialized_size(encoding, size, stru.readerDiscInfo);
  primitive_serialized_size(encoding, size, stru.transportContext);
  serialized_size(encoding, size, stru.readerId);
  serialized_size(encoding, size, stru.subQos);
  serialized_size(encoding, size, stru.readerQos);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.filterClassName.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.filterExpression.in()) + 1;
  serialized_size(encoding, size, stru.exprParams);
  serialized_size(encoding, size, stru.serializedTypeInfo);
  serialized_size(encoding, size, stru.participantDiscoveredAt);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.readerTransInfo)
    && (strm << stru.readerDiscInfo)
    && (strm << stru.transportContext)
    && (strm << stru.readerId)
    && (strm << stru.subQos)
    && (strm << stru.readerQos)
    && (strm << stru.filterClassName.in())
    && (strm << stru.filterExpression.in())
    && (strm << stru.exprParams)
    && (strm << stru.serializedTypeInfo)
    && (strm << stru.participantDiscoveredAt);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerTransInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerDiscInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transportContext)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.subQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.filterClassName.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.filterExpression.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.exprParams)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.serializedTypeInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.participantDiscoveredAt)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ReaderAssociation>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.readerTransInfo);
  serialized_size(encoding, size, stru.value.readerDiscInfo);
  primitive_serialized_size(encoding, size, stru.value.transportContext);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(stru.value.readerId));
  serialized_size(encoding, size, stru.value.subQos);
  serialized_size(encoding, size, stru.value.readerQos);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.filterClassName.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.filterExpression.in()) + 1;
  serialized_size(encoding, size, stru.value.exprParams);
  serialized_size(encoding, size, stru.value.serializedTypeInfo);
  serialized_size(encoding, size, stru.value.participantDiscoveredAt);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::ReaderAssociation>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.readerTransInfo)
    && (strm << stru.value.readerDiscInfo)
    && (strm << stru.value.transportContext)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(stru.value.readerId))
    && (strm << stru.value.subQos)
    && (strm << stru.value.readerQos)
    && (strm << stru.value.filterClassName.in())
    && (strm << stru.value.filterExpression.in())
    && (strm << stru.value.exprParams)
    && (strm << stru.value.serializedTypeInfo)
    && (strm << stru.value.participantDiscoveredAt);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ReaderAssociation>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::RepoId> stru_value_readerId_nested_key_only(stru.value.readerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.readerTransInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.readerDiscInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.transportContext)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.subQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.readerQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.filterClassName.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.filterExpression.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.exprParams)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.serializedTypeInfo)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.participantDiscoveredAt)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::ReaderAssociation> : MetaStruct {
  typedef  ::OpenDDS::DCPS::ReaderAssociation T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("readerTransInfo", 0),
      std::make_pair("readerDiscInfo", 1),
      std::make_pair("transportContext", 2),
      std::make_pair("readerId", 3),
      std::make_pair("subQos", 4),
      std::make_pair("readerQos", 5),
      std::make_pair("filterClassName", 6),
      std::make_pair("filterExpression", 7),
      std::make_pair("exprParams", 8),
      std::make_pair("serializedTypeInfo", 9),
      std::make_pair("participantDiscoveredAt", 10),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 11);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderAssociation)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::ReaderAssociation& typed = *static_cast<const  ::OpenDDS::DCPS::ReaderAssociation*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "readerDiscInfo.", 15) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::TransportLocator>().getValue(&typed.readerDiscInfo, field + 15);
    }
    if (std::strcmp(field, "transportContext") == 0) {
      return typed.transportContext;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::RepoId>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "subQos.", 7) == 0) {
      return getMetaStruct< ::DDS::SubscriberQos>().getValue(&typed.subQos, field + 7);
    }
    if (std::strncmp(field, "readerQos.", 10) == 0) {
      return getMetaStruct< ::DDS::DataReaderQos>().getValue(&typed.readerQos, field + 10);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return typed.filterClassName.in();
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return typed.filterExpression.in();
    }
    if (std::strncmp(field, "participantDiscoveredAt.", 24) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().getValue(&typed.participantDiscoveredAt, field + 24);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderAssociation)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "readerDiscInfo") {
      return getMetaStruct< ::OpenDDS::DCPS::TransportLocator>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::TransportLocator*>(0))) {
        throw std::runtime_error("Field 'readerDiscInfo' could not be skipped");
      }
    }
    if (base_field == "transportContext") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'transportContext' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'transportContext' could not be skipped");
      }
    }
    if (base_field == "readerId") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (base_field == "subQos") {
      return getMetaStruct< ::DDS::SubscriberQos>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::SubscriberQos*>(0))) {
        throw std::runtime_error("Field 'subQos' could not be skipped");
      }
    }
    if (base_field == "readerQos") {
      return getMetaStruct< ::DDS::DataReaderQos>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DataReaderQos*>(0))) {
        throw std::runtime_error("Field 'readerQos' could not be skipped");
      }
    }
    if (base_field == "filterClassName") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'filterClassName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'filterClassName' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'filterClassName' contents could not be skipped");
      }
    }
    if (base_field == "filterExpression") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'filterExpression' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'filterExpression' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'filterExpression' contents could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::StringSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "participantDiscoveredAt") {
      return getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::MonotonicTime_t*>(0))) {
        throw std::runtime_error("Field 'participantDiscoveredAt' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "readerDiscInfo.", 15) == 0) {
      return make_struct_cmp(&T::readerDiscInfo, getMetaStruct< ::OpenDDS::DCPS::TransportLocator>().create_qc_comparator(field + 15), next);
    }
    if (std::strcmp(field, "transportContext") == 0) {
      return make_field_cmp(&T::transportContext, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct< ::OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "subQos.", 7) == 0) {
      return make_struct_cmp(&T::subQos, getMetaStruct< ::DDS::SubscriberQos>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "readerQos.", 10) == 0) {
      return make_struct_cmp(&T::readerQos, getMetaStruct< ::DDS::DataReaderQos>().create_qc_comparator(field + 10), next);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return make_field_cmp(&T::filterClassName, next);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return make_field_cmp(&T::filterExpression, next);
    }
    if (std::strncmp(field, "participantDiscoveredAt.", 24) == 0) {
      return make_struct_cmp(&T::participantDiscoveredAt, getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().create_qc_comparator(field + 24), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderAssociation)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"readerTransInfo", "readerDiscInfo", "transportContext", "readerId", "subQos", "readerQos", "filterClassName", "filterExpression", "exprParams", "serializedTypeInfo", "participantDiscoveredAt", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "readerTransInfo") == 0) {
      return &static_cast<const T*>(stru)->readerTransInfo;
    }
    if (std::strcmp(field, "readerDiscInfo") == 0) {
      return &static_cast<const T*>(stru)->readerDiscInfo;
    }
    if (std::strcmp(field, "transportContext") == 0) {
      return &static_cast<const T*>(stru)->transportContext;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "subQos") == 0) {
      return &static_cast<const T*>(stru)->subQos;
    }
    if (std::strcmp(field, "readerQos") == 0) {
      return &static_cast<const T*>(stru)->readerQos;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return &static_cast<const T*>(stru)->filterClassName;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return &static_cast<const T*>(stru)->filterExpression;
    }
    if (std::strcmp(field, "exprParams") == 0) {
      return &static_cast<const T*>(stru)->exprParams;
    }
    if (std::strcmp(field, "serializedTypeInfo") == 0) {
      return &static_cast<const T*>(stru)->serializedTypeInfo;
    }
    if (std::strcmp(field, "participantDiscoveredAt") == 0) {
      return &static_cast<const T*>(stru)->participantDiscoveredAt;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "readerTransInfo") == 0) {
      static_cast<T*>(lhs)->readerTransInfo = *static_cast<const  ::OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerDiscInfo") == 0) {
      static_cast<T*>(lhs)->readerDiscInfo = *static_cast<const  ::OpenDDS::DCPS::TransportLocator*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transportContext") == 0) {
      static_cast<T*>(lhs)->transportContext = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const  ::OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "subQos") == 0) {
      static_cast<T*>(lhs)->subQos = *static_cast<const  ::DDS::SubscriberQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerQos") == 0) {
      static_cast<T*>(lhs)->readerQos = *static_cast<const  ::DDS::DataReaderQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      static_cast<T*>(lhs)->filterClassName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      static_cast<T*>(lhs)->filterExpression = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "exprParams") == 0) {
      static_cast<T*>(lhs)->exprParams = *static_cast<const  ::DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "serializedTypeInfo") == 0) {
      static_cast<T*>(lhs)->serializedTypeInfo = *static_cast<const  ::DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participantDiscoveredAt") == 0) {
      static_cast<T*>(lhs)->participantDiscoveredAt = *static_cast<const  ::OpenDDS::DCPS::MonotonicTime_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderAssociation)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "transportContext") == 0) {
      return static_cast<const T*>(lhs)->transportContext == static_cast<const T*>(rhs)->transportContext;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterClassName.in(), static_cast<const T*>(rhs)->filterClassName.in());
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterExpression.in(), static_cast<const T*>(rhs)->filterExpression.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ReaderAssociation>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::ReaderAssociation> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ReaderAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::ReaderAssociation>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReaderAssociation */


/* Begin TYPEDEF: WriterIdSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_WriterIdSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(82, 96, 79, 106, 153, 112, 94, 212, 196, 11, 234, 10, 185, 225));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_WriterIdSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::WriterIdSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::WriterIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::WriterIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::WriterIdSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::WriterIdSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::WriterIdSeq>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::WriterIdSeq>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::WriterIdSeq>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::RepoId> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::WriterIdSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::WriterIdSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::WriterIdSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::RepoId*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: WriterIdSeq */


/* Begin TYPEDEF: ReaderIdSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ReaderIdSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(82, 96, 79, 106, 153, 112, 94, 212, 196, 11, 234, 10, 185, 225));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ReaderIdSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ReaderIdSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ReaderIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ReaderIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::ReaderIdSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::ReaderIdSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ReaderIdSeq>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::ReaderIdSeq>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::RepoId>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::ReaderIdSeq>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::RepoId> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::ReaderIdSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::ReaderIdSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ReaderIdSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::RepoId*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ReaderIdSeq */


/* Begin TYPEDEF: String256 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_String256_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_String256_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: String256 */


/* Begin STRUCT: ContentFilterProperty_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ContentFilterProperty_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(119, 4, 180, 70, 2, 71, 100, 25, 64, 45, 106, 141, 80, 208));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ContentFilterProperty_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ContentFilterProperty_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"contentFilteredTopicName",0},{"relatedTopicName",1},{"filterClassName",2},{"filterExpression",3},{"expressionParameters",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.contentFilteredTopicName = x.c_str();
      }
      break;
    }
    case 1: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relatedTopicName = x.c_str();
      }
      break;
    }
    case 2: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.filterClassName = x.c_str();
      }
      break;
    }
    case 3: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.filterExpression = x.c_str();
      }
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.expressionParameters);
        if (!value_reader.begin_element()) return false;
        {
          String x;
          if (!value_reader.read_string(x)) return false;
          value.expressionParameters[i] = x.c_str();
        }
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ContentFilterProperty_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("contentFilteredTopicName");
  value_writer.write_string(value.contentFilteredTopicName);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("relatedTopicName");
  value_writer.write_string(value.relatedTopicName);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("filterClassName");
  value_writer.write_string(value.filterClassName);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("filterExpression");
  value_writer.write_string(value.filterExpression);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("expressionParameters");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.expressionParameters.length(); ++i) {
    value_writer.begin_element(i);
    value_writer.write_string(value.expressionParameters[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::ContentFilterProperty_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.contentFilteredTopicName = "";
  stru.relatedTopicName = "";
  stru.filterClassName = "";
  stru.filterExpression = "";
  stru.expressionParameters.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ContentFilterProperty_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.contentFilteredTopicName.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.relatedTopicName.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.filterClassName.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.filterExpression.in()) + 1;
  serialized_size(encoding, size, stru.expressionParameters);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ContentFilterProperty_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_string(stru.contentFilteredTopicName.in(), 256))
    && (strm << ACE_OutputCDR::from_string(stru.relatedTopicName.in(), 256))
    && (strm << ACE_OutputCDR::from_string(stru.filterClassName.in(), 256))
    && (strm << stru.filterExpression.in())
    && (strm << stru.expressionParameters);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ContentFilterProperty_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_string(stru.contentFilteredTopicName.out(), 256))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_string(stru.relatedTopicName.out(), 256))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_string(stru.filterClassName.out(), 256))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.filterExpression.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.expressionParameters)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ContentFilterProperty_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.contentFilteredTopicName.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.relatedTopicName.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.filterClassName.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.filterExpression.in()) + 1;
  serialized_size(encoding, size, stru.value.expressionParameters);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::ContentFilterProperty_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_string(stru.value.contentFilteredTopicName.in(), 256))
    && (strm << ACE_OutputCDR::from_string(stru.value.relatedTopicName.in(), 256))
    && (strm << ACE_OutputCDR::from_string(stru.value.filterClassName.in(), 256))
    && (strm << stru.value.filterExpression.in())
    && (strm << stru.value.expressionParameters);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ContentFilterProperty_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_string(stru.value.contentFilteredTopicName.out(), 256))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_string(stru.value.relatedTopicName.out(), 256))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_string(stru.value.filterClassName.out(), 256))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.filterExpression.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.expressionParameters)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::ContentFilterProperty_t> : MetaStruct {
  typedef  ::OpenDDS::DCPS::ContentFilterProperty_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("contentFilteredTopicName", 0),
      std::make_pair("relatedTopicName", 1),
      std::make_pair("filterClassName", 2),
      std::make_pair("filterExpression", 3),
      std::make_pair("expressionParameters", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ContentFilterProperty_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::ContentFilterProperty_t& typed = *static_cast<const  ::OpenDDS::DCPS::ContentFilterProperty_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return typed.contentFilteredTopicName.in();
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return typed.relatedTopicName.in();
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return typed.filterClassName.in();
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return typed.filterExpression.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ContentFilterProperty_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "contentFilteredTopicName") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'contentFilteredTopicName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'contentFilteredTopicName' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'contentFilteredTopicName' contents could not be skipped");
      }
    }
    if (base_field == "relatedTopicName") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'relatedTopicName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relatedTopicName' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relatedTopicName' contents could not be skipped");
      }
    }
    if (base_field == "filterClassName") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'filterClassName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'filterClassName' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'filterClassName' contents could not be skipped");
      }
    }
    if (base_field == "filterExpression") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'filterExpression' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'filterExpression' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'filterExpression' contents could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::StringSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return make_field_cmp(&T::contentFilteredTopicName, next);
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return make_field_cmp(&T::relatedTopicName, next);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return make_field_cmp(&T::filterClassName, next);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return make_field_cmp(&T::filterExpression, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ContentFilterProperty_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"contentFilteredTopicName", "relatedTopicName", "filterClassName", "filterExpression", "expressionParameters", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return &static_cast<const T*>(stru)->contentFilteredTopicName;
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return &static_cast<const T*>(stru)->relatedTopicName;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return &static_cast<const T*>(stru)->filterClassName;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return &static_cast<const T*>(stru)->filterExpression;
    }
    if (std::strcmp(field, "expressionParameters") == 0) {
      return &static_cast<const T*>(stru)->expressionParameters;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ContentFilterProperty_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      static_cast<T*>(lhs)->contentFilteredTopicName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      static_cast<T*>(lhs)->relatedTopicName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      static_cast<T*>(lhs)->filterClassName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      static_cast<T*>(lhs)->filterExpression = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expressionParameters") == 0) {
      static_cast<T*>(lhs)->expressionParameters = *static_cast<const  ::DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ContentFilterProperty_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->contentFilteredTopicName.in(), static_cast<const T*>(rhs)->contentFilteredTopicName.in());
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->relatedTopicName.in(), static_cast<const T*>(rhs)->relatedTopicName.in());
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterClassName.in(), static_cast<const T*>(rhs)->filterClassName.in());
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterExpression.in(), static_cast<const T*>(rhs)->filterExpression.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ContentFilterProperty_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ContentFilterProperty_t>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::ContentFilterProperty_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ContentFilterProperty_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::ContentFilterProperty_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ContentFilterProperty_t */


/* Begin STRUCT: ReaderProxy_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ReaderProxy_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(36, 21, 223, 88, 43, 90, 28, 135, 144, 217, 33, 207, 120, 116));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ReaderProxy_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ReaderProxy_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"remoteReaderGuid",0},{"expectsInlineQos",1},{"allLocators",2},{"associatedWriters",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.remoteReaderGuid)) return false;
      break;
    }
    case 1: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.expectsInlineQos = bx;
      }
      break;
    }
    case 2: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.allLocators);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.allLocators[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.associatedWriters);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.associatedWriters[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ReaderProxy_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("remoteReaderGuid");
  vwrite(value_writer, value.remoteReaderGuid);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("expectsInlineQos");
  value_writer.write_boolean(value.expectsInlineQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("allLocators");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.allLocators.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.allLocators[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("associatedWriters");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.associatedWriters.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.associatedWriters[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::ReaderProxy_t& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.remoteReaderGuid);
  stru.expectsInlineQos = 0;
  stru.allLocators.length(0);
  stru.associatedWriters.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ReaderProxy_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.remoteReaderGuid);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.expectsInlineQos));
  serialized_size(encoding, size, stru.allLocators);
  serialized_size(encoding, size, stru.associatedWriters);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ReaderProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.remoteReaderGuid)
    && (strm << ACE_OutputCDR::from_boolean(stru.expectsInlineQos))
    && (strm << stru.allLocators)
    && (strm << stru.associatedWriters);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ReaderProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.remoteReaderGuid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.expectsInlineQos))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.allLocators)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.associatedWriters)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ReaderProxy_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.remoteReaderGuid));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.expectsInlineQos));
  serialized_size(encoding, size, stru.value.allLocators);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUIDSeq>(stru.value.associatedWriters));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::ReaderProxy_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.remoteReaderGuid))
    && (strm << ACE_OutputCDR::from_boolean(stru.value.expectsInlineQos))
    && (strm << stru.value.allLocators)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUIDSeq>(stru.value.associatedWriters));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ReaderProxy_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_remoteReaderGuid_nested_key_only(stru.value.remoteReaderGuid);
  NestedKeyOnly< ::OpenDDS::DCPS::GUIDSeq> stru_value_associatedWriters_nested_key_only(stru.value.associatedWriters);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_remoteReaderGuid_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.expectsInlineQos))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.allLocators)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_associatedWriters_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::ReaderProxy_t> : MetaStruct {
  typedef  ::OpenDDS::DCPS::ReaderProxy_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("remoteReaderGuid", 0),
      std::make_pair("expectsInlineQos", 1),
      std::make_pair("allLocators", 2),
      std::make_pair("associatedWriters", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderProxy_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::ReaderProxy_t& typed = *static_cast<const  ::OpenDDS::DCPS::ReaderProxy_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.remoteReaderGuid, field + 17);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return typed.expectsInlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderProxy_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "remoteReaderGuid") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'remoteReaderGuid' could not be skipped");
      }
    }
    if (base_field == "expectsInlineQos") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUIDSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
      return make_struct_cmp(&T::remoteReaderGuid, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 17), next);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return make_field_cmp(&T::expectsInlineQos, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderProxy_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"remoteReaderGuid", "expectsInlineQos", "allLocators", "associatedWriters", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "remoteReaderGuid") == 0) {
      return &static_cast<const T*>(stru)->remoteReaderGuid;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return &static_cast<const T*>(stru)->expectsInlineQos;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      return &static_cast<const T*>(stru)->allLocators;
    }
    if (std::strcmp(field, "associatedWriters") == 0) {
      return &static_cast<const T*>(stru)->associatedWriters;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "remoteReaderGuid") == 0) {
      static_cast<T*>(lhs)->remoteReaderGuid = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      static_cast<T*>(lhs)->expectsInlineQos = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      static_cast<T*>(lhs)->allLocators = *static_cast<const  ::OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associatedWriters") == 0) {
      static_cast<T*>(lhs)->associatedWriters = *static_cast<const  ::OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderProxy_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return static_cast<const T*>(lhs)->expectsInlineQos == static_cast<const T*>(rhs)->expectsInlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ReaderProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ReaderProxy_t>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::ReaderProxy_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ReaderProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::ReaderProxy_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReaderProxy_t */


/* Begin STRUCT: DiscoveredReaderData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DiscoveredReaderData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(180, 8, 166, 2, 242, 192, 224, 208, 90, 123, 18, 118, 31, 225));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DiscoveredReaderData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DiscoveredReaderData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"ddsSubscriptionData",0},{"readerProxy",1},{"contentFilterProperty",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.ddsSubscriptionData)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.readerProxy)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.contentFilterProperty)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DiscoveredReaderData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("ddsSubscriptionData");
  vwrite(value_writer, value.ddsSubscriptionData);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerProxy");
  vwrite(value_writer, value.readerProxy);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("contentFilterProperty");
  vwrite(value_writer, value.contentFilterProperty);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DiscoveredReaderData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.ddsSubscriptionData);
  set_default(stru.readerProxy);
  set_default(stru.contentFilterProperty);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DiscoveredReaderData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.ddsSubscriptionData);
  serialized_size(encoding, size, stru.readerProxy);
  serialized_size(encoding, size, stru.contentFilterProperty);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DiscoveredReaderData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.ddsSubscriptionData)
    && (strm << stru.readerProxy)
    && (strm << stru.contentFilterProperty);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DiscoveredReaderData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ddsSubscriptionData)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerProxy)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.contentFilterProperty)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DiscoveredReaderData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::DDS::SubscriptionBuiltinTopicData>(stru.value.ddsSubscriptionData));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::ReaderProxy_t>(stru.value.readerProxy));
  serialized_size(encoding, size, stru.value.contentFilterProperty);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DiscoveredReaderData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::DDS::SubscriptionBuiltinTopicData>(stru.value.ddsSubscriptionData))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::ReaderProxy_t>(stru.value.readerProxy))
    && (strm << stru.value.contentFilterProperty);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DiscoveredReaderData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::DDS::SubscriptionBuiltinTopicData> stru_value_ddsSubscriptionData_nested_key_only(stru.value.ddsSubscriptionData);
  NestedKeyOnly< ::OpenDDS::DCPS::ReaderProxy_t> stru_value_readerProxy_nested_key_only(stru.value.readerProxy);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_ddsSubscriptionData_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerProxy_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.contentFilterProperty)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DiscoveredReaderData> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DiscoveredReaderData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("ddsSubscriptionData", 0),
      std::make_pair("readerProxy", 1),
      std::make_pair("contentFilterProperty", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredReaderData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DiscoveredReaderData& typed = *static_cast<const  ::OpenDDS::DCPS::DiscoveredReaderData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
      return getMetaStruct< ::DDS::SubscriptionBuiltinTopicData>().getValue(&typed.ddsSubscriptionData, field + 20);
    }
    if (std::strncmp(field, "readerProxy.", 12) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::ReaderProxy_t>().getValue(&typed.readerProxy, field + 12);
    }
    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::ContentFilterProperty_t>().getValue(&typed.contentFilterProperty, field + 22);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredReaderData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "ddsSubscriptionData") {
      return getMetaStruct< ::DDS::SubscriptionBuiltinTopicData>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::SubscriptionBuiltinTopicData*>(0))) {
        throw std::runtime_error("Field 'ddsSubscriptionData' could not be skipped");
      }
    }
    if (base_field == "readerProxy") {
      return getMetaStruct< ::OpenDDS::DCPS::ReaderProxy_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::ReaderProxy_t*>(0))) {
        throw std::runtime_error("Field 'readerProxy' could not be skipped");
      }
    }
    if (base_field == "contentFilterProperty") {
      return getMetaStruct< ::OpenDDS::DCPS::ContentFilterProperty_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::ContentFilterProperty_t*>(0))) {
        throw std::runtime_error("Field 'contentFilterProperty' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
      return make_struct_cmp(&T::ddsSubscriptionData, getMetaStruct< ::DDS::SubscriptionBuiltinTopicData>().create_qc_comparator(field + 20), next);
    }
    if (std::strncmp(field, "readerProxy.", 12) == 0) {
      return make_struct_cmp(&T::readerProxy, getMetaStruct< ::OpenDDS::DCPS::ReaderProxy_t>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
      return make_struct_cmp(&T::contentFilterProperty, getMetaStruct< ::OpenDDS::DCPS::ContentFilterProperty_t>().create_qc_comparator(field + 22), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredReaderData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsSubscriptionData", "readerProxy", "contentFilterProperty", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsSubscriptionData") == 0) {
      return &static_cast<const T*>(stru)->ddsSubscriptionData;
    }
    if (std::strcmp(field, "readerProxy") == 0) {
      return &static_cast<const T*>(stru)->readerProxy;
    }
    if (std::strcmp(field, "contentFilterProperty") == 0) {
      return &static_cast<const T*>(stru)->contentFilterProperty;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredReaderData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsSubscriptionData") == 0) {
      static_cast<T*>(lhs)->ddsSubscriptionData = *static_cast<const  ::DDS::SubscriptionBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerProxy") == 0) {
      static_cast<T*>(lhs)->readerProxy = *static_cast<const  ::OpenDDS::DCPS::ReaderProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "contentFilterProperty") == 0) {
      static_cast<T*>(lhs)->contentFilterProperty = *static_cast<const  ::OpenDDS::DCPS::ContentFilterProperty_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredReaderData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredReaderData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DiscoveredReaderData>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DiscoveredReaderData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DiscoveredReaderData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DiscoveredReaderData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DiscoveredReaderData */


/* Begin STRUCT: WriterProxy_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_WriterProxy_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(197, 3, 233, 56, 244, 213, 221, 209, 72, 250, 39, 98, 178, 240));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_WriterProxy_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::WriterProxy_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"remoteWriterGuid",0},{"allLocators",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.remoteWriterGuid)) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.allLocators);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.allLocators[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::WriterProxy_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("remoteWriterGuid");
  vwrite(value_writer, value.remoteWriterGuid);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("allLocators");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.allLocators.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.allLocators[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::WriterProxy_t& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.remoteWriterGuid);
  stru.allLocators.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::WriterProxy_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.remoteWriterGuid);
  serialized_size(encoding, size, stru.allLocators);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::WriterProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.remoteWriterGuid)
    && (strm << stru.allLocators);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::WriterProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.remoteWriterGuid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.allLocators)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::WriterProxy_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.remoteWriterGuid));
  serialized_size(encoding, size, stru.value.allLocators);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::WriterProxy_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.remoteWriterGuid))
    && (strm << stru.value.allLocators);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::WriterProxy_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_remoteWriterGuid_nested_key_only(stru.value.remoteWriterGuid);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_remoteWriterGuid_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.allLocators)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::WriterProxy_t> : MetaStruct {
  typedef  ::OpenDDS::DCPS::WriterProxy_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("remoteWriterGuid", 0),
      std::make_pair("allLocators", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterProxy_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::WriterProxy_t& typed = *static_cast<const  ::OpenDDS::DCPS::WriterProxy_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.remoteWriterGuid, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterProxy_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "remoteWriterGuid") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'remoteWriterGuid' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
      return make_struct_cmp(&T::remoteWriterGuid, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterProxy_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"remoteWriterGuid", "allLocators", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "remoteWriterGuid") == 0) {
      return &static_cast<const T*>(stru)->remoteWriterGuid;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      return &static_cast<const T*>(stru)->allLocators;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "remoteWriterGuid") == 0) {
      static_cast<T*>(lhs)->remoteWriterGuid = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      static_cast<T*>(lhs)->allLocators = *static_cast<const  ::OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterProxy_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::WriterProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::WriterProxy_t>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::WriterProxy_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::WriterProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::WriterProxy_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WriterProxy_t */


/* Begin STRUCT: DiscoveredWriterData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DiscoveredWriterData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 247, 148, 42, 187, 5, 147, 133, 124, 0, 28, 58, 48, 246));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DiscoveredWriterData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DiscoveredWriterData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"ddsPublicationData",0},{"writerProxy",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.ddsPublicationData)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.writerProxy)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DiscoveredWriterData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("ddsPublicationData");
  vwrite(value_writer, value.ddsPublicationData);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerProxy");
  vwrite(value_writer, value.writerProxy);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DiscoveredWriterData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.ddsPublicationData);
  set_default(stru.writerProxy);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DiscoveredWriterData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.ddsPublicationData);
  serialized_size(encoding, size, stru.writerProxy);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DiscoveredWriterData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.ddsPublicationData)
    && (strm << stru.writerProxy);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DiscoveredWriterData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ddsPublicationData)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerProxy)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DiscoveredWriterData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::DDS::PublicationBuiltinTopicData>(stru.value.ddsPublicationData));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::WriterProxy_t>(stru.value.writerProxy));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DiscoveredWriterData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::DDS::PublicationBuiltinTopicData>(stru.value.ddsPublicationData))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::WriterProxy_t>(stru.value.writerProxy));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DiscoveredWriterData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::DDS::PublicationBuiltinTopicData> stru_value_ddsPublicationData_nested_key_only(stru.value.ddsPublicationData);
  NestedKeyOnly< ::OpenDDS::DCPS::WriterProxy_t> stru_value_writerProxy_nested_key_only(stru.value.writerProxy);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_ddsPublicationData_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerProxy_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DiscoveredWriterData> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DiscoveredWriterData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("ddsPublicationData", 0),
      std::make_pair("writerProxy", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredWriterData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DiscoveredWriterData& typed = *static_cast<const  ::OpenDDS::DCPS::DiscoveredWriterData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
      return getMetaStruct< ::DDS::PublicationBuiltinTopicData>().getValue(&typed.ddsPublicationData, field + 19);
    }
    if (std::strncmp(field, "writerProxy.", 12) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::WriterProxy_t>().getValue(&typed.writerProxy, field + 12);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredWriterData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "ddsPublicationData") {
      return getMetaStruct< ::DDS::PublicationBuiltinTopicData>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PublicationBuiltinTopicData*>(0))) {
        throw std::runtime_error("Field 'ddsPublicationData' could not be skipped");
      }
    }
    if (base_field == "writerProxy") {
      return getMetaStruct< ::OpenDDS::DCPS::WriterProxy_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::WriterProxy_t*>(0))) {
        throw std::runtime_error("Field 'writerProxy' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
      return make_struct_cmp(&T::ddsPublicationData, getMetaStruct< ::DDS::PublicationBuiltinTopicData>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "writerProxy.", 12) == 0) {
      return make_struct_cmp(&T::writerProxy, getMetaStruct< ::OpenDDS::DCPS::WriterProxy_t>().create_qc_comparator(field + 12), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredWriterData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsPublicationData", "writerProxy", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsPublicationData") == 0) {
      return &static_cast<const T*>(stru)->ddsPublicationData;
    }
    if (std::strcmp(field, "writerProxy") == 0) {
      return &static_cast<const T*>(stru)->writerProxy;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredWriterData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsPublicationData") == 0) {
      static_cast<T*>(lhs)->ddsPublicationData = *static_cast<const  ::DDS::PublicationBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerProxy") == 0) {
      static_cast<T*>(lhs)->writerProxy = *static_cast<const  ::OpenDDS::DCPS::WriterProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredWriterData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DiscoveredWriterData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DiscoveredWriterData>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DiscoveredWriterData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DiscoveredWriterData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DiscoveredWriterData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DiscoveredWriterData */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

namespace {
XTypes::TypeObject minimal_to0()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(146, 200, 199, 70))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(27, 204, 23, 153))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(107, 155, 68, 175))))));
}

XTypes::TypeObject minimal_to1()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(236, 248, 8, 220, 236, 201, 133, 108, 218, 21, 16, 3, 142, 168))), XTypes::MinimalMemberDetail(199, 239, 99, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 235, 25, 172, 15, 65, 98, 13, 167, 52, 8, 137, 206, 198))), XTypes::MinimalMemberDetail(49, 73, 153, 166))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(171, 68, 106, 128))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(206, 148, 209, 100, 81, 125, 42, 181, 12, 217, 195, 161, 137, 0))), XTypes::MinimalMemberDetail(51, 88, 217, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(126, 56, 73, 18, 9, 183, 3, 167, 93, 113, 230, 154, 87, 113))), XTypes::MinimalMemberDetail(255, 6, 208, 45))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(55, 10, 190, 230, 50, 127, 48, 223, 212, 68, 18, 125, 171, 30))), XTypes::MinimalMemberDetail(141, 13, 132, 5))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(188, 129, 128, 87))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(228, 9, 248, 126))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(138, 152, 206, 56))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(133, 110, 66, 236))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(148, 23, 1, 140))))));
}

XTypes::TypeObject minimal_to2()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))), XTypes::MinimalMemberDetail(43, 95, 162, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))), XTypes::MinimalMemberDetail(60, 209, 95, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))), XTypes::MinimalMemberDetail(15, 202, 164, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(27, 42, 197, 216))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(13, 138, 191, 79))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(170, 93, 128, 221))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(14, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(151, 133, 93, 97, 88, 230, 235, 85, 240, 208, 235, 75, 68, 253))), XTypes::MinimalMemberDetail(161, 47, 124, 21))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(15, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))))));
}

XTypes::TypeObject minimal_to3()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(3), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to4()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to5()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_STRING8_LARGE, XTypes::StringLTypeDefn(256)))))));
}

XTypes::TypeObject minimal_to6()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85)))))));
}

XTypes::TypeObject minimal_to7()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(124, 184, 31, 69))))));
}

XTypes::TypeObject minimal_to8()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(206, 148, 209, 100, 81, 125, 42, 181, 12, 217, 195, 161, 137, 0))), XTypes::MinimalMemberDetail(184, 11, 183, 116))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(20, 57, 77, 168))))));
}

XTypes::TypeObject minimal_to9()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(131, 209, 126, 235))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(84, 1, 88, 35))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(236, 248, 8, 220, 236, 201, 133, 108, 218, 21, 16, 3, 142, 168))), XTypes::MinimalMemberDetail(87, 234, 49, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))), XTypes::MinimalMemberDetail(84, 101, 201, 4))))));
}

XTypes::TypeObject minimal_to10()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(235, 102, 36, 53))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(170, 93, 128, 221))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(34, 23, 141, 102))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(26, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(27, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(29, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(30, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))), XTypes::MinimalMemberDetail(43, 95, 162, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(31, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(33, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))), XTypes::MinimalMemberDetail(36, 134, 146, 58))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(35, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(37, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(39, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(41, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))), XTypes::MinimalMemberDetail(112, 19, 186, 155))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(43, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(13, 138, 191, 79))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(44, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(45, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(249, 86, 165, 139))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(46, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(141, 115, 88, 91))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(129, 113, 223, 135))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(90, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(60, 110, 11, 138))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(115, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))))));
}

XTypes::TypeObject minimal_to11()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(157, 89, 81, 62))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 184, 244, 149, 52, 65, 12, 119, 163, 176, 63, 222, 239, 135))), XTypes::MinimalMemberDetail(141, 119, 127, 56))))));
}

XTypes::TypeObject minimal_to12()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))), XTypes::MinimalMemberDetail(60, 209, 95, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))), XTypes::MinimalMemberDetail(15, 202, 164, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37))), XTypes::MinimalMemberDetail(248, 53, 38, 241))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(128, 6, 106, 169, 239, 151, 91, 255, 81, 243, 37, 38, 187, 17))), XTypes::MinimalMemberDetail(201, 231, 175, 233))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225))), XTypes::MinimalMemberDetail(184, 135, 19, 246))))));
}

XTypes::TypeObject minimal_to13()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to14()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 124, 74, 82, 33, 209, 171, 154, 100, 92, 69, 182, 34, 215))), XTypes::MinimalMemberDetail(144, 105, 124, 76))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(28, 106, 127, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(25, 186, 87, 68))))));
}

XTypes::TypeObject minimal_to15()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(184, 94, 195, 20))))));
}

XTypes::TypeObject minimal_to16()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(233, 42, 172, 155))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(208, 123, 134, 189))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(11, 60, 225, 99))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(3, 0), XTypes::MinimalMemberDetail(47, 181, 127, 223))))));
}

XTypes::TypeObject minimal_to17()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(212, 19, 36, 204, 216, 207, 229, 8, 101, 152, 15, 215, 71, 23))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to18()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(16), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to19()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148)))))))));
}

XTypes::TypeObject minimal_to20()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(116, 69, 156, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 4, 100, 213))))));
}

XTypes::TypeObject minimal_to21()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(206, 148, 209, 100, 81, 125, 42, 181, 12, 217, 195, 161, 137, 0)))))))));
}

XTypes::TypeObject minimal_to22()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(18, 160, 85, 191))))));
}

XTypes::TypeObject minimal_to23()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(62, 114, 125, 184, 14, 246, 184, 86, 96, 15, 47, 72, 182, 26))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to24()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))), XTypes::MinimalMemberDetail(253, 35, 86, 164))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))), XTypes::MinimalMemberDetail(152, 150, 76, 59))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))), XTypes::MinimalMemberDetail(188, 129, 128, 87))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(228, 9, 248, 126))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(80, 138, 45, 158))))));
}

XTypes::TypeObject minimal_to25()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(104, 240, 63, 69))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(106, 40, 90, 134))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(230, 32, 45, 146))))));
}

XTypes::TypeObject minimal_to26()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to27()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(12, 87, 212, 43))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))), XTypes::MinimalMemberDetail(35, 210, 249, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(82, 73, 45, 112))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(167, 83, 247, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(65, 192, 149, 169))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(1, 216, 160, 135))))));
}

XTypes::TypeObject minimal_to28()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(52, 66, 30, 3))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(20, 188, 11, 46))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(188, 222, 35, 31))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(180, 45, 19, 101, 194, 86, 184, 210, 220, 168, 163, 127, 201, 93))), XTypes::MinimalMemberDetail(148, 66, 47, 166))))));
}

XTypes::TypeObject minimal_to29()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(1, 78, 93, 82, 90, 169, 236, 225, 40, 97, 126, 118, 81, 144))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(223, 134, 34, 208))))));
}

XTypes::TypeObject minimal_to30()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))), XTypes::MinimalMemberDetail(36, 134, 146, 58))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))), XTypes::MinimalMemberDetail(112, 19, 186, 155))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(249, 86, 165, 139))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(208, 131, 188, 155, 96, 118, 238, 78, 31, 220, 1, 243, 99, 160))), XTypes::MinimalMemberDetail(196, 4, 33, 100))))));
}

XTypes::TypeObject minimal_to31()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(217, 161, 56, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(157, 130, 84, 170))))));
}

XTypes::TypeObject minimal_to32()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(167, 83, 247, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(65, 192, 149, 169))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(1, 216, 160, 135))))));
}

XTypes::TypeObject minimal_to33()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT32))))));
}

XTypes::TypeObject minimal_to34()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(174, 221, 205, 216))))));
}

XTypes::TypeObject minimal_to35()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(64, 188, 63, 150))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(5, 165, 180, 122))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(107, 61, 225, 31))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(70, 41, 47, 174))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(245, 160, 163, 241))))));
}

XTypes::TypeObject minimal_to36()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0)))))))));
}

XTypes::TypeObject minimal_to37()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(36, 50, 236, 40, 121, 209, 47, 107, 124, 179, 72, 134, 177, 69))), XTypes::MinimalMemberDetail(160, 23, 193, 195))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(197, 3, 233, 56, 244, 213, 221, 209, 72, 250, 39, 98, 178, 240))), XTypes::MinimalMemberDetail(59, 146, 71, 232))))));
}

XTypes::TypeObject minimal_to38()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(177, 178, 109, 157))))));
}

XTypes::TypeObject minimal_to39()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(12), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to40()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(152, 105, 11, 246))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(200, 207, 110, 234))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(62, 145, 142, 156))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(3, 0), XTypes::MinimalMemberDetail(140, 2, 84, 122))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(4, 0), XTypes::MinimalMemberDetail(179, 70, 23, 69))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(5, 0), XTypes::MinimalMemberDetail(234, 196, 93, 88))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(6, 0), XTypes::MinimalMemberDetail(136, 114, 125, 37))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(7, 0), XTypes::MinimalMemberDetail(232, 192, 199, 8))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(8, 0), XTypes::MinimalMemberDetail(31, 117, 41, 15))))));
}

XTypes::TypeObject minimal_to41()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(122, 244, 39, 138))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(142, 251, 174, 249))))));
}

XTypes::TypeObject minimal_to42()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 2, 1, 165, 140, 132, 125, 160, 139, 76, 161, 70, 60, 186))), XTypes::MinimalMemberDetail(228, 222, 171, 175))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(36, 21, 223, 88, 43, 90, 28, 135, 144, 217, 33, 207, 120, 116))), XTypes::MinimalMemberDetail(89, 214, 70, 53))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(119, 4, 180, 70, 2, 71, 100, 25, 64, 45, 106, 141, 80, 208))), XTypes::MinimalMemberDetail(12, 108, 154, 97))))));
}

XTypes::TypeObject minimal_to43()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(187, 206, 175, 130, 167, 249, 57, 105, 219, 219, 138, 84, 110, 94)))))))));
}

XTypes::TypeObject minimal_to44()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37))), XTypes::MinimalMemberDetail(248, 53, 38, 241))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(235, 102, 36, 53))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(34, 23, 141, 102))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(26, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(27, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(29, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(31, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(33, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))), XTypes::MinimalMemberDetail(36, 134, 146, 58))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(35, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(37, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(39, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(41, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))), XTypes::MinimalMemberDetail(112, 19, 186, 155))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(44, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(45, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(249, 86, 165, 139))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(46, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(141, 115, 88, 91))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(129, 113, 223, 135))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(90, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(60, 110, 11, 138))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(115, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(116, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225))), XTypes::MinimalMemberDetail(184, 135, 19, 246))))));
}

XTypes::TypeObject minimal_to45()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT16))))));
}

XTypes::TypeObject minimal_to46()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(236, 248, 8, 220, 236, 201, 133, 108, 218, 21, 16, 3, 142, 168))), XTypes::MinimalMemberDetail(89, 4, 80, 36))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 235, 25, 172, 15, 65, 98, 13, 167, 52, 8, 137, 206, 198))), XTypes::MinimalMemberDetail(51, 232, 197, 213))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(171, 68, 106, 128))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(206, 148, 209, 100, 81, 125, 42, 181, 12, 217, 195, 161, 137, 0))), XTypes::MinimalMemberDetail(106, 125, 250, 119))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(126, 56, 73, 18, 9, 183, 3, 167, 93, 113, 230, 154, 87, 113))), XTypes::MinimalMemberDetail(42, 70, 242, 8))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(9, 122, 150, 104, 250, 78, 157, 83, 255, 157, 123, 250, 229, 93))), XTypes::MinimalMemberDetail(135, 238, 83, 44))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(133, 110, 66, 236))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(148, 23, 1, 140))))));
}

XTypes::TypeObject minimal_to47()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(202, 176, 202, 19))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(226, 148, 42, 4))))));
}

XTypes::TypeObject minimal_to48()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253)))))))));
}

XTypes::TypeObject minimal_to49()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(19, 154, 62, 30))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(236, 248, 8, 220, 236, 201, 133, 108, 218, 21, 16, 3, 142, 168))), XTypes::MinimalMemberDetail(87, 234, 49, 143))))));
}

XTypes::TypeObject minimal_to50()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(176, 104, 147, 28))))));
}

XTypes::TypeObject minimal_to51()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253)))))));
}

XTypes::TypeObject minimal_to52()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(16, 167, 14, 140))))));
}

XTypes::TypeObject minimal_to53()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to54()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(253, 72, 63, 147, 206, 16, 241, 72, 186, 231, 206, 213, 79, 158))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to55()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(43, 67, 125, 32))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(249, 191, 143, 65))))));
}

XTypes::TypeObject minimal_to56()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))), XTypes::MinimalMemberDetail(87, 2, 74, 74))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(61, 5, 144, 205))))));
}

XTypes::TypeObject minimal_to57()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 31, 169, 229, 223, 19, 38, 65, 134, 73, 192, 156, 90, 188))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to58()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 235, 25, 172, 15, 65, 98, 13, 167, 52, 8, 137, 206, 198)))))))));
}

XTypes::TypeObject minimal_to59()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 115, 43, 233, 139, 29, 28, 130, 117, 249, 188, 147, 54, 250))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(2, 5, 193, 190))))));
}

XTypes::TypeObject minimal_to60()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(68, 71, 41, 218))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(139, 230, 147, 131))))));
}

XTypes::TypeObject minimal_to61()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(160, 172, 250, 70))))));
}

XTypes::TypeObject minimal_to62()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(107, 157, 171, 99))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(175, 93, 205, 154))))));
}

XTypes::TypeObject minimal_to63()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(116, 69, 156, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 4, 100, 213))))));
}

XTypes::TypeMap get_minimal_type_map_private()
{
  XTypes::TypeMap tm;
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(1, 78, 93, 82, 90, 169, 236, 225, 40, 97, 126, 118, 81, 144))] = minimal_to0();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(5, 102, 80, 116, 41, 244, 222, 116, 5, 254, 50, 13, 195, 172))] = minimal_to1();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(9, 122, 150, 104, 250, 78, 157, 83, 255, 157, 123, 250, 229, 93))] = minimal_to2();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))] = minimal_to3();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))] = minimal_to4();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))] = minimal_to5();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 184, 244, 149, 52, 65, 12, 119, 163, 176, 63, 222, 239, 135))] = minimal_to6();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37))] = minimal_to7();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(34, 31, 35, 130, 77, 65, 129, 167, 192, 171, 71, 167, 106, 34))] = minimal_to8();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(36, 21, 223, 88, 43, 90, 28, 135, 144, 217, 33, 207, 120, 116))] = minimal_to9();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(36, 50, 236, 40, 121, 209, 47, 107, 124, 179, 72, 134, 177, 69))] = minimal_to10();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 235, 25, 172, 15, 65, 98, 13, 167, 52, 8, 137, 206, 198))] = minimal_to11();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(55, 10, 190, 230, 50, 127, 48, 223, 212, 68, 18, 125, 171, 30))] = minimal_to12();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))] = minimal_to13();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))] = minimal_to14();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))] = minimal_to15();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(62, 114, 125, 184, 14, 246, 184, 86, 96, 15, 47, 72, 182, 26))] = minimal_to16();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))] = minimal_to17();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))] = minimal_to18();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 31, 169, 229, 223, 19, 38, 65, 134, 73, 192, 156, 90, 188))] = minimal_to19();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))] = minimal_to20();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(82, 96, 79, 106, 153, 112, 94, 212, 196, 11, 234, 10, 185, 225))] = minimal_to21();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))] = minimal_to22();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))] = minimal_to23();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(119, 4, 180, 70, 2, 71, 100, 25, 64, 45, 106, 141, 80, 208))] = minimal_to24();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 124, 74, 82, 33, 209, 171, 154, 100, 92, 69, 182, 34, 215))] = minimal_to25();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))] = minimal_to26();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))] = minimal_to27();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(122, 164, 141, 199, 34, 3, 12, 157, 70, 146, 76, 48, 42, 168))] = minimal_to28();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))] = minimal_to29();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(126, 56, 73, 18, 9, 183, 3, 167, 93, 113, 230, 154, 87, 113))] = minimal_to30();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(128, 6, 106, 169, 239, 151, 91, 255, 81, 243, 37, 38, 187, 17))] = minimal_to31();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))] = minimal_to32();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))] = minimal_to33();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(151, 133, 93, 97, 88, 230, 235, 85, 240, 208, 235, 75, 68, 253))] = minimal_to34();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225))] = minimal_to35();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))] = minimal_to36();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 247, 148, 42, 187, 5, 147, 133, 124, 0, 28, 58, 48, 246))] = minimal_to37();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))] = minimal_to38();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))] = minimal_to39();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(170, 8, 164, 71, 199, 171, 74, 67, 145, 50, 111, 104, 167, 217))] = minimal_to40();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 115, 43, 233, 139, 29, 28, 130, 117, 249, 188, 147, 54, 250))] = minimal_to41();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(180, 8, 166, 2, 242, 192, 224, 208, 90, 123, 18, 118, 31, 225))] = minimal_to42();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(180, 45, 19, 101, 194, 86, 184, 210, 220, 168, 163, 127, 201, 93))] = minimal_to43();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 2, 1, 165, 140, 132, 125, 160, 139, 76, 161, 70, 60, 186))] = minimal_to44();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148))] = minimal_to45();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(185, 78, 152, 175, 105, 253, 69, 207, 164, 112, 96, 247, 184, 154))] = minimal_to46();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(187, 206, 175, 130, 167, 249, 57, 105, 219, 219, 138, 84, 110, 94))] = minimal_to47();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))] = minimal_to48();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(197, 3, 233, 56, 244, 213, 221, 209, 72, 250, 39, 98, 178, 240))] = minimal_to49();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))] = minimal_to50();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(206, 148, 209, 100, 81, 125, 42, 181, 12, 217, 195, 161, 137, 0))] = minimal_to51();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(208, 131, 188, 155, 96, 118, 238, 78, 31, 220, 1, 243, 99, 160))] = minimal_to52();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))] = minimal_to53();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))] = minimal_to54();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(212, 19, 36, 204, 216, 207, 229, 8, 101, 152, 15, 215, 71, 23))] = minimal_to55();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))] = minimal_to56();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))] = minimal_to57();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(236, 248, 8, 220, 236, 201, 133, 108, 218, 21, 16, 3, 142, 168))] = minimal_to58();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))] = minimal_to59();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))] = minimal_to60();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))] = minimal_to61();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(253, 72, 63, 147, 206, 16, 241, 72, 186, 231, 206, 213, 79, 158))] = minimal_to62();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))] = minimal_to63();
  return tm;
}

}

const XTypes::TypeMap& get_minimal_type_map()
{
  static XTypes::TypeMap tm;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), tm);
  if (tm.empty()) {
    tm = get_minimal_type_map_private();
  }
  return tm;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

