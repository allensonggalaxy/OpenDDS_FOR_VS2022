/* Generated by ..\bin\opendds_idl version 3.20.0 (ACE version 6.2a_p23) running on input file DdsDcpsGuid.idl */
#include "DCPS/DdsDcps_pch.h"
#include "DdsDcpsGuidTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/PoolAllocator.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GuidVendorId_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(223, 137, 245, 17, 179, 98, 96, 20, 237, 41, 215, 82, 255, 127));
  }
  return ti;
}

static const XTypes::TypeMap& get_minimal_type_map();
template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GuidVendorId_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::GuidVendorId_t_forany& arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
    arr[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GuidVendorId_t_forany& arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size_octet(encoding, size, 2);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GuidVendorId_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_octet_array(arr.in(), 2);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GuidVendorId_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_octet_array(arr.out(), 2);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GuidVendorId_t_forany*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(2, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GuidPrefix_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GuidPrefix_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::GuidPrefix_t_forany& arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
    arr[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GuidPrefix_t_forany& arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size_octet(encoding, size, 12);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GuidPrefix_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_octet_array(arr.in(), 12);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GuidPrefix_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_octet_array(arr.out(), 12);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GuidPrefix_t_forany*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(12, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_EntityKey_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_EntityKey_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::EntityKey_t_forany& arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    arr[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::EntityKey_t_forany& arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size_octet(encoding, size, 3);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::EntityKey_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_octet_array(arr.in(), 3);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::EntityKey_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_octet_array(arr.out(), 3);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::EntityKey_t_forany*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(3, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_EntityId_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_EntityId_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::EntityId_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"entityKey",0},{"entityKind",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.entityKey, 3)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_byte(value.entityKind)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::EntityId_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("entityKey");
  value_writer.begin_array();
  value_writer.write_byte_array (value.entityKey, 3);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("entityKind");
  value_writer.write_byte(value.entityKind);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::EntityId_t& stru)
{
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::DCPS::EntityKey_t_forany stru_entityKey_temp(const_cast< ::OpenDDS::DCPS::EntityKey_t_slice*>(stru.entityKey));
  set_default(stru_entityKey_temp);
  stru.entityKind = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::EntityId_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::DCPS::EntityKey_t_forany stru_entityKey_forany(const_cast< ::OpenDDS::DCPS::EntityKey_t_slice*>(stru.entityKey));
  serialized_size(encoding, size, stru_entityKey_forany);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.entityKind));
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::EntityId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
   ::OpenDDS::DCPS::EntityKey_t_forany stru_entityKey_forany(const_cast< ::OpenDDS::DCPS::EntityKey_t_slice*>(stru.entityKey));
  return (strm << stru_entityKey_forany)
    && (strm << ACE_OutputCDR::from_octet(stru.entityKind));
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::EntityId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
   ::OpenDDS::DCPS::EntityKey_t_forany stru_entityKey_forany(const_cast< ::OpenDDS::DCPS::EntityKey_t_slice*>(stru.entityKey));
  return (strm >> stru_entityKey_forany)
    && (strm >> ACE_InputCDR::to_octet(stru.entityKind));
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::DCPS::EntityKey_t_forany stru_value_entityKey_forany(const_cast< ::OpenDDS::DCPS::EntityKey_t_slice*>(stru.value.entityKey));
  serialized_size(encoding, size, stru_value_entityKey_forany);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.value.entityKind));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
   ::OpenDDS::DCPS::EntityKey_t_forany stru_value_entityKey_forany(const_cast< ::OpenDDS::DCPS::EntityKey_t_slice*>(stru.value.entityKey));
  return (strm << stru_value_entityKey_forany)
    && (strm << ACE_OutputCDR::from_octet(stru.value.entityKind));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
   ::OpenDDS::DCPS::EntityKey_t_forany stru_value_entityKey_forany(const_cast< ::OpenDDS::DCPS::EntityKey_t_slice*>(stru.value.entityKey));
  return (strm >> stru_value_entityKey_forany)
    && (strm >> ACE_InputCDR::to_octet(stru.value.entityKind));
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::EntityId_t> : MetaStruct {
  typedef  ::OpenDDS::DCPS::EntityId_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("entityKey", 0),
      std::make_pair("entityKind", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::EntityId_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::EntityId_t& typed = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "entityKind") == 0) {
      return typed.entityKind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::EntityId_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityKey_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "entityKind") {
      ACE_CDR::Octet val;
      if (!(strm >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'entityKind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'entityKind' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "entityKind") == 0) {
      return make_field_cmp(&T::entityKind, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::EntityId_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"entityKey", "entityKind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "entityKey") == 0) {
      return &static_cast<const T*>(stru)->entityKey;
    }
    if (std::strcmp(field, "entityKind") == 0) {
      return &static_cast<const T*>(stru)->entityKind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::EntityId_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "entityKey") == 0) {
       ::OpenDDS::DCPS::EntityKey_t* lhsArr = &static_cast<T*>(lhs)->entityKey;
      const  ::OpenDDS::DCPS::EntityKey_t* rhsArr = static_cast<const  ::OpenDDS::DCPS::EntityKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "entityKind") == 0) {
      static_cast<T*>(lhs)->entityKind = *static_cast<const  ::CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::EntityId_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "entityKind") == 0) {
      return static_cast<const T*>(lhs)->entityKind == static_cast<const T*>(rhs)->entityKind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::EntityId_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::EntityId_t>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::EntityId_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::EntityId_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::EntityId_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GUID_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GUID_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::GUID_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"guidPrefix",0},{"entityId",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.guidPrefix, 12)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.entityId)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::GUID_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("guidPrefix");
  value_writer.begin_array();
  value_writer.write_byte_array (value.guidPrefix, 12);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("entityId");
  vwrite(value_writer, value.entityId);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::GUID_t& stru)
{
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_temp(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  set_default(stru_guidPrefix_temp);
  set_default(stru.entityId);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GUID_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  serialized_size(encoding, size, stru_guidPrefix_forany);
  serialized_size(encoding, size, stru.entityId);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GUID_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru_guidPrefix_forany)
    && (strm << stru.entityId);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GUID_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru_guidPrefix_forany)
    && (strm >> stru.entityId);
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  serialized_size(encoding, size, stru_value_guidPrefix_forany);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.entityId));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  return (strm << stru_value_guidPrefix_forany)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.entityId));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::GUID_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_entityId_nested_key_only(stru.value.entityId);
  return (strm >> stru_value_guidPrefix_forany)
    && (strm >> stru_value_entityId_nested_key_only);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::GUID_t> : MetaStruct {
  typedef  ::OpenDDS::DCPS::GUID_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("guidPrefix", 0),
      std::make_pair("entityId", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GUID_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::GUID_t& typed = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "entityId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.entityId, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GUID_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "entityId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'entityId' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "entityId.", 9) == 0) {
      return make_struct_cmp(&T::entityId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GUID_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"guidPrefix", "entityId", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    if (std::strcmp(field, "entityId") == 0) {
      return &static_cast<const T*>(stru)->entityId;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GUID_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "guidPrefix") == 0) {
       ::OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const  ::OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const  ::OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "entityId") == 0) {
      static_cast<T*>(lhs)->entityId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GUID_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GUID_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::GUID_t>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::GUID_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GUID_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::GUID_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GUIDSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GUIDSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GUIDSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GUIDSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GUIDSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::GUIDSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::GUIDSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::GUIDSeq>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::GUIDSeq>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::GUIDSeq>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::GUIDSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::GUIDSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GUIDSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

namespace {
XTypes::TypeObject minimal_to0()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(3), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to1()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(177, 178, 109, 157))))));
}

XTypes::TypeObject minimal_to2()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(12), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to3()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253)))))))));
}

XTypes::TypeObject minimal_to4()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(2), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to5()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))), XTypes::MinimalMemberDetail(87, 2, 74, 74))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(61, 5, 144, 205))))));
}

XTypes::TypeMap get_minimal_type_map_private()
{
  XTypes::TypeMap tm;
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))] = minimal_to0();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))] = minimal_to1();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))] = minimal_to2();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))] = minimal_to3();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(223, 137, 245, 17, 179, 98, 96, 20, 237, 41, 215, 82, 255, 127))] = minimal_to4();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))] = minimal_to5();
  return tm;
}

}

const XTypes::TypeMap& get_minimal_type_map()
{
  static XTypes::TypeMap tm;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), tm);
  if (tm.empty()) {
    tm = get_minimal_type_map_private();
  }
  return tm;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

