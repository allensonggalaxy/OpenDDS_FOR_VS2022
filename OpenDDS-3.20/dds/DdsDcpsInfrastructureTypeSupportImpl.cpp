/* Generated by ..\bin\opendds_idl version 3.20.0 (ACE version 6.2a_p23) running on input file DdsDcpsInfrastructure.idl */
#include "DCPS/DdsDcps_pch.h"
#include "DdsDcpsInfrastructureTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: DDS */



/* Begin INTERFACE-FWD: Condition */


/* End INTERFACE-FWD: Condition */


/* Begin TYPEDEF: ConditionSeq */


/* End TYPEDEF: ConditionSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DomainId_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211));
  }
  return ti;
}

static const XTypes::TypeMap& get_minimal_type_map();
template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DomainId_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: ReturnCode_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ReturnCode_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_ReturnCode_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ReturnCode_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_StatusKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_StatusKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_StatusMask_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_StatusMask_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InconsistentTopicStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 128, 160, 117, 69, 76, 234, 57, 156, 223, 61, 65, 196, 175));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_InconsistentTopicStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::InconsistentTopicStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::InconsistentTopicStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::InconsistentTopicStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::InconsistentTopicStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
}

bool operator<<(Serializer& strm, const  ::DDS::InconsistentTopicStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change);
}

bool operator>>(Serializer& strm,  ::DDS::InconsistentTopicStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::InconsistentTopicStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::InconsistentTopicStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::InconsistentTopicStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::InconsistentTopicStatus> : MetaStruct {
  typedef  ::DDS::InconsistentTopicStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::InconsistentTopicStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::InconsistentTopicStatus& typed = *static_cast<const  ::DDS::InconsistentTopicStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::InconsistentTopicStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::InconsistentTopicStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::InconsistentTopicStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::InconsistentTopicStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::InconsistentTopicStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::InconsistentTopicStatus>()
{
  static MetaStructImpl< ::DDS::InconsistentTopicStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::InconsistentTopicStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::InconsistentTopicStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleLostStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 128, 160, 117, 69, 76, 234, 57, 156, 223, 61, 65, 196, 175));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleLostStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SampleLostStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SampleLostStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::SampleLostStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::SampleLostStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
}

bool operator<<(Serializer& strm, const  ::DDS::SampleLostStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change);
}

bool operator>>(Serializer& strm,  ::DDS::SampleLostStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::SampleLostStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::SampleLostStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SampleLostStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::SampleLostStatus> : MetaStruct {
  typedef  ::DDS::SampleLostStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleLostStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::SampleLostStatus& typed = *static_cast<const  ::DDS::SampleLostStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleLostStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleLostStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleLostStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleLostStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleLostStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::SampleLostStatus>()
{
  static MetaStructImpl< ::DDS::SampleLostStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::SampleLostStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::SampleLostStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleRejectedStatusKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(26, 28, 21, 155, 172, 168, 92, 103, 118, 83, 252, 122, 171, 74));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleRejectedStatusKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SampleRejectedStatusKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"NOT_REJECTED",0},{"REJECTED_BY_INSTANCES_LIMIT",1},{"REJECTED_BY_SAMPLES_LIMIT",2},{"REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT",3},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SampleRejectedStatusKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case DDS::NOT_REJECTED:
    value_writer.write_enum("NOT_REJECTED", DDS::NOT_REJECTED);
    break;
  case DDS::REJECTED_BY_INSTANCES_LIMIT:
    value_writer.write_enum("REJECTED_BY_INSTANCES_LIMIT", DDS::REJECTED_BY_INSTANCES_LIMIT);
    break;
  case DDS::REJECTED_BY_SAMPLES_LIMIT:
    value_writer.write_enum("REJECTED_BY_SAMPLES_LIMIT", DDS::REJECTED_BY_SAMPLES_LIMIT);
    break;
  case DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT:
    value_writer.write_enum("REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT", DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::DDS::SampleRejectedStatusKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 4) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::DDS::SampleRejectedStatusKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::DDS::SampleRejectedStatusKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 4) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::DDS::SampleRejectedStatusKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_SampleRejectedStatusKind_names[] = {
  "NOT_REJECTED",
  "REJECTED_BY_INSTANCES_LIMIT",
  "REJECTED_BY_SAMPLES_LIMIT",
  "REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT"
};
const size_t gen_DDS_SampleRejectedStatusKind_names_size = 4;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleRejectedStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 238, 206, 96, 216, 194, 176, 195, 111, 193, 164, 132, 163, 100));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleRejectedStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SampleRejectedStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{"last_reason",2},{"last_instance_handle",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.last_reason)) return false;
      break;
    }
    case 3: {
      if (!value_reader.read_int32(value.last_instance_handle)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SampleRejectedStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_reason");
  vwrite(value_writer, value.last_reason);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_instance_handle");
  value_writer.write_int32(value.last_instance_handle);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::SampleRejectedStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
  stru.last_reason =  ::DDS::NOT_REJECTED;
  stru.last_instance_handle = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::SampleRejectedStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
  primitive_serialized_size_ulong(encoding, size);
  primitive_serialized_size(encoding, size, stru.last_instance_handle);
}

bool operator<<(Serializer& strm, const  ::DDS::SampleRejectedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_reason)
    && (strm << stru.last_instance_handle);
}

bool operator>>(Serializer& strm,  ::DDS::SampleRejectedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_reason)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_instance_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::SampleRejectedStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
  primitive_serialized_size_ulong(encoding, size);
  primitive_serialized_size(encoding, size, stru.value.last_instance_handle);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::SampleRejectedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change)
    && (strm << stru.value.last_reason)
    && (strm << stru.value.last_instance_handle);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SampleRejectedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_reason)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_instance_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::SampleRejectedStatus> : MetaStruct {
  typedef  ::DDS::SampleRejectedStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
      std::make_pair("last_reason", 2),
      std::make_pair("last_instance_handle", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleRejectedStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::SampleRejectedStatus& typed = *static_cast<const  ::DDS::SampleRejectedStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_reason") == 0) {
      return gen_DDS_SampleRejectedStatusKind_names[typed.last_reason];
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return typed.last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleRejectedStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (base_field == "last_reason") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_reason' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_reason' could not be skipped");
      }
    }
    if (base_field == "last_instance_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_instance_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_instance_handle' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_reason") == 0) {
      return make_field_cmp(&T::last_reason, next);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return make_field_cmp(&T::last_instance_handle, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleRejectedStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_reason", "last_instance_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_reason") == 0) {
      return &static_cast<const T*>(stru)->last_reason;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return &static_cast<const T*>(stru)->last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleRejectedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_reason") == 0) {
      static_cast<T*>(lhs)->last_reason = *static_cast<const  ::DDS::SampleRejectedStatusKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      static_cast<T*>(lhs)->last_instance_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleRejectedStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_reason") == 0) {
      return static_cast<const T*>(lhs)->last_reason == static_cast<const T*>(rhs)->last_reason;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return static_cast<const T*>(lhs)->last_instance_handle == static_cast<const T*>(rhs)->last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleRejectedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::SampleRejectedStatus>()
{
  static MetaStructImpl< ::DDS::SampleRejectedStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::SampleRejectedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::SampleRejectedStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LivelinessLostStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 128, 160, 117, 69, 76, 234, 57, 156, 223, 61, 65, 196, 175));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_LivelinessLostStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LivelinessLostStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LivelinessLostStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::LivelinessLostStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::LivelinessLostStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
}

bool operator<<(Serializer& strm, const  ::DDS::LivelinessLostStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change);
}

bool operator>>(Serializer& strm,  ::DDS::LivelinessLostStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::LivelinessLostStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::LivelinessLostStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::LivelinessLostStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::LivelinessLostStatus> : MetaStruct {
  typedef  ::DDS::LivelinessLostStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessLostStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::LivelinessLostStatus& typed = *static_cast<const  ::DDS::LivelinessLostStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessLostStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessLostStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessLostStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessLostStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessLostStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::LivelinessLostStatus>()
{
  static MetaStructImpl< ::DDS::LivelinessLostStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::LivelinessLostStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::LivelinessLostStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LivelinessChangedStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 101, 55, 118, 164, 15, 85, 80, 243, 235, 108, 20, 189, 62));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_LivelinessChangedStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LivelinessChangedStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"alive_count",0},{"not_alive_count",1},{"alive_count_change",2},{"not_alive_count_change",3},{"last_publication_handle",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.alive_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.not_alive_count)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.alive_count_change)) return false;
      break;
    }
    case 3: {
      if (!value_reader.read_int32(value.not_alive_count_change)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_int32(value.last_publication_handle)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LivelinessChangedStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("alive_count");
  value_writer.write_int32(value.alive_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("not_alive_count");
  value_writer.write_int32(value.not_alive_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("alive_count_change");
  value_writer.write_int32(value.alive_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("not_alive_count_change");
  value_writer.write_int32(value.not_alive_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_publication_handle");
  value_writer.write_int32(value.last_publication_handle);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::LivelinessChangedStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.alive_count = 0;
  stru.not_alive_count = 0;
  stru.alive_count_change = 0;
  stru.not_alive_count_change = 0;
  stru.last_publication_handle = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::LivelinessChangedStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.alive_count);
  primitive_serialized_size(encoding, size, stru.not_alive_count);
  primitive_serialized_size(encoding, size, stru.alive_count_change);
  primitive_serialized_size(encoding, size, stru.not_alive_count_change);
  primitive_serialized_size(encoding, size, stru.last_publication_handle);
}

bool operator<<(Serializer& strm, const  ::DDS::LivelinessChangedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.alive_count)
    && (strm << stru.not_alive_count)
    && (strm << stru.alive_count_change)
    && (strm << stru.not_alive_count_change)
    && (strm << stru.last_publication_handle);
}

bool operator>>(Serializer& strm,  ::DDS::LivelinessChangedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.alive_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.not_alive_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.alive_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.not_alive_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_publication_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::LivelinessChangedStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.alive_count);
  primitive_serialized_size(encoding, size, stru.value.not_alive_count);
  primitive_serialized_size(encoding, size, stru.value.alive_count_change);
  primitive_serialized_size(encoding, size, stru.value.not_alive_count_change);
  primitive_serialized_size(encoding, size, stru.value.last_publication_handle);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::LivelinessChangedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.alive_count)
    && (strm << stru.value.not_alive_count)
    && (strm << stru.value.alive_count_change)
    && (strm << stru.value.not_alive_count_change)
    && (strm << stru.value.last_publication_handle);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::LivelinessChangedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.alive_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.not_alive_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.alive_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.not_alive_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_publication_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::LivelinessChangedStatus> : MetaStruct {
  typedef  ::DDS::LivelinessChangedStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("alive_count", 0),
      std::make_pair("not_alive_count", 1),
      std::make_pair("alive_count_change", 2),
      std::make_pair("not_alive_count_change", 3),
      std::make_pair("last_publication_handle", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessChangedStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::LivelinessChangedStatus& typed = *static_cast<const  ::DDS::LivelinessChangedStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "alive_count") == 0) {
      return typed.alive_count;
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      return typed.not_alive_count;
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      return typed.alive_count_change;
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      return typed.not_alive_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return typed.last_publication_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessChangedStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "alive_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'alive_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'alive_count' could not be skipped");
      }
    }
    if (base_field == "not_alive_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'not_alive_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'not_alive_count' could not be skipped");
      }
    }
    if (base_field == "alive_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'alive_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'alive_count_change' could not be skipped");
      }
    }
    if (base_field == "not_alive_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'not_alive_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'not_alive_count_change' could not be skipped");
      }
    }
    if (base_field == "last_publication_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_publication_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_publication_handle' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "alive_count") == 0) {
      return make_field_cmp(&T::alive_count, next);
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      return make_field_cmp(&T::not_alive_count, next);
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      return make_field_cmp(&T::alive_count_change, next);
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      return make_field_cmp(&T::not_alive_count_change, next);
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return make_field_cmp(&T::last_publication_handle, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessChangedStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"alive_count", "not_alive_count", "alive_count_change", "not_alive_count_change", "last_publication_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "alive_count") == 0) {
      return &static_cast<const T*>(stru)->alive_count;
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      return &static_cast<const T*>(stru)->not_alive_count;
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      return &static_cast<const T*>(stru)->alive_count_change;
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      return &static_cast<const T*>(stru)->not_alive_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return &static_cast<const T*>(stru)->last_publication_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessChangedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "alive_count") == 0) {
      static_cast<T*>(lhs)->alive_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      static_cast<T*>(lhs)->not_alive_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      static_cast<T*>(lhs)->alive_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      static_cast<T*>(lhs)->not_alive_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      static_cast<T*>(lhs)->last_publication_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessChangedStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "alive_count") == 0) {
      return static_cast<const T*>(lhs)->alive_count == static_cast<const T*>(rhs)->alive_count;
    }
    if (std::strcmp(field, "not_alive_count") == 0) {
      return static_cast<const T*>(lhs)->not_alive_count == static_cast<const T*>(rhs)->not_alive_count;
    }
    if (std::strcmp(field, "alive_count_change") == 0) {
      return static_cast<const T*>(lhs)->alive_count_change == static_cast<const T*>(rhs)->alive_count_change;
    }
    if (std::strcmp(field, "not_alive_count_change") == 0) {
      return static_cast<const T*>(lhs)->not_alive_count_change == static_cast<const T*>(rhs)->not_alive_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return static_cast<const T*>(lhs)->last_publication_handle == static_cast<const T*>(rhs)->last_publication_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessChangedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::LivelinessChangedStatus>()
{
  static MetaStructImpl< ::DDS::LivelinessChangedStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::LivelinessChangedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::LivelinessChangedStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OfferedDeadlineMissedStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(95, 75, 190, 255, 230, 220, 82, 207, 189, 15, 63, 35, 187, 172));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_OfferedDeadlineMissedStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::OfferedDeadlineMissedStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{"last_instance_handle",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.last_instance_handle)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::OfferedDeadlineMissedStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_instance_handle");
  value_writer.write_int32(value.last_instance_handle);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::OfferedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
  stru.last_instance_handle = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::OfferedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
  primitive_serialized_size(encoding, size, stru.last_instance_handle);
}

bool operator<<(Serializer& strm, const  ::DDS::OfferedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_instance_handle);
}

bool operator>>(Serializer& strm,  ::DDS::OfferedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_instance_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::OfferedDeadlineMissedStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
  primitive_serialized_size(encoding, size, stru.value.last_instance_handle);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::OfferedDeadlineMissedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change)
    && (strm << stru.value.last_instance_handle);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::OfferedDeadlineMissedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_instance_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::OfferedDeadlineMissedStatus> : MetaStruct {
  typedef  ::DDS::OfferedDeadlineMissedStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
      std::make_pair("last_instance_handle", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedDeadlineMissedStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::OfferedDeadlineMissedStatus& typed = *static_cast<const  ::DDS::OfferedDeadlineMissedStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return typed.last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedDeadlineMissedStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (base_field == "last_instance_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_instance_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_instance_handle' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return make_field_cmp(&T::last_instance_handle, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedDeadlineMissedStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_instance_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return &static_cast<const T*>(stru)->last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedDeadlineMissedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      static_cast<T*>(lhs)->last_instance_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedDeadlineMissedStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return static_cast<const T*>(lhs)->last_instance_handle == static_cast<const T*>(rhs)->last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedDeadlineMissedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::OfferedDeadlineMissedStatus>()
{
  static MetaStructImpl< ::DDS::OfferedDeadlineMissedStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::OfferedDeadlineMissedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::OfferedDeadlineMissedStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_RequestedDeadlineMissedStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(95, 75, 190, 255, 230, 220, 82, 207, 189, 15, 63, 35, 187, 172));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_RequestedDeadlineMissedStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::RequestedDeadlineMissedStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{"last_instance_handle",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.last_instance_handle)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::RequestedDeadlineMissedStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_instance_handle");
  value_writer.write_int32(value.last_instance_handle);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::RequestedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
  stru.last_instance_handle = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::RequestedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
  primitive_serialized_size(encoding, size, stru.last_instance_handle);
}

bool operator<<(Serializer& strm, const  ::DDS::RequestedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_instance_handle);
}

bool operator>>(Serializer& strm,  ::DDS::RequestedDeadlineMissedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_instance_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::RequestedDeadlineMissedStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
  primitive_serialized_size(encoding, size, stru.value.last_instance_handle);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::RequestedDeadlineMissedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change)
    && (strm << stru.value.last_instance_handle);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::RequestedDeadlineMissedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_instance_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::RequestedDeadlineMissedStatus> : MetaStruct {
  typedef  ::DDS::RequestedDeadlineMissedStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
      std::make_pair("last_instance_handle", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedDeadlineMissedStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::RequestedDeadlineMissedStatus& typed = *static_cast<const  ::DDS::RequestedDeadlineMissedStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return typed.last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedDeadlineMissedStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (base_field == "last_instance_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_instance_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_instance_handle' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return make_field_cmp(&T::last_instance_handle, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedDeadlineMissedStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_instance_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return &static_cast<const T*>(stru)->last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedDeadlineMissedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      static_cast<T*>(lhs)->last_instance_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedDeadlineMissedStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_instance_handle") == 0) {
      return static_cast<const T*>(lhs)->last_instance_handle == static_cast<const T*>(rhs)->last_instance_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedDeadlineMissedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::RequestedDeadlineMissedStatus>()
{
  static MetaStructImpl< ::DDS::RequestedDeadlineMissedStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::RequestedDeadlineMissedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::RequestedDeadlineMissedStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: OfferedIncompatibleQosStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OfferedIncompatibleQosStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(220, 211, 154, 149, 84, 153, 252, 166, 69, 194, 136, 24, 69, 230));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_OfferedIncompatibleQosStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::OfferedIncompatibleQosStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{"last_policy_id",2},{"policies",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.last_policy_id)) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.policies);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.policies[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::OfferedIncompatibleQosStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_policy_id");
  value_writer.write_int32(value.last_policy_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("policies");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.policies.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.policies[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::OfferedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
  stru.last_policy_id = 0;
  stru.policies.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::OfferedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
  primitive_serialized_size(encoding, size, stru.last_policy_id);
  serialized_size(encoding, size, stru.policies);
}

bool operator<<(Serializer& strm, const  ::DDS::OfferedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_policy_id)
    && (strm << stru.policies);
}

bool operator>>(Serializer& strm,  ::DDS::OfferedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_policy_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.policies)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::OfferedIncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
  primitive_serialized_size(encoding, size, stru.value.last_policy_id);
  serialized_size(encoding, size, stru.value.policies);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::OfferedIncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change)
    && (strm << stru.value.last_policy_id)
    && (strm << stru.value.policies);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::OfferedIncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_policy_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.policies)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::OfferedIncompatibleQosStatus> : MetaStruct {
  typedef  ::DDS::OfferedIncompatibleQosStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
      std::make_pair("last_policy_id", 2),
      std::make_pair("policies", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedIncompatibleQosStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::OfferedIncompatibleQosStatus& typed = *static_cast<const  ::DDS::OfferedIncompatibleQosStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return typed.last_policy_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedIncompatibleQosStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (base_field == "last_policy_id") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_policy_id' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_policy_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::QosPolicyCountSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return make_field_cmp(&T::last_policy_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedIncompatibleQosStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_policy_id", "policies", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return &static_cast<const T*>(stru)->last_policy_id;
    }
    if (std::strcmp(field, "policies") == 0) {
      return &static_cast<const T*>(stru)->policies;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedIncompatibleQosStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      static_cast<T*>(lhs)->last_policy_id = *static_cast<const  ::DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "policies") == 0) {
      static_cast<T*>(lhs)->policies = *static_cast<const  ::DDS::QosPolicyCountSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedIncompatibleQosStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return static_cast<const T*>(lhs)->last_policy_id == static_cast<const T*>(rhs)->last_policy_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OfferedIncompatibleQosStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::OfferedIncompatibleQosStatus>()
{
  static MetaStructImpl< ::DDS::OfferedIncompatibleQosStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::OfferedIncompatibleQosStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::OfferedIncompatibleQosStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_RequestedIncompatibleQosStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(220, 211, 154, 149, 84, 153, 252, 166, 69, 194, 136, 24, 69, 230));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_RequestedIncompatibleQosStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::RequestedIncompatibleQosStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{"last_policy_id",2},{"policies",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.last_policy_id)) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.policies);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.policies[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::RequestedIncompatibleQosStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_policy_id");
  value_writer.write_int32(value.last_policy_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("policies");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.policies.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.policies[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::RequestedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
  stru.last_policy_id = 0;
  stru.policies.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::RequestedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
  primitive_serialized_size(encoding, size, stru.last_policy_id);
  serialized_size(encoding, size, stru.policies);
}

bool operator<<(Serializer& strm, const  ::DDS::RequestedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.last_policy_id)
    && (strm << stru.policies);
}

bool operator>>(Serializer& strm,  ::DDS::RequestedIncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_policy_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.policies)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::RequestedIncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
  primitive_serialized_size(encoding, size, stru.value.last_policy_id);
  serialized_size(encoding, size, stru.value.policies);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::RequestedIncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change)
    && (strm << stru.value.last_policy_id)
    && (strm << stru.value.policies);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::RequestedIncompatibleQosStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_policy_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.policies)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::RequestedIncompatibleQosStatus> : MetaStruct {
  typedef  ::DDS::RequestedIncompatibleQosStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
      std::make_pair("last_policy_id", 2),
      std::make_pair("policies", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedIncompatibleQosStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::RequestedIncompatibleQosStatus& typed = *static_cast<const  ::DDS::RequestedIncompatibleQosStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return typed.last_policy_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedIncompatibleQosStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (base_field == "last_policy_id") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_policy_id' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_policy_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::QosPolicyCountSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return make_field_cmp(&T::last_policy_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedIncompatibleQosStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "last_policy_id", "policies", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return &static_cast<const T*>(stru)->last_policy_id;
    }
    if (std::strcmp(field, "policies") == 0) {
      return &static_cast<const T*>(stru)->policies;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedIncompatibleQosStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      static_cast<T*>(lhs)->last_policy_id = *static_cast<const  ::DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "policies") == 0) {
      static_cast<T*>(lhs)->policies = *static_cast<const  ::DDS::QosPolicyCountSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedIncompatibleQosStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return static_cast<const T*>(lhs)->last_policy_id == static_cast<const T*>(rhs)->last_policy_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::RequestedIncompatibleQosStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::RequestedIncompatibleQosStatus>()
{
  static MetaStructImpl< ::DDS::RequestedIncompatibleQosStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::RequestedIncompatibleQosStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::RequestedIncompatibleQosStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PublicationMatchedStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 226, 77, 54, 110, 11, 76, 230, 47, 177, 147, 143, 219, 103));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_PublicationMatchedStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PublicationMatchedStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{"current_count",2},{"current_count_change",3},{"last_subscription_handle",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.current_count)) return false;
      break;
    }
    case 3: {
      if (!value_reader.read_int32(value.current_count_change)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_int32(value.last_subscription_handle)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PublicationMatchedStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("current_count");
  value_writer.write_int32(value.current_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("current_count_change");
  value_writer.write_int32(value.current_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_subscription_handle");
  value_writer.write_int32(value.last_subscription_handle);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::PublicationMatchedStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
  stru.current_count = 0;
  stru.current_count_change = 0;
  stru.last_subscription_handle = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PublicationMatchedStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
  primitive_serialized_size(encoding, size, stru.current_count);
  primitive_serialized_size(encoding, size, stru.current_count_change);
  primitive_serialized_size(encoding, size, stru.last_subscription_handle);
}

bool operator<<(Serializer& strm, const  ::DDS::PublicationMatchedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.current_count)
    && (strm << stru.current_count_change)
    && (strm << stru.last_subscription_handle);
}

bool operator>>(Serializer& strm,  ::DDS::PublicationMatchedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.current_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.current_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_subscription_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::PublicationMatchedStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
  primitive_serialized_size(encoding, size, stru.value.current_count);
  primitive_serialized_size(encoding, size, stru.value.current_count_change);
  primitive_serialized_size(encoding, size, stru.value.last_subscription_handle);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::PublicationMatchedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change)
    && (strm << stru.value.current_count)
    && (strm << stru.value.current_count_change)
    && (strm << stru.value.last_subscription_handle);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PublicationMatchedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.current_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.current_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_subscription_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::PublicationMatchedStatus> : MetaStruct {
  typedef  ::DDS::PublicationMatchedStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
      std::make_pair("current_count", 2),
      std::make_pair("current_count_change", 3),
      std::make_pair("last_subscription_handle", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationMatchedStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::PublicationMatchedStatus& typed = *static_cast<const  ::DDS::PublicationMatchedStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return typed.current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return typed.current_count_change;
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      return typed.last_subscription_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationMatchedStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (base_field == "current_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'current_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'current_count' could not be skipped");
      }
    }
    if (base_field == "current_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'current_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'current_count_change' could not be skipped");
      }
    }
    if (base_field == "last_subscription_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_subscription_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_subscription_handle' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "current_count") == 0) {
      return make_field_cmp(&T::current_count, next);
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return make_field_cmp(&T::current_count_change, next);
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      return make_field_cmp(&T::last_subscription_handle, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationMatchedStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "current_count", "current_count_change", "last_subscription_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return &static_cast<const T*>(stru)->current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return &static_cast<const T*>(stru)->current_count_change;
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      return &static_cast<const T*>(stru)->last_subscription_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationMatchedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "current_count") == 0) {
      static_cast<T*>(lhs)->current_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      static_cast<T*>(lhs)->current_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      static_cast<T*>(lhs)->last_subscription_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationMatchedStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return static_cast<const T*>(lhs)->current_count == static_cast<const T*>(rhs)->current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return static_cast<const T*>(lhs)->current_count_change == static_cast<const T*>(rhs)->current_count_change;
    }
    if (std::strcmp(field, "last_subscription_handle") == 0) {
      return static_cast<const T*>(lhs)->last_subscription_handle == static_cast<const T*>(rhs)->last_subscription_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationMatchedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::PublicationMatchedStatus>()
{
  static MetaStructImpl< ::DDS::PublicationMatchedStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::PublicationMatchedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::PublicationMatchedStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SubscriptionMatchedStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(21, 125, 111, 198, 174, 105, 95, 91, 28, 247, 171, 78, 104, 120));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SubscriptionMatchedStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SubscriptionMatchedStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"total_count",0},{"total_count_change",1},{"current_count",2},{"current_count_change",3},{"last_publication_handle",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.total_count)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.total_count_change)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.current_count)) return false;
      break;
    }
    case 3: {
      if (!value_reader.read_int32(value.current_count_change)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_int32(value.last_publication_handle)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SubscriptionMatchedStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("total_count");
  value_writer.write_int32(value.total_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("total_count_change");
  value_writer.write_int32(value.total_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("current_count");
  value_writer.write_int32(value.current_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("current_count_change");
  value_writer.write_int32(value.current_count_change);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("last_publication_handle");
  value_writer.write_int32(value.last_publication_handle);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::SubscriptionMatchedStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.total_count = 0;
  stru.total_count_change = 0;
  stru.current_count = 0;
  stru.current_count_change = 0;
  stru.last_publication_handle = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::SubscriptionMatchedStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.total_count);
  primitive_serialized_size(encoding, size, stru.total_count_change);
  primitive_serialized_size(encoding, size, stru.current_count);
  primitive_serialized_size(encoding, size, stru.current_count_change);
  primitive_serialized_size(encoding, size, stru.last_publication_handle);
}

bool operator<<(Serializer& strm, const  ::DDS::SubscriptionMatchedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.total_count)
    && (strm << stru.total_count_change)
    && (strm << stru.current_count)
    && (strm << stru.current_count_change)
    && (strm << stru.last_publication_handle);
}

bool operator>>(Serializer& strm,  ::DDS::SubscriptionMatchedStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.current_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.current_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.last_publication_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::SubscriptionMatchedStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.total_count);
  primitive_serialized_size(encoding, size, stru.value.total_count_change);
  primitive_serialized_size(encoding, size, stru.value.current_count);
  primitive_serialized_size(encoding, size, stru.value.current_count_change);
  primitive_serialized_size(encoding, size, stru.value.last_publication_handle);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::SubscriptionMatchedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.total_count)
    && (strm << stru.value.total_count_change)
    && (strm << stru.value.current_count)
    && (strm << stru.value.current_count_change)
    && (strm << stru.value.last_publication_handle);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SubscriptionMatchedStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.total_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.current_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.current_count_change)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.last_publication_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::SubscriptionMatchedStatus> : MetaStruct {
  typedef  ::DDS::SubscriptionMatchedStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("total_count", 0),
      std::make_pair("total_count_change", 1),
      std::make_pair("current_count", 2),
      std::make_pair("current_count_change", 3),
      std::make_pair("last_publication_handle", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionMatchedStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::SubscriptionMatchedStatus& typed = *static_cast<const  ::DDS::SubscriptionMatchedStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return typed.total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return typed.current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return typed.current_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return typed.last_publication_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionMatchedStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "total_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (base_field == "total_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'total_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'total_count_change' could not be skipped");
      }
    }
    if (base_field == "current_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'current_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'current_count' could not be skipped");
      }
    }
    if (base_field == "current_count_change") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'current_count_change' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'current_count_change' could not be skipped");
      }
    }
    if (base_field == "last_publication_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'last_publication_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'last_publication_handle' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return make_field_cmp(&T::total_count_change, next);
    }
    if (std::strcmp(field, "current_count") == 0) {
      return make_field_cmp(&T::current_count, next);
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return make_field_cmp(&T::current_count_change, next);
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return make_field_cmp(&T::last_publication_handle, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionMatchedStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "total_count_change", "current_count", "current_count_change", "last_publication_handle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return &static_cast<const T*>(stru)->total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return &static_cast<const T*>(stru)->current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return &static_cast<const T*>(stru)->current_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return &static_cast<const T*>(stru)->last_publication_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionMatchedStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      static_cast<T*>(lhs)->total_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "current_count") == 0) {
      static_cast<T*>(lhs)->current_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      static_cast<T*>(lhs)->current_count_change = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      static_cast<T*>(lhs)->last_publication_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionMatchedStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "total_count_change") == 0) {
      return static_cast<const T*>(lhs)->total_count_change == static_cast<const T*>(rhs)->total_count_change;
    }
    if (std::strcmp(field, "current_count") == 0) {
      return static_cast<const T*>(lhs)->current_count == static_cast<const T*>(rhs)->current_count;
    }
    if (std::strcmp(field, "current_count_change") == 0) {
      return static_cast<const T*>(lhs)->current_count_change == static_cast<const T*>(rhs)->current_count_change;
    }
    if (std::strcmp(field, "last_publication_handle") == 0) {
      return static_cast<const T*>(lhs)->last_publication_handle == static_cast<const T*>(rhs)->last_publication_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionMatchedStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::SubscriptionMatchedStatus>()
{
  static MetaStructImpl< ::DDS::SubscriptionMatchedStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::SubscriptionMatchedStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::SubscriptionMatchedStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin CONST: DOMAIN_UNKNOWN */


/* End CONST: DOMAIN_UNKNOWN */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

namespace {
XTypes::TypeObject minimal_to0()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(52, 66, 30, 3))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(244, 222, 70, 82))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(211, 76, 145, 44))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(63, 97, 156, 199))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(184, 76, 255, 165))))));
}

XTypes::TypeObject minimal_to1()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(80, 26, 63, 247))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(121, 175, 240, 199))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(146, 31, 168, 15))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(3, 0), XTypes::MinimalMemberDetail(48, 70, 197, 82))))));
}

XTypes::TypeObject minimal_to2()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(252, 5, 18, 134))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(209, 241, 54, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(135, 178, 211, 213))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(92, 244, 198, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(184, 76, 255, 165))))));
}

XTypes::TypeObject minimal_to3()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(52, 66, 30, 3))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(244, 222, 70, 82))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(226, 1, 151, 66))))));
}

XTypes::TypeObject minimal_to4()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_UINT32))))));
}

XTypes::TypeObject minimal_to5()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT32))))));
}

XTypes::TypeObject minimal_to6()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(52, 66, 30, 3))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(244, 222, 70, 82))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(211, 76, 145, 44))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(63, 97, 156, 199))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(126, 167, 38, 85))))));
}

XTypes::TypeObject minimal_to7()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(187, 206, 175, 130, 167, 249, 57, 105, 219, 219, 138, 84, 110, 94)))))))));
}

XTypes::TypeObject minimal_to8()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(202, 176, 202, 19))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(226, 148, 42, 4))))));
}

XTypes::TypeObject minimal_to9()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(52, 66, 30, 3))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(244, 222, 70, 82))))));
}

XTypes::TypeObject minimal_to10()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(52, 66, 30, 3))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(244, 222, 70, 82))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(188, 222, 35, 31))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(180, 45, 19, 101, 194, 86, 184, 210, 220, 168, 163, 127, 201, 93))), XTypes::MinimalMemberDetail(148, 66, 47, 166))))));
}

XTypes::TypeObject minimal_to11()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(52, 66, 30, 3))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(244, 222, 70, 82))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(26, 28, 21, 155, 172, 168, 92, 103, 118, 83, 252, 122, 171, 74))), XTypes::MinimalMemberDetail(207, 36, 40, 97))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(226, 1, 151, 66))))));
}

XTypes::TypeMap get_minimal_type_map_private()
{
  XTypes::TypeMap tm;
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(21, 125, 111, 198, 174, 105, 95, 91, 28, 247, 171, 78, 104, 120))] = minimal_to0();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(26, 28, 21, 155, 172, 168, 92, 103, 118, 83, 252, 122, 171, 74))] = minimal_to1();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 101, 55, 118, 164, 15, 85, 80, 243, 235, 108, 20, 189, 62))] = minimal_to2();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(95, 75, 190, 255, 230, 220, 82, 207, 189, 15, 63, 35, 187, 172))] = minimal_to3();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))] = minimal_to4();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))] = minimal_to5();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 226, 77, 54, 110, 11, 76, 230, 47, 177, 147, 143, 219, 103))] = minimal_to6();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(180, 45, 19, 101, 194, 86, 184, 210, 220, 168, 163, 127, 201, 93))] = minimal_to7();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(187, 206, 175, 130, 167, 249, 57, 105, 219, 219, 138, 84, 110, 94))] = minimal_to8();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 128, 160, 117, 69, 76, 234, 57, 156, 223, 61, 65, 196, 175))] = minimal_to9();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(220, 211, 154, 149, 84, 153, 252, 166, 69, 194, 136, 24, 69, 230))] = minimal_to10();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 238, 206, 96, 216, 194, 176, 195, 111, 193, 164, 132, 163, 100))] = minimal_to11();
  return tm;
}

}

const XTypes::TypeMap& get_minimal_type_map()
{
  static XTypes::TypeMap tm;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), tm);
  if (tm.empty()) {
    tm = get_minimal_type_map_private();
  }
  return tm;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

