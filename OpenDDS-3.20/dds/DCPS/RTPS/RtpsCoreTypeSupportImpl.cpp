/* Generated by ..\..\..\bin\opendds_idl version 3.20.0 (ACE version 6.2a_p23) running on input file RtpsCore.idl */
#include "RtpsCoreTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#ifndef OPENDDS_SAFETY_PROFILE
  #include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#endif
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"
#include "dds/DdsDcpsInfoUtilsTypeSupportImpl.h"
#include "dds/OpenddsDcpsExtTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: ParticipantLocation */


/* End TYPEDEF: ParticipantLocation */


/* Begin CONST: LOCATION_LOCAL */


/* End CONST: LOCATION_LOCAL */


/* Begin CONST: LOCATION_ICE */


/* End CONST: LOCATION_ICE */


/* Begin CONST: LOCATION_RELAY */


/* End CONST: LOCATION_RELAY */


/* Begin CONST: LOCATION_LOCAL6 */


/* End CONST: LOCATION_LOCAL6 */


/* Begin CONST: LOCATION_ICE6 */


/* End CONST: LOCATION_ICE6 */


/* Begin CONST: LOCATION_RELAY6 */


/* End CONST: LOCATION_RELAY6 */


/* Begin STRUCT: ParticipantLocationBuiltinTopicData */


/* End STRUCT: ParticipantLocationBuiltinTopicData */


/* Begin CONST: RTPS_RELAY_STUN_PROTOCOL */


/* End CONST: RTPS_RELAY_STUN_PROTOCOL */


/* Begin STRUCT: ConnectionRecord */


/* End STRUCT: ConnectionRecord */


/* Begin STRUCT: InternalThreadBuiltinTopicData */


/* End STRUCT: InternalThreadBuiltinTopicData */


/* Begin CONST: LOCATOR_KIND_INVALID */


/* End CONST: LOCATOR_KIND_INVALID */


/* Begin CONST: LOCATOR_KIND_RESERVED */


/* End CONST: LOCATOR_KIND_RESERVED */


/* Begin CONST: LOCATOR_KIND_UDPv4 */


/* End CONST: LOCATOR_KIND_UDPv4 */


/* Begin CONST: LOCATOR_KIND_UDPv6 */


/* End CONST: LOCATOR_KIND_UDPv6 */


/* Begin CONST: LOCATOR_PORT_INVALID */


/* End CONST: LOCATOR_PORT_INVALID */


/* Begin STRUCT: Locator_t */


/* End STRUCT: Locator_t */


/* Begin TYPEDEF: LocatorSeq */


/* End TYPEDEF: LocatorSeq */


/* Begin TYPEDEF: MessageCountKind */


/* End TYPEDEF: MessageCountKind */


/* Begin CONST: MCK_RTPS */


/* End CONST: MCK_RTPS */


/* Begin CONST: MCK_STUN */


/* End CONST: MCK_STUN */


/* Begin STRUCT: MessageCount */


/* End STRUCT: MessageCount */


/* Begin STRUCT: GuidCount */


/* End STRUCT: GuidCount */


/* Begin TYPEDEF: MessageCountSequence */


/* End TYPEDEF: MessageCountSequence */


/* Begin TYPEDEF: GuidCountSequence */


/* End TYPEDEF: GuidCountSequence */


/* Begin STRUCT: TransportStatistics */


/* End STRUCT: TransportStatistics */


/* Begin TYPEDEF: TransportStatisticsSequence */


/* End TYPEDEF: TransportStatisticsSequence */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: RepoId */


/* End TYPEDEF: RepoId */


/* Begin STRUCT: MonotonicTime_t */


/* End STRUCT: MonotonicTime_t */


/* Begin TYPEDEF: TransportBLOB */


/* End TYPEDEF: TransportBLOB */


/* Begin STRUCT: TransportLocator */


/* End STRUCT: TransportLocator */


/* Begin TYPEDEF: TransportLocatorSeq */


/* End TYPEDEF: TransportLocatorSeq */


/* Begin STRUCT: IncompatibleQosStatus */


/* End STRUCT: IncompatibleQosStatus */


/* Begin STRUCT: AddDomainStatus */


/* End STRUCT: AddDomainStatus */


/* Begin ENUM: TopicStatus */


/* End ENUM: TopicStatus */


/* Begin STRUCT: WriterAssociation */


/* End STRUCT: WriterAssociation */


/* Begin STRUCT: ReaderAssociation */


/* End STRUCT: ReaderAssociation */


/* Begin TYPEDEF: WriterIdSeq */


/* End TYPEDEF: WriterIdSeq */


/* Begin TYPEDEF: ReaderIdSeq */


/* End TYPEDEF: ReaderIdSeq */


/* Begin TYPEDEF: String256 */


/* End TYPEDEF: String256 */


/* Begin STRUCT: ContentFilterProperty_t */


/* End STRUCT: ContentFilterProperty_t */


/* Begin STRUCT: ReaderProxy_t */


/* End STRUCT: ReaderProxy_t */


/* Begin STRUCT: DiscoveredReaderData */


/* End STRUCT: DiscoveredReaderData */


/* Begin STRUCT: WriterProxy_t */


/* End STRUCT: WriterProxy_t */


/* Begin STRUCT: DiscoveredWriterData */


/* End STRUCT: DiscoveredWriterData */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: DDS */



/* Begin INTERFACE-FWD: Condition */


/* End INTERFACE-FWD: Condition */


/* Begin TYPEDEF: ConditionSeq */


/* End TYPEDEF: ConditionSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: ReturnCode_t */


/* End TYPEDEF: ReturnCode_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */


/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */


/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */


/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */


/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */


/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */


/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */


/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */


/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: OfferedIncompatibleQosStatus */


/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */


/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */


/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */


/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin CONST: DOMAIN_UNKNOWN */


/* End CONST: DOMAIN_UNKNOWN */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: RTPS */



/* Begin TYPEDEF: OctetArray2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_OctetArray2_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(223, 137, 245, 17, 179, 98, 96, 20, 237, 41, 215, 82, 255, 127));
  }
  return ti;
}

static const XTypes::TypeMap& get_minimal_type_map();
template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_OctetArray2_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
    arr[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size_octet(encoding, size, 2);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_octet_array(arr.in(), 2);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_octet_array(arr.out(), 2);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::OctetArray2_forany*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(2, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray2 */


/* Begin TYPEDEF: OctetArray4 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_OctetArray4_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 90, 35, 84, 117, 166, 180, 163, 60, 216, 244, 19, 92, 13));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_OctetArray4_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
    arr[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size_octet(encoding, size, 4);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_octet_array(arr.in(), 4);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_octet_array(arr.out(), 4);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::OctetArray4_forany*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(4, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray4 */


/* Begin TYPEDEF: FilterSignature_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_FilterSignature_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(18, 113, 84, 193, 2, 246, 131, 177, 4, 117, 126, 75, 63, 142));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_FilterSignature_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
    arr[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size(encoding, size,  ::CORBA::Long(), 4);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_long_array(arr.in(), 4);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_long_array(arr.out(), 4);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::FilterSignature_t_forany*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(4, 4);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterSignature_t */


/* Begin TYPEDEF: FilterResult_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_FilterResult_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 132, 84, 128, 187, 1, 123, 173, 187, 231, 55, 190, 22, 206));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_FilterResult_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  primitive_serialized_size(encoding, size,  ::CORBA::Long(), seq.length());
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::FilterResult_t*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  return ser.skip(length, 4);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterResult_t */


/* Begin TYPEDEF: FilterSignatureSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_FilterSignatureSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(8, 72, 1, 219, 209, 130, 97, 88, 183, 75, 190, 192, 122, 99));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_FilterSignatureSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
     ::OpenDDS::RTPS::FilterSignature_t_forany seq_i_forany(const_cast< ::OpenDDS::RTPS::FilterSignature_t_slice*>(seq[i]));
    serialized_size(encoding, size, seq_i_forany);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
     ::OpenDDS::RTPS::FilterSignature_t_forany seq_i_forany(const_cast< ::OpenDDS::RTPS::FilterSignature_t_slice*>(seq[i]));
    if (!(strm << seq_i_forany)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     ::OpenDDS::RTPS::FilterSignature_t_var seq_i_tmp_var=  ::OpenDDS::RTPS::FilterSignature_t_alloc();
     ::OpenDDS::RTPS::FilterSignature_t_forany seq_9i_9tmp_9var_forany = seq_i_tmp_var.inout();
     if (!(strm >> seq_9i_9tmp_9var_forany)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::RTPS::FilterSignatureSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
           ::OpenDDS::RTPS::FilterSignature_t_var tempvar_tmp_var=  ::OpenDDS::RTPS::FilterSignature_t_alloc();
           ::OpenDDS::RTPS::FilterSignature_t_forany tempvar_9tmp_9var_forany = tempvar_tmp_var.inout();
          strm >> tempvar_9tmp_9var_forany;
        }
      }
      return false;
    }
     ::OpenDDS::RTPS::FilterSignature_t_copy(seq[i], seq_i_tmp_var.in());
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::RTPS::FilterSignatureSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
         ::OpenDDS::RTPS::FilterSignature_t_var tempvar_tmp_var=  ::OpenDDS::RTPS::FilterSignature_t_alloc();
         ::OpenDDS::RTPS::FilterSignature_t_forany tempvar_9tmp_9var_forany = tempvar_tmp_var.inout();
        strm >> tempvar_9tmp_9var_forany;
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::FilterSignatureSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::FilterSignature_t_forany*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterSignatureSeq */


/* Begin STRUCT: ContentFilterInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_ContentFilterInfo_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(217, 115, 52, 86, 152, 78, 235, 0, 132, 179, 241, 33, 223, 229));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_ContentFilterInfo_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::ContentFilterInfo_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"filterResult",0},{"filterSignatures",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.filterResult);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_int32(value.filterResult[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.filterSignatures);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.begin_array()) return false;
        if (!value_reader.read_int32_array (value.filterSignatures[i], 4)) return false;
        if (!value_reader.end_array()) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::ContentFilterInfo_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("filterResult");
  value_writer.begin_sequence();
  value_writer.write_int32_array (value.filterResult.get_buffer(), value.filterResult.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("filterSignatures");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.filterSignatures.length(); ++i) {
    value_writer.begin_element(i);
    value_writer.begin_array();
    value_writer.write_int32_array (value.filterSignatures[i], 4);
    value_writer.end_array();
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.filterResult.length(0);
  stru.filterSignatures.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.filterResult);
  serialized_size(encoding, size, stru.filterSignatures);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.filterResult)
    && (strm << stru.filterSignatures);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.filterResult)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.filterSignatures)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::ContentFilterInfo_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.filterResult);
  serialized_size(encoding, size, stru.value.filterSignatures);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::ContentFilterInfo_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.filterResult)
    && (strm << stru.value.filterSignatures);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::ContentFilterInfo_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.filterResult)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.filterSignatures)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::ContentFilterInfo_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::ContentFilterInfo_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("filterResult", 0),
      std::make_pair("filterSignatures", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ContentFilterInfo_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::ContentFilterInfo_t& typed = *static_cast<const  ::OpenDDS::RTPS::ContentFilterInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::FilterResult_t*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::FilterSignatureSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ContentFilterInfo_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"filterResult", "filterSignatures", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "filterResult") == 0) {
      return &static_cast<const T*>(stru)->filterResult;
    }
    if (std::strcmp(field, "filterSignatures") == 0) {
      return &static_cast<const T*>(stru)->filterSignatures;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "filterResult") == 0) {
      static_cast<T*>(lhs)->filterResult = *static_cast<const  ::OpenDDS::RTPS::FilterResult_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterSignatures") == 0) {
      static_cast<T*>(lhs)->filterSignatures = *static_cast<const  ::OpenDDS::RTPS::FilterSignatureSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ContentFilterInfo_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ContentFilterInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::ContentFilterInfo_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::ContentFilterInfo_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::ContentFilterInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::ContentFilterInfo_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ContentFilterInfo_t */


/* Begin TYPEDEF: Property_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Property_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(196, 35, 144, 119, 219, 90, 67, 131, 234, 152, 218, 209, 208, 105));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Property_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Property_t */


/* Begin TYPEDEF: PropertySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_PropertySeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 81, 30, 246, 182, 164, 30, 76, 46, 244, 231, 33, 240, 210));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_PropertySeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: EntityName_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_EntityName_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(183, 77, 161, 2, 250, 20, 171, 40, 89, 82, 214, 220, 104, 251));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_EntityName_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::EntityName_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"name",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.name = x.c_str();
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::EntityName_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("name");
  value_writer.write_string(value.name);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.name = "";
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.name.in()) + 1;
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.name.in());
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::EntityName_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.name.in()) + 1;
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::EntityName_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.name.in());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::EntityName_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::EntityName_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::EntityName_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("name", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::EntityName_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::EntityName_t& typed = *static_cast<const  ::OpenDDS::RTPS::EntityName_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::EntityName_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::EntityName_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"name", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::EntityName_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::EntityName_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::EntityName_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::EntityName_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::EntityName_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::EntityName_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::EntityName_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityName_t */


/* Begin STRUCT: Count_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Count_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Count_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::Count_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.value)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::Count_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.write_int32(value.value);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::Count_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::Count_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::Count_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::Count_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::Count_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Count_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::Count_t& typed = *static_cast<const  ::OpenDDS::RTPS::Count_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Count_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "value") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Count_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Count_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Count_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Count_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::Count_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::Count_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::Count_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::Count_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Count_t */


/* Begin STRUCT: SequenceNumber_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_SequenceNumber_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_SequenceNumber_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::SequenceNumber_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"high",0},{"low",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.high)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.low)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::SequenceNumber_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("high");
  value_writer.write_int32(value.high);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("low");
  value_writer.write_uint32(value.low);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.high = 0;
  stru.low = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  primitive_serialized_size(encoding, size, stru.high);
  primitive_serialized_size(encoding, size, stru.low);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm << stru.high)
    && (strm << stru.low);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm >> stru.high)
    && (strm >> stru.low);
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::SequenceNumber_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  primitive_serialized_size(encoding, size, stru.value.high);
  primitive_serialized_size(encoding, size, stru.value.low);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::SequenceNumber_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm << stru.value.high)
    && (strm << stru.value.low);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::SequenceNumber_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm >> stru.value.high)
    && (strm >> stru.value.low);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::SequenceNumber_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::SequenceNumber_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("high", 0),
      std::make_pair("low", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumber_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::SequenceNumber_t& typed = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "high") == 0) {
      return typed.high;
    }
    if (std::strcmp(field, "low") == 0) {
      return typed.low;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumber_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "high") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'high' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'high' could not be skipped");
      }
    }
    if (base_field == "low") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'low' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'low' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "high") == 0) {
      return make_field_cmp(&T::high, next);
    }
    if (std::strcmp(field, "low") == 0) {
      return make_field_cmp(&T::low, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumber_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"high", "low", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "high") == 0) {
      return &static_cast<const T*>(stru)->high;
    }
    if (std::strcmp(field, "low") == 0) {
      return &static_cast<const T*>(stru)->low;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumber_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "high") == 0) {
      static_cast<T*>(lhs)->high = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "low") == 0) {
      static_cast<T*>(lhs)->low = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumber_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "high") == 0) {
      return static_cast<const T*>(lhs)->high == static_cast<const T*>(rhs)->high;
    }
    if (std::strcmp(field, "low") == 0) {
      return static_cast<const T*>(lhs)->low == static_cast<const T*>(rhs)->low;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumber_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::SequenceNumber_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::SequenceNumber_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SequenceNumber_t */


/* Begin TYPEDEF: LongSeq8 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_LongSeq8_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(149, 57, 30, 106, 7, 12, 230, 99, 234, 186, 194, 64, 166, 141));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_LongSeq8_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  primitive_serialized_size(encoding, size,  ::CORBA::Long(), seq.length());
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  const CORBA::ULong length = seq.length();
  if (length > 8) {
    return false;
  }
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  if (length > seq.maximum()) {
    new_length = seq.maximum();
  }
  seq.length(new_length);
  strm.read_long_array(seq.get_buffer(), new_length);
  if (new_length != length) {
    size_t skip_length = 0;
    primitive_serialized_size(encoding, skip_length,  ::CORBA::Long(), (length - new_length));
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    strm.skip(skip_length);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::LongSeq8*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  return ser.skip(length, 4);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LongSeq8 */


/* Begin STRUCT: SequenceNumberSet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_SequenceNumberSet_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(147, 235, 253, 18, 141, 198, 246, 197, 245, 92, 250, 175, 56, 124));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_SequenceNumberSet_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::SequenceNumberSet& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"bitmapBase",0},{"numBits",1},{"bitmap",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.bitmapBase)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.numBits)) return false;
      break;
    }
    case 2: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.bitmap);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_int32(value.bitmap[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::SequenceNumberSet& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("bitmapBase");
  vwrite(value_writer, value.bitmapBase);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("numBits");
  value_writer.write_uint32(value.numBits);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("bitmap");
  value_writer.begin_sequence();
  value_writer.write_int32_array (value.bitmap.get_buffer(), value.bitmap.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.bitmapBase);
  stru.numBits = 0;
  stru.bitmap.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size += 12 + 4 * ((stru.numBits + 31) / 32); // RTPS Custom
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm << stru.bitmapBase) && (strm << stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (stru.bitmap.length() < M) {
      return false;
    }
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm << stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm >> stru.bitmapBase) && (strm >> stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (M > 8) {
      return false;
    }
    stru.bitmap.length(M);
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm >> stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::SequenceNumberSet> : MetaStruct {
  typedef  ::OpenDDS::RTPS::SequenceNumberSet T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("bitmapBase", 0),
      std::make_pair("numBits", 1),
      std::make_pair("bitmap", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumberSet)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::SequenceNumberSet& typed = *static_cast<const  ::OpenDDS::RTPS::SequenceNumberSet*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.bitmapBase, field + 11);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return typed.numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumberSet)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "bitmapBase") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'bitmapBase' could not be skipped");
      }
    }
    if (base_field == "numBits") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'numBits' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'numBits' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::LongSeq8*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return make_struct_cmp(&T::bitmapBase, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 11), next);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return make_field_cmp(&T::numBits, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumberSet)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"bitmapBase", "numBits", "bitmap", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bitmapBase") == 0) {
      return &static_cast<const T*>(stru)->bitmapBase;
    }
    if (std::strcmp(field, "numBits") == 0) {
      return &static_cast<const T*>(stru)->numBits;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      return &static_cast<const T*>(stru)->bitmap;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumberSet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bitmapBase") == 0) {
      static_cast<T*>(lhs)->bitmapBase = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "numBits") == 0) {
      static_cast<T*>(lhs)->numBits = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      static_cast<T*>(lhs)->bitmap = *static_cast<const  ::OpenDDS::RTPS::LongSeq8*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumberSet)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "numBits") == 0) {
      return static_cast<const T*>(lhs)->numBits == static_cast<const T*>(rhs)->numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SequenceNumberSet)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::SequenceNumberSet>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::SequenceNumberSet> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::SequenceNumberSet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SequenceNumberSet */


/* Begin TYPEDEF: LocatorList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_LocatorList_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 247, 209, 52, 65, 35, 253, 153, 236, 85, 203, 16, 40, 240));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_LocatorList_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (length > 8) {
    return false;
  }
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  if (length > seq.maximum()) {
    new_length = seq.maximum();
  }
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::RTPS::LocatorList tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::RTPS::LocatorList tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::LocatorList*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::Locator_t*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LocatorList */


/* Begin STRUCT: Time_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Time_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(12, 146, 216, 130, 44, 156, 246, 196, 95, 35, 157, 166, 171, 143));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Time_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::Time_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"seconds",0},{"fraction",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_uint32(value.seconds)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.fraction)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::Time_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("seconds");
  value_writer.write_uint32(value.seconds);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("fraction");
  value_writer.write_uint32(value.fraction);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.seconds = 0;
  stru.fraction = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.seconds);
  primitive_serialized_size(encoding, size, stru.fraction);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.seconds)
    && (strm << stru.fraction);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.seconds)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.fraction)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::Time_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.seconds);
  primitive_serialized_size(encoding, size, stru.value.fraction);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::Time_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.seconds)
    && (strm << stru.value.fraction);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::Time_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.seconds)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.fraction)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::Time_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::Time_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("seconds", 0),
      std::make_pair("fraction", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Time_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::Time_t& typed = *static_cast<const  ::OpenDDS::RTPS::Time_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "seconds") == 0) {
      return typed.seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return typed.fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Time_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "seconds") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'seconds' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'seconds' could not be skipped");
      }
    }
    if (base_field == "fraction") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'fraction' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'fraction' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "seconds") == 0) {
      return make_field_cmp(&T::seconds, next);
    }
    if (std::strcmp(field, "fraction") == 0) {
      return make_field_cmp(&T::fraction, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Time_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"seconds", "fraction", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      return &static_cast<const T*>(stru)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return &static_cast<const T*>(stru)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Time_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "seconds") == 0) {
      static_cast<T*>(lhs)->seconds = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fraction") == 0) {
      static_cast<T*>(lhs)->fraction = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Time_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "seconds") == 0) {
      return static_cast<const T*>(lhs)->seconds == static_cast<const T*>(rhs)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return static_cast<const T*>(lhs)->fraction == static_cast<const T*>(rhs)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Time_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::Time_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::Time_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::Time_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::Time_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Time_t */


/* Begin TYPEDEF: Timestamp_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Timestamp_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(103, 99, 176, 25, 62, 194, 58, 17, 243, 55, 82, 78, 3, 240));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Timestamp_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Timestamp_t */


/* Begin STRUCT: Duration_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Duration_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(159, 245, 110, 111, 33, 28, 122, 7, 5, 199, 96, 142, 87, 19));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Duration_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::Duration_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"seconds",0},{"fraction",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.seconds)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.fraction)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::Duration_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("seconds");
  value_writer.write_int32(value.seconds);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("fraction");
  value_writer.write_uint32(value.fraction);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::Duration_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.seconds = 0;
  stru.fraction = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::Duration_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.seconds);
  primitive_serialized_size(encoding, size, stru.fraction);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.seconds)
    && (strm << stru.fraction);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.seconds)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.fraction)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::Duration_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.seconds);
  primitive_serialized_size(encoding, size, stru.value.fraction);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::Duration_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.seconds)
    && (strm << stru.value.fraction);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::Duration_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.seconds)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.fraction)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::Duration_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::Duration_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("seconds", 0),
      std::make_pair("fraction", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Duration_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::Duration_t& typed = *static_cast<const  ::OpenDDS::RTPS::Duration_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "seconds") == 0) {
      return typed.seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return typed.fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Duration_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "seconds") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'seconds' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'seconds' could not be skipped");
      }
    }
    if (base_field == "fraction") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'fraction' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'fraction' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "seconds") == 0) {
      return make_field_cmp(&T::seconds, next);
    }
    if (std::strcmp(field, "fraction") == 0) {
      return make_field_cmp(&T::fraction, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Duration_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"seconds", "fraction", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      return &static_cast<const T*>(stru)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return &static_cast<const T*>(stru)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Duration_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "seconds") == 0) {
      static_cast<T*>(lhs)->seconds = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fraction") == 0) {
      static_cast<T*>(lhs)->fraction = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Duration_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "seconds") == 0) {
      return static_cast<const T*>(lhs)->seconds == static_cast<const T*>(rhs)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return static_cast<const T*>(lhs)->fraction == static_cast<const T*>(rhs)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Duration_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::Duration_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::Duration_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::Duration_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::Duration_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Duration_t */


/* Begin CONST: LOCATOR_KIND_INVALID */


/* End CONST: LOCATOR_KIND_INVALID */


/* Begin CONST: LOCATOR_KIND_RESERVED */


/* End CONST: LOCATOR_KIND_RESERVED */


/* Begin CONST: LOCATOR_KIND_UDPv4 */


/* End CONST: LOCATOR_KIND_UDPv4 */


/* Begin CONST: LOCATOR_KIND_UDPv6 */


/* End CONST: LOCATOR_KIND_UDPv6 */


/* Begin CONST: LOCATOR_PORT_INVALID */


/* End CONST: LOCATOR_PORT_INVALID */


/* Begin STRUCT: LocatorUDPv4_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_LocatorUDPv4_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 175, 77, 37, 194, 231, 136, 170, 53, 228, 31, 45, 86, 160));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_LocatorUDPv4_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::LocatorUDPv4_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"address",0},{"port",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_uint32(value.address)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.port)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::LocatorUDPv4_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("address");
  value_writer.write_uint32(value.address);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("port");
  value_writer.write_uint32(value.port);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.address = 0;
  stru.port = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.address);
  primitive_serialized_size(encoding, size, stru.port);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.address)
    && (strm << stru.port);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.address)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.port)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::LocatorUDPv4_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.address);
  primitive_serialized_size(encoding, size, stru.value.port);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::LocatorUDPv4_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.address)
    && (strm << stru.value.port);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::LocatorUDPv4_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.address)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.port)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::LocatorUDPv4_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::LocatorUDPv4_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("address", 0),
      std::make_pair("port", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::LocatorUDPv4_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::LocatorUDPv4_t& typed = *static_cast<const  ::OpenDDS::RTPS::LocatorUDPv4_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "address") == 0) {
      return typed.address;
    }
    if (std::strcmp(field, "port") == 0) {
      return typed.port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "address") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'address' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'address' could not be skipped");
      }
    }
    if (base_field == "port") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'port' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'port' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "address") == 0) {
      return make_field_cmp(&T::address, next);
    }
    if (std::strcmp(field, "port") == 0) {
      return make_field_cmp(&T::port, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::LocatorUDPv4_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"address", "port", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->address;
    }
    if (std::strcmp(field, "port") == 0) {
      return &static_cast<const T*>(stru)->port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "address") == 0) {
      static_cast<T*>(lhs)->address = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "port") == 0) {
      static_cast<T*>(lhs)->port = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::LocatorUDPv4_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "address") == 0) {
      return static_cast<const T*>(lhs)->address == static_cast<const T*>(rhs)->address;
    }
    if (std::strcmp(field, "port") == 0) {
      return static_cast<const T*>(lhs)->port == static_cast<const T*>(rhs)->port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::LocatorUDPv4_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::LocatorUDPv4_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::LocatorUDPv4_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::LocatorUDPv4_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LocatorUDPv4_t */


/* Begin STRUCT: TopicKind_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_TopicKind_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_TopicKind_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::TopicKind_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.value)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::TopicKind_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.write_int32(value.value);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::TopicKind_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::TopicKind_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::TopicKind_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::TopicKind_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::TopicKind_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::TopicKind_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::TopicKind_t& typed = *static_cast<const  ::OpenDDS::RTPS::TopicKind_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::TopicKind_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "value") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::TopicKind_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::TopicKind_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::TopicKind_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::TopicKind_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::TopicKind_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::TopicKind_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::TopicKind_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::TopicKind_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicKind_t */


/* Begin CONST: NO_KEY */


/* End CONST: NO_KEY */


/* Begin CONST: WITH_KEY */


/* End CONST: WITH_KEY */


/* Begin STRUCT: ReliabilityKind_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_ReliabilityKind_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_ReliabilityKind_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::ReliabilityKind_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.value)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::ReliabilityKind_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.write_int32(value.value);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::ReliabilityKind_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::ReliabilityKind_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::ReliabilityKind_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::ReliabilityKind_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::ReliabilityKind_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityKind_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::ReliabilityKind_t& typed = *static_cast<const  ::OpenDDS::RTPS::ReliabilityKind_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityKind_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "value") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityKind_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityKind_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityKind_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityKind_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::ReliabilityKind_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::ReliabilityKind_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::ReliabilityKind_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::ReliabilityKind_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReliabilityKind_t */


/* Begin CONST: BEST_EFFORT */


/* End CONST: BEST_EFFORT */


/* Begin CONST: RELIABLE */


/* End CONST: RELIABLE */


/* Begin STRUCT: ReliabilityQosPolicyRtps */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_ReliabilityQosPolicyRtps_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 165, 200, 168, 60, 12, 23, 106, 127, 63, 129, 60, 104, 33));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_ReliabilityQosPolicyRtps_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{"max_blocking_time",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.kind)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.max_blocking_time)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  vwrite(value_writer, value.kind);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_blocking_time");
  vwrite(value_writer, value.max_blocking_time);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::ReliabilityQosPolicyRtps& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.kind);
  set_default(stru.max_blocking_time);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.kind);
  serialized_size(encoding, size, stru.max_blocking_time);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.kind)
    && (strm << stru.max_blocking_time);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.max_blocking_time)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.kind);
  serialized_size(encoding, size, stru.value.max_blocking_time);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.kind)
    && (strm << stru.value.max_blocking_time);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::ReliabilityQosPolicyRtps>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.max_blocking_time)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::ReliabilityQosPolicyRtps> : MetaStruct {
  typedef  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
      std::make_pair("max_blocking_time", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityQosPolicyRtps)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps& typed = *static_cast<const  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "kind.", 5) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::ReliabilityKind_t>().getValue(&typed.kind, field + 5);
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.max_blocking_time, field + 18);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityQosPolicyRtps)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      return getMetaStruct< ::OpenDDS::RTPS::ReliabilityKind_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::ReliabilityKind_t*>(0))) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (base_field == "max_blocking_time") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'max_blocking_time' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "kind.", 5) == 0) {
      return make_struct_cmp(&T::kind, getMetaStruct< ::OpenDDS::RTPS::ReliabilityKind_t>().create_qc_comparator(field + 5), next);
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return make_struct_cmp(&T::max_blocking_time, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 18), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityQosPolicyRtps)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "max_blocking_time", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "max_blocking_time") == 0) {
      return &static_cast<const T*>(stru)->max_blocking_time;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityQosPolicyRtps)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::OpenDDS::RTPS::ReliabilityKind_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_blocking_time") == 0) {
      static_cast<T*>(lhs)->max_blocking_time = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityQosPolicyRtps)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ReliabilityQosPolicyRtps)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::ReliabilityQosPolicyRtps>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::ReliabilityQosPolicyRtps> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::ReliabilityQosPolicyRtps*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::ReliabilityQosPolicyRtps>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReliabilityQosPolicyRtps */


/* Begin STRUCT: KeyHash_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_KeyHash_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_KeyHash_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::KeyHash_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.value, 16)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::KeyHash_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.begin_array();
  value_writer.write_byte_array (value.value, 16);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(stru);
   ::DDS::OctetArray16_forany stru_value_temp(const_cast< ::DDS::OctetArray16_slice*>(stru.value));
  set_default(stru_value_temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value));
  serialized_size(encoding, size, stru_value_forany);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value));
  return (strm << stru_value_forany);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::KeyHash_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.value));
  serialized_size(encoding, size, stru_value_value_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::KeyHash_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.value));
  return (strm << stru_value_value_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::KeyHash_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.value));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_value_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::KeyHash_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::KeyHash_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::KeyHash_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::KeyHash_t& typed = *static_cast<const  ::OpenDDS::RTPS::KeyHash_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::KeyHash_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetArray16_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::KeyHash_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::KeyHash_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
       ::DDS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->value;
      const  ::DDS::OctetArray16* rhsArr = static_cast<const  ::DDS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::KeyHash_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::KeyHash_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::KeyHash_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::KeyHash_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::KeyHash_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::KeyHash_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: KeyHash_t */


/* Begin STRUCT: StatusInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_StatusInfo_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(133, 22, 18, 238, 85, 223, 209, 176, 88, 48, 223, 166, 156, 212));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_StatusInfo_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::StatusInfo_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.value, 4)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::StatusInfo_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.begin_array();
  value_writer.write_byte_array (value.value, 4);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::RTPS::OctetArray4_forany stru_value_temp(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  set_default(stru_value_temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::RTPS::OctetArray4_forany stru_value_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  serialized_size(encoding, size, stru_value_forany);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::RTPS::OctetArray4_forany stru_value_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  return (strm << stru_value_forany);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::RTPS::OctetArray4_forany stru_value_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::StatusInfo_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::RTPS::OctetArray4_forany stru_value_value_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value.value));
  serialized_size(encoding, size, stru_value_value_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::StatusInfo_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::RTPS::OctetArray4_forany stru_value_value_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value.value));
  return (strm << stru_value_value_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::StatusInfo_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::RTPS::OctetArray4_forany stru_value_value_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value.value));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_value_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::StatusInfo_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::StatusInfo_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::StatusInfo_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::StatusInfo_t& typed = *static_cast<const  ::OpenDDS::RTPS::StatusInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::StatusInfo_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::OctetArray4_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::StatusInfo_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::StatusInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
       ::OpenDDS::RTPS::OctetArray4* lhsArr = &static_cast<T*>(lhs)->value;
      const  ::OpenDDS::RTPS::OctetArray4* rhsArr = static_cast<const  ::OpenDDS::RTPS::OctetArray4*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::StatusInfo_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::StatusInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::StatusInfo_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::StatusInfo_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::StatusInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::StatusInfo_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StatusInfo_t */


/* Begin STRUCT: ProtocolVersion_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_ProtocolVersion_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(110, 72, 232, 232, 110, 217, 15, 250, 174, 208, 243, 110, 194, 46));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_ProtocolVersion_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::ProtocolVersion_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"major",0},{"minor",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_byte(value.major)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_byte(value.minor)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::ProtocolVersion_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("major");
  value_writer.write_byte(value.major);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("minor");
  value_writer.write_byte(value.minor);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.major = 0;
  stru.minor = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.major));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.minor));
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_octet(stru.major))
    && (strm << ACE_OutputCDR::from_octet(stru.minor));
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_octet(stru.major))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_octet(stru.minor))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::ProtocolVersion_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.value.major));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.value.minor));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::ProtocolVersion_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_octet(stru.value.major))
    && (strm << ACE_OutputCDR::from_octet(stru.value.minor));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::ProtocolVersion_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_octet(stru.value.major))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_octet(stru.value.minor))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::ProtocolVersion_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::ProtocolVersion_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("major", 0),
      std::make_pair("minor", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ProtocolVersion_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::ProtocolVersion_t& typed = *static_cast<const  ::OpenDDS::RTPS::ProtocolVersion_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "major") == 0) {
      return typed.major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return typed.minor;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ProtocolVersion_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "major") {
      ACE_CDR::Octet val;
      if (!(strm >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'major' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'major' could not be skipped");
      }
    }
    if (base_field == "minor") {
      ACE_CDR::Octet val;
      if (!(strm >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'minor' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'minor' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "major") == 0) {
      return make_field_cmp(&T::major, next);
    }
    if (std::strcmp(field, "minor") == 0) {
      return make_field_cmp(&T::minor, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ProtocolVersion_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"major", "minor", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "major") == 0) {
      return &static_cast<const T*>(stru)->major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return &static_cast<const T*>(stru)->minor;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ProtocolVersion_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "major") == 0) {
      static_cast<T*>(lhs)->major = *static_cast<const  ::CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "minor") == 0) {
      static_cast<T*>(lhs)->minor = *static_cast<const  ::CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ProtocolVersion_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "major") == 0) {
      return static_cast<const T*>(lhs)->major == static_cast<const T*>(rhs)->major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return static_cast<const T*>(lhs)->minor == static_cast<const T*>(rhs)->minor;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ProtocolVersion_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::ProtocolVersion_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::ProtocolVersion_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ProtocolVersion_t */


/* Begin STRUCT: VendorId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_VendorId_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(38, 51, 5, 107, 156, 29, 189, 228, 155, 120, 31, 109, 12, 240));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_VendorId_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::VendorId_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"vendorId",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.vendorId, 2)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::VendorId_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("vendorId");
  value_writer.begin_array();
  value_writer.write_byte_array (value.vendorId, 2);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::RTPS::OctetArray2_forany stru_vendorId_temp(const_cast< ::OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  set_default(stru_vendorId_temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::RTPS::OctetArray2_forany stru_vendorId_forany(const_cast< ::OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  serialized_size(encoding, size, stru_vendorId_forany);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::RTPS::OctetArray2_forany stru_vendorId_forany(const_cast< ::OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  return (strm << stru_vendorId_forany);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::RTPS::OctetArray2_forany stru_vendorId_forany(const_cast< ::OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_vendorId_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::VendorId_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::RTPS::OctetArray2_forany stru_value_vendorId_forany(const_cast< ::OpenDDS::RTPS::OctetArray2_slice*>(stru.value.vendorId));
  serialized_size(encoding, size, stru_value_vendorId_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::VendorId_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::RTPS::OctetArray2_forany stru_value_vendorId_forany(const_cast< ::OpenDDS::RTPS::OctetArray2_slice*>(stru.value.vendorId));
  return (strm << stru_value_vendorId_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::VendorId_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::RTPS::OctetArray2_forany stru_value_vendorId_forany(const_cast< ::OpenDDS::RTPS::OctetArray2_slice*>(stru.value.vendorId));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_vendorId_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::VendorId_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::VendorId_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("vendorId", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::VendorId_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::VendorId_t& typed = *static_cast<const  ::OpenDDS::RTPS::VendorId_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::VendorId_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::OctetArray2_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::VendorId_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"vendorId", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::VendorId_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "vendorId") == 0) {
       ::OpenDDS::RTPS::OctetArray2* lhsArr = &static_cast<T*>(lhs)->vendorId;
      const  ::OpenDDS::RTPS::OctetArray2* rhsArr = static_cast<const  ::OpenDDS::RTPS::OctetArray2*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::VendorId_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::VendorId_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::VendorId_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::VendorId_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::VendorId_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::VendorId_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: VendorId_t */


/* Begin TYPEDEF: IceAgentType_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_IceAgentType_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_IceAgentType_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: IceAgentType_t */


/* Begin CONST: ICE_FULL */


/* End CONST: ICE_FULL */


/* Begin CONST: ICE_LITE */


/* End CONST: ICE_LITE */


/* Begin STRUCT: IceGeneral_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_IceGeneral_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(146, 63, 166, 114, 163, 203, 97, 205, 144, 166, 92, 200, 247, 237));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_IceGeneral_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::IceGeneral_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"key",0},{"agent_type",1},{"username",2},{"password",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.key = x.c_str();
      }
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.agent_type)) return false;
      break;
    }
    case 2: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.username = x.c_str();
      }
      break;
    }
    case 3: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.password = x.c_str();
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::IceGeneral_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("key");
  value_writer.write_string(value.key);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("agent_type");
  value_writer.write_uint32(value.agent_type);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("username");
  value_writer.write_string(value.username);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("password");
  value_writer.write_string(value.password);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::IceGeneral_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.key = "";
  stru.agent_type = 0;
  stru.username = "";
  stru.password = "";
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::IceGeneral_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.key.in()) + 1;
  primitive_serialized_size(encoding, size, stru.agent_type);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.username.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.password.in()) + 1;
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::IceGeneral_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.key.in())
    && (strm << stru.agent_type)
    && (strm << stru.username.in())
    && (strm << stru.password.in());
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::IceGeneral_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.key.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.agent_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.username.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.password.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::IceGeneral_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.key.in()) + 1;
  primitive_serialized_size(encoding, size, stru.value.agent_type);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.username.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.password.in()) + 1;
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::IceGeneral_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key.in())
    && (strm << stru.value.agent_type)
    && (strm << stru.value.username.in())
    && (strm << stru.value.password.in());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::IceGeneral_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.agent_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.username.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.password.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::IceGeneral_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::IceGeneral_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("key", 0),
      std::make_pair("agent_type", 1),
      std::make_pair("username", 2),
      std::make_pair("password", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceGeneral_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::IceGeneral_t& typed = *static_cast<const  ::OpenDDS::RTPS::IceGeneral_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "key") == 0) {
      return typed.key.in();
    }
    if (std::strcmp(field, "agent_type") == 0) {
      return typed.agent_type;
    }
    if (std::strcmp(field, "username") == 0) {
      return typed.username.in();
    }
    if (std::strcmp(field, "password") == 0) {
      return typed.password.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceGeneral_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "key") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'key' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'key' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'key' contents could not be skipped");
      }
    }
    if (base_field == "agent_type") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'agent_type' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'agent_type' could not be skipped");
      }
    }
    if (base_field == "username") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'username' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'username' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'username' contents could not be skipped");
      }
    }
    if (base_field == "password") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'password' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'password' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'password' contents could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "key") == 0) {
      return make_field_cmp(&T::key, next);
    }
    if (std::strcmp(field, "agent_type") == 0) {
      return make_field_cmp(&T::agent_type, next);
    }
    if (std::strcmp(field, "username") == 0) {
      return make_field_cmp(&T::username, next);
    }
    if (std::strcmp(field, "password") == 0) {
      return make_field_cmp(&T::password, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceGeneral_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "agent_type", "username", "password", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "agent_type") == 0) {
      return &static_cast<const T*>(stru)->agent_type;
    }
    if (std::strcmp(field, "username") == 0) {
      return &static_cast<const T*>(stru)->username;
    }
    if (std::strcmp(field, "password") == 0) {
      return &static_cast<const T*>(stru)->password;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceGeneral_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "agent_type") == 0) {
      static_cast<T*>(lhs)->agent_type = *static_cast<const  ::OpenDDS::RTPS::IceAgentType_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "username") == 0) {
      static_cast<T*>(lhs)->username = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "password") == 0) {
      static_cast<T*>(lhs)->password = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceGeneral_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "key") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->key.in(), static_cast<const T*>(rhs)->key.in());
    }
    if (std::strcmp(field, "agent_type") == 0) {
      return static_cast<const T*>(lhs)->agent_type == static_cast<const T*>(rhs)->agent_type;
    }
    if (std::strcmp(field, "username") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->username.in(), static_cast<const T*>(rhs)->username.in());
    }
    if (std::strcmp(field, "password") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->password.in(), static_cast<const T*>(rhs)->password.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceGeneral_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::IceGeneral_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::IceGeneral_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::IceGeneral_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::IceGeneral_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: IceGeneral_t */


/* Begin TYPEDEF: IceCandidateType_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_IceCandidateType_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_IceCandidateType_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: IceCandidateType_t */


/* Begin CONST: ICE_HOST */


/* End CONST: ICE_HOST */


/* Begin CONST: ICE_SERVER_REFLEXIVE */


/* End CONST: ICE_SERVER_REFLEXIVE */


/* Begin CONST: ICE_PEER_REFLEXIVE */


/* End CONST: ICE_PEER_REFLEXIVE */


/* Begin CONST: ICE_RELAYED */


/* End CONST: ICE_RELAYED */


/* Begin STRUCT: IceCandidate_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_IceCandidate_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(99, 164, 202, 7, 10, 4, 116, 207, 251, 120, 151, 82, 190, 72));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_IceCandidate_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::IceCandidate_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"key",0},{"locator",1},{"foundation",2},{"priority",3},{"type",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.key = x.c_str();
      }
      break;
    }
    case 1: {
      if (!vread(value_reader, value.locator)) return false;
      break;
    }
    case 2: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.foundation = x.c_str();
      }
      break;
    }
    case 3: {
      if (!value_reader.read_uint32(value.priority)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_uint32(value.type)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::IceCandidate_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("key");
  value_writer.write_string(value.key);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("locator");
  vwrite(value_writer, value.locator);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("foundation");
  value_writer.write_string(value.foundation);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("priority");
  value_writer.write_uint32(value.priority);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("type");
  value_writer.write_uint32(value.type);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::IceCandidate_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.key = "";
  set_default(stru.locator);
  stru.foundation = "";
  stru.priority = 0;
  stru.type = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::IceCandidate_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.key.in()) + 1;
  serialized_size(encoding, size, stru.locator);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.foundation.in()) + 1;
  primitive_serialized_size(encoding, size, stru.priority);
  primitive_serialized_size(encoding, size, stru.type);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::IceCandidate_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.key.in())
    && (strm << stru.locator)
    && (strm << stru.foundation.in())
    && (strm << stru.priority)
    && (strm << stru.type);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::IceCandidate_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.key.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.locator)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.foundation.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.priority)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::IceCandidate_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.key.in()) + 1;
  serialized_size(encoding, size, stru.value.locator);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.foundation.in()) + 1;
  primitive_serialized_size(encoding, size, stru.value.priority);
  primitive_serialized_size(encoding, size, stru.value.type);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::IceCandidate_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key.in())
    && (strm << stru.value.locator)
    && (strm << stru.value.foundation.in())
    && (strm << stru.value.priority)
    && (strm << stru.value.type);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::IceCandidate_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.locator)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.foundation.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.priority)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::IceCandidate_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::IceCandidate_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("key", 0),
      std::make_pair("locator", 1),
      std::make_pair("foundation", 2),
      std::make_pair("priority", 3),
      std::make_pair("type", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceCandidate_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::IceCandidate_t& typed = *static_cast<const  ::OpenDDS::RTPS::IceCandidate_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "key") == 0) {
      return typed.key.in();
    }
    if (std::strncmp(field, "locator.", 8) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::Locator_t>().getValue(&typed.locator, field + 8);
    }
    if (std::strcmp(field, "foundation") == 0) {
      return typed.foundation.in();
    }
    if (std::strcmp(field, "priority") == 0) {
      return typed.priority;
    }
    if (std::strcmp(field, "type") == 0) {
      return typed.type;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceCandidate_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "key") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'key' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'key' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'key' contents could not be skipped");
      }
    }
    if (base_field == "locator") {
      return getMetaStruct< ::OpenDDS::DCPS::Locator_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::Locator_t*>(0))) {
        throw std::runtime_error("Field 'locator' could not be skipped");
      }
    }
    if (base_field == "foundation") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'foundation' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'foundation' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'foundation' contents could not be skipped");
      }
    }
    if (base_field == "priority") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'priority' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'priority' could not be skipped");
      }
    }
    if (base_field == "type") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'type' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'type' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "key") == 0) {
      return make_field_cmp(&T::key, next);
    }
    if (std::strncmp(field, "locator.", 8) == 0) {
      return make_struct_cmp(&T::locator, getMetaStruct< ::OpenDDS::DCPS::Locator_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strcmp(field, "foundation") == 0) {
      return make_field_cmp(&T::foundation, next);
    }
    if (std::strcmp(field, "priority") == 0) {
      return make_field_cmp(&T::priority, next);
    }
    if (std::strcmp(field, "type") == 0) {
      return make_field_cmp(&T::type, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceCandidate_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "locator", "foundation", "priority", "type", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "locator") == 0) {
      return &static_cast<const T*>(stru)->locator;
    }
    if (std::strcmp(field, "foundation") == 0) {
      return &static_cast<const T*>(stru)->foundation;
    }
    if (std::strcmp(field, "priority") == 0) {
      return &static_cast<const T*>(stru)->priority;
    }
    if (std::strcmp(field, "type") == 0) {
      return &static_cast<const T*>(stru)->type;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceCandidate_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "locator") == 0) {
      static_cast<T*>(lhs)->locator = *static_cast<const  ::OpenDDS::DCPS::Locator_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "foundation") == 0) {
      static_cast<T*>(lhs)->foundation = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "priority") == 0) {
      static_cast<T*>(lhs)->priority = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type") == 0) {
      static_cast<T*>(lhs)->type = *static_cast<const  ::OpenDDS::RTPS::IceCandidateType_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceCandidate_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "key") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->key.in(), static_cast<const T*>(rhs)->key.in());
    }
    if (std::strcmp(field, "foundation") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->foundation.in(), static_cast<const T*>(rhs)->foundation.in());
    }
    if (std::strcmp(field, "priority") == 0) {
      return static_cast<const T*>(lhs)->priority == static_cast<const T*>(rhs)->priority;
    }
    if (std::strcmp(field, "type") == 0) {
      return static_cast<const T*>(lhs)->type == static_cast<const T*>(rhs)->type;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::IceCandidate_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::IceCandidate_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::IceCandidate_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::IceCandidate_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::IceCandidate_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: IceCandidate_t */


/* Begin TYPEDEF: BuiltinEndpointSet_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_BuiltinEndpointSet_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_BuiltinEndpointSet_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: BuiltinEndpointSet_t */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_DETECTOR */


/* Begin CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_WRITER */


/* End CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_WRITER */


/* Begin CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_READER */


/* End CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_READER */


/* Begin CONST: BUILTIN_ENDPOINT_TYPE_LOOKUP_REQUEST_DATA_WRITER */


/* End CONST: BUILTIN_ENDPOINT_TYPE_LOOKUP_REQUEST_DATA_WRITER */


/* Begin CONST: BUILTIN_ENDPOINT_TYPE_LOOKUP_REQUEST_DATA_READER */


/* End CONST: BUILTIN_ENDPOINT_TYPE_LOOKUP_REQUEST_DATA_READER */


/* Begin CONST: BUILTIN_ENDPOINT_TYPE_LOOKUP_REPLY_DATA_WRITER */


/* End CONST: BUILTIN_ENDPOINT_TYPE_LOOKUP_REPLY_DATA_WRITER */


/* Begin CONST: BUILTIN_ENDPOINT_TYPE_LOOKUP_REPLY_DATA_READER */


/* End CONST: BUILTIN_ENDPOINT_TYPE_LOOKUP_REPLY_DATA_READER */


/* Begin TYPEDEF: BuiltinEndpointQos_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_BuiltinEndpointQos_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_BuiltinEndpointQos_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: BuiltinEndpointQos_t */


/* Begin CONST: BEST_EFFORT_PARTICIPANT_MESSAGE_DATA_READER */


/* End CONST: BEST_EFFORT_PARTICIPANT_MESSAGE_DATA_READER */


/* Begin UNION-FWD: Parameter */


/* End UNION-FWD: Parameter */


/* Begin TYPEDEF: ParameterList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_ParameterList_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(82, 136, 3, 161, 52, 193, 32, 193, 107, 215, 205, 208, 118, 237));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_ParameterList_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i]._d() == OpenDDS::RTPS::PID_SENTINEL) continue;
    serialized_size(encoding, size, seq[i]);
    align(size, 4);
  }
  size += 4; /* PID_SENTINEL */
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i]._d() == OpenDDS::RTPS::PID_SENTINEL) continue;
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return (strm << OpenDDS::RTPS::PID_SENTINEL)
    && (strm << OpenDDS::RTPS::PID_PAD);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  while (true) {
    const CORBA::ULong idx = OpenDDS::DCPS::grow(seq) - 1;
    if (!(strm >> seq[idx])) {
      return false;
    }
    if (seq[idx]._d() == OpenDDS::RTPS::PID_SENTINEL) {
      seq.length(idx);
      return true;
    }
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::ParameterList*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ParameterList */


/* Begin STRUCT: OriginalWriterInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_OriginalWriterInfo_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(0, 236, 19, 180, 137, 206, 245, 92, 185, 48, 236, 164, 76, 231));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_OriginalWriterInfo_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::OriginalWriterInfo_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"originalWriterGUID",0},{"originalWriterSN",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.originalWriterGUID)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.originalWriterSN)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::OriginalWriterInfo_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("originalWriterGUID");
  vwrite(value_writer, value.originalWriterGUID);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("originalWriterSN");
  vwrite(value_writer, value.originalWriterSN);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.originalWriterGUID);
  set_default(stru.originalWriterSN);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.originalWriterGUID);
  serialized_size(encoding, size, stru.originalWriterSN);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.originalWriterGUID)
    && (strm << stru.originalWriterSN);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.originalWriterGUID)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.originalWriterSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::OriginalWriterInfo_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.originalWriterGUID));
  serialized_size(encoding, size, stru.value.originalWriterSN);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::OriginalWriterInfo_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.originalWriterGUID))
    && (strm << stru.value.originalWriterSN);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::OriginalWriterInfo_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_originalWriterGUID_nested_key_only(stru.value.originalWriterGUID);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_originalWriterGUID_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.originalWriterSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::OriginalWriterInfo_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::OriginalWriterInfo_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("originalWriterGUID", 0),
      std::make_pair("originalWriterSN", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OriginalWriterInfo_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::OriginalWriterInfo_t& typed = *static_cast<const  ::OpenDDS::RTPS::OriginalWriterInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.originalWriterGUID, field + 19);
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.originalWriterSN, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "originalWriterGUID") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'originalWriterGUID' could not be skipped");
      }
    }
    if (base_field == "originalWriterSN") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'originalWriterSN' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return make_struct_cmp(&T::originalWriterGUID, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return make_struct_cmp(&T::originalWriterSN, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"originalWriterGUID", "originalWriterSN", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "originalWriterGUID") == 0) {
      return &static_cast<const T*>(stru)->originalWriterGUID;
    }
    if (std::strcmp(field, "originalWriterSN") == 0) {
      return &static_cast<const T*>(stru)->originalWriterSN;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "originalWriterGUID") == 0) {
      static_cast<T*>(lhs)->originalWriterGUID = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "originalWriterSN") == 0) {
      static_cast<T*>(lhs)->originalWriterSN = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OriginalWriterInfo_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OriginalWriterInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::OriginalWriterInfo_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::OriginalWriterInfo_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::OriginalWriterInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::OriginalWriterInfo_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OriginalWriterInfo_t */


/* Begin TYPEDEF: ParameterId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_ParameterId_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(128, 69, 94, 121, 109, 211, 67, 113, 99, 203, 83, 32, 137, 218));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_ParameterId_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ParameterId_t */


/* Begin CONST: PID_PAD */


/* End CONST: PID_PAD */


/* Begin CONST: PID_SENTINEL */


/* End CONST: PID_SENTINEL */


/* Begin CONST: PID_USER_DATA */


/* End CONST: PID_USER_DATA */


/* Begin CONST: PID_TOPIC_NAME */


/* End CONST: PID_TOPIC_NAME */


/* Begin CONST: PID_TYPE_NAME */


/* End CONST: PID_TYPE_NAME */


/* Begin CONST: PID_GROUP_DATA */


/* End CONST: PID_GROUP_DATA */


/* Begin CONST: PID_TOPIC_DATA */


/* End CONST: PID_TOPIC_DATA */


/* Begin CONST: PID_DURABILITY */


/* End CONST: PID_DURABILITY */


/* Begin CONST: PID_DURABILITY_SERVICE */


/* End CONST: PID_DURABILITY_SERVICE */


/* Begin CONST: PID_DEADLINE */


/* End CONST: PID_DEADLINE */


/* Begin CONST: PID_LATENCY_BUDGET */


/* End CONST: PID_LATENCY_BUDGET */


/* Begin CONST: PID_LIVELINESS */


/* End CONST: PID_LIVELINESS */


/* Begin CONST: PID_RELIABILITY */


/* End CONST: PID_RELIABILITY */


/* Begin CONST: PID_LIFESPAN */


/* End CONST: PID_LIFESPAN */


/* Begin CONST: PID_DESTINATION_ORDER */


/* End CONST: PID_DESTINATION_ORDER */


/* Begin CONST: PID_HISTORY */


/* End CONST: PID_HISTORY */


/* Begin CONST: PID_RESOURCE_LIMITS */


/* End CONST: PID_RESOURCE_LIMITS */


/* Begin CONST: PID_OWNERSHIP */


/* End CONST: PID_OWNERSHIP */


/* Begin CONST: PID_OWNERSHIP_STRENGTH */


/* End CONST: PID_OWNERSHIP_STRENGTH */


/* Begin CONST: PID_PRESENTATION */


/* End CONST: PID_PRESENTATION */


/* Begin CONST: PID_PARTITION */


/* End CONST: PID_PARTITION */


/* Begin CONST: PID_TIME_BASED_FILTER */


/* End CONST: PID_TIME_BASED_FILTER */


/* Begin CONST: PID_TRANSPORT_PRIORITY */


/* End CONST: PID_TRANSPORT_PRIORITY */


/* Begin CONST: PID_PROTOCOL_VERSION */


/* End CONST: PID_PROTOCOL_VERSION */


/* Begin CONST: PID_VENDORID */


/* End CONST: PID_VENDORID */


/* Begin CONST: PID_UNICAST_LOCATOR */


/* End CONST: PID_UNICAST_LOCATOR */


/* Begin CONST: PID_MULTICAST_LOCATOR */


/* End CONST: PID_MULTICAST_LOCATOR */


/* Begin CONST: PID_DEFAULT_UNICAST_LOCATOR */


/* End CONST: PID_DEFAULT_UNICAST_LOCATOR */


/* Begin CONST: PID_DEFAULT_MULTICAST_LOCATOR */


/* End CONST: PID_DEFAULT_MULTICAST_LOCATOR */


/* Begin CONST: PID_METATRAFFIC_UNICAST_LOCATOR */


/* End CONST: PID_METATRAFFIC_UNICAST_LOCATOR */


/* Begin CONST: PID_METATRAFFIC_MULTICAST_LOCATOR */


/* End CONST: PID_METATRAFFIC_MULTICAST_LOCATOR */


/* Begin CONST: PID_EXPECTS_INLINE_QOS */


/* End CONST: PID_EXPECTS_INLINE_QOS */


/* Begin CONST: PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT */


/* End CONST: PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT */


/* Begin CONST: PID_PARTICIPANT_BUILTIN_ENDPOINTS */


/* End CONST: PID_PARTICIPANT_BUILTIN_ENDPOINTS */


/* Begin CONST: PID_PARTICIPANT_LEASE_DURATION */


/* End CONST: PID_PARTICIPANT_LEASE_DURATION */


/* Begin CONST: PID_CONTENT_FILTER_PROPERTY */


/* End CONST: PID_CONTENT_FILTER_PROPERTY */


/* Begin CONST: PID_PARTICIPANT_GUID */


/* End CONST: PID_PARTICIPANT_GUID */


/* Begin CONST: PID_GROUP_GUID */


/* End CONST: PID_GROUP_GUID */


/* Begin CONST: PID_BUILTIN_ENDPOINT_SET */


/* End CONST: PID_BUILTIN_ENDPOINT_SET */


/* Begin CONST: PID_PROPERTY_LIST */


/* End CONST: PID_PROPERTY_LIST */


/* Begin CONST: PID_TYPE_MAX_SIZE_SERIALIZED */


/* End CONST: PID_TYPE_MAX_SIZE_SERIALIZED */


/* Begin CONST: PID_ENTITY_NAME */


/* End CONST: PID_ENTITY_NAME */


/* Begin CONST: PID_KEY_HASH */


/* End CONST: PID_KEY_HASH */


/* Begin CONST: PID_STATUS_INFO */


/* End CONST: PID_STATUS_INFO */


/* Begin CONST: PID_ENDPOINT_GUID */


/* End CONST: PID_ENDPOINT_GUID */


/* Begin CONST: PID_CONTENT_FILTER_INFO */


/* End CONST: PID_CONTENT_FILTER_INFO */


/* Begin CONST: PID_COHERENT_SET */


/* End CONST: PID_COHERENT_SET */


/* Begin CONST: PID_DIRECTED_WRITE */


/* End CONST: PID_DIRECTED_WRITE */


/* Begin CONST: PID_ORIGINAL_WRITER_INFO */


/* End CONST: PID_ORIGINAL_WRITER_INFO */


/* Begin CONST: PID_DATA_REPRESENTATION */


/* End CONST: PID_DATA_REPRESENTATION */


/* Begin CONST: PID_XTYPES_TYPE_CONSISTENCY */


/* End CONST: PID_XTYPES_TYPE_CONSISTENCY */


/* Begin CONST: PID_XTYPES_TYPE_INFORMATION */


/* End CONST: PID_XTYPES_TYPE_INFORMATION */


/* Begin CONST: PIDMASK_VENDOR_SPECIFIC */


/* End CONST: PIDMASK_VENDOR_SPECIFIC */


/* Begin CONST: PIDMASK_INCOMPATIBLE */


/* End CONST: PIDMASK_INCOMPATIBLE */


/* Begin CONST: PID_DOMAIN_ID */


/* End CONST: PID_DOMAIN_ID */


/* Begin CONST: PID_DOMAIN_TAG */


/* End CONST: PID_DOMAIN_TAG */


/* Begin CONST: PID_BUILTIN_ENDPOINT_QOS */


/* End CONST: PID_BUILTIN_ENDPOINT_QOS */


/* Begin TYPEDEF: OpenDDSParticipantFlagsBits_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_OpenDDSParticipantFlagsBits_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_OpenDDSParticipantFlagsBits_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: OpenDDSParticipantFlagsBits_t */


/* Begin CONST: PFLAGS_EMPTY */


/* End CONST: PFLAGS_EMPTY */


/* Begin CONST: PFLAGS_NO_ASSOCIATED_WRITERS */


/* End CONST: PFLAGS_NO_ASSOCIATED_WRITERS */


/* Begin CONST: PFLAGS_DIRECTED_HEARTBEAT */


/* End CONST: PFLAGS_DIRECTED_HEARTBEAT */


/* Begin CONST: PFLAGS_REFLECT_HEARTBEAT_COUNT */


/* End CONST: PFLAGS_REFLECT_HEARTBEAT_COUNT */


/* Begin CONST: PFLAGS_THIS_VERSION */


/* End CONST: PFLAGS_THIS_VERSION */


/* Begin STRUCT: OpenDDSParticipantFlags_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_OpenDDSParticipantFlags_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(117, 115, 123, 224, 198, 52, 178, 1, 245, 119, 232, 217, 48, 219));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_OpenDDSParticipantFlags_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"bits",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_uint32(value.bits)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("bits");
  value_writer.write_uint32(value.bits);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::OpenDDSParticipantFlags_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.bits = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.bits);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.bits);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.bits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.bits);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.bits);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.bits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("bits", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t& typed = *static_cast<const  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "bits") == 0) {
      return typed.bits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "bits") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'bits' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'bits' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "bits") == 0) {
      return make_field_cmp(&T::bits, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"bits", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bits") == 0) {
      return &static_cast<const T*>(stru)->bits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bits") == 0) {
      static_cast<T*>(lhs)->bits = *static_cast<const  ::OpenDDS::RTPS::OpenDDSParticipantFlagsBits_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "bits") == 0) {
      return static_cast<const T*>(lhs)->bits == static_cast<const T*>(rhs)->bits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OpenDDSParticipantFlags_t */


/* Begin CONST: PID_OPENDDS_BASE */


/* End CONST: PID_OPENDDS_BASE */


/* Begin CONST: PID_OPENDDS_LOCATOR */


/* End CONST: PID_OPENDDS_LOCATOR */


/* Begin CONST: PID_OPENDDS_ASSOCIATED_WRITER */


/* End CONST: PID_OPENDDS_ASSOCIATED_WRITER */


/* Begin CONST: PID_OPENDDS_ICE_GENERAL */


/* End CONST: PID_OPENDDS_ICE_GENERAL */


/* Begin CONST: PID_OPENDDS_ICE_CANDIDATE */


/* End CONST: PID_OPENDDS_ICE_CANDIDATE */


/* Begin CONST: PID_OPENDDS_PARTICIPANT_FLAGS */


/* End CONST: PID_OPENDDS_PARTICIPANT_FLAGS */


/* Begin CONST: PID_OPENDDS_RTPS_RELAY_APPLICATION_PARTICIPANT */


/* End CONST: PID_OPENDDS_RTPS_RELAY_APPLICATION_PARTICIPANT */


/* Begin UNION: Parameter */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Parameter_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(189, 234, 44, 41, 184, 44, 245, 89, 156, 86, 145, 192, 39, 61));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Parameter_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::Parameter& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  if (!value_reader.begin_union()) return false;
  if (!value_reader.begin_discriminator()) return false;
  {
     ::CORBA::UShort d;
    if (!value_reader.read_uint16(d)) return false;
    value._d(d);
  }
  if (!value_reader.end_discriminator()) return false;
  switch (value._d()) {
  case 5u:
  case 7u: {
    if (!value_reader.begin_union_member()) return false;
    std::string bv;
    {
      String x;
      if (!value_reader.read_string(x)) return false;
      bv = x.c_str();
    }
    value.string_data(bv.c_str());
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 44u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::UserDataQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.user_data(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 45u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::GroupDataQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.group_data(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 46u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::TopicDataQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.topic_data(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 29u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::DurabilityQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.durability(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 30u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::DurabilityServiceQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.durability_service(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 35u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::DeadlineQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.deadline(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 39u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::LatencyBudgetQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.latency_budget(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 27u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::LivelinessQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.liveliness(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 26u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::ReliabilityQosPolicyRtps bv;
    if (!vread(value_reader, bv)) return false;
    value.reliability(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 43u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::LifespanQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.lifespan(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 37u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::DestinationOrderQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.destination_order(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 64u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::HistoryQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.history(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 65u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::ResourceLimitsQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.resource_limits(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 31u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::OwnershipQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.ownership(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 6u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::OwnershipStrengthQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.ownership_strength(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 33u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::PresentationQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.presentation(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 41u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::PartitionQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.partition(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 4u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::TimeBasedFilterQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.time_based_filter(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 73u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::TransportPriorityQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.transport_priority(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 21u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::ProtocolVersion_t bv;
    if (!vread(value_reader, bv)) return false;
    value.version(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 22u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::VendorId_t bv;
    if (!vread(value_reader, bv)) return false;
    value.vendor(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::Locator_t bv;
    if (!vread(value_reader, bv)) return false;
    value.locator(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 67u: {
    if (!value_reader.begin_union_member()) return false;
     ::CORBA::Boolean bv;
    {
       ::CORBA::Boolean bx;
      if (!value_reader.read_boolean(bx)) return false;
      bv = bx;
    }
    value.expects_inline_qos(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 52u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::Count_t bv;
    if (!vread(value_reader, bv)) return false;
    value.count(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 68u: {
    if (!value_reader.begin_union_member()) return false;
     ::CORBA::ULong bv;
    if (!value_reader.read_uint32(bv)) return false;
    value.participant_builtin_endpoints(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 2u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::Duration_t bv;
    if (!vread(value_reader, bv)) return false;
    value.duration(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 53u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::ContentFilterProperty_t bv;
    if (!vread(value_reader, bv)) return false;
    value.content_filter_property(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::GUID_t bv;
    if (!vread(value_reader, bv)) return false;
    value.guid(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 45061u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::OpenDDSParticipantFlags_t bv;
    if (!vread(value_reader, bv)) return false;
    value.participant_flags(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 45062u: {
    if (!value_reader.begin_union_member()) return false;
     ::CORBA::Boolean bv;
    {
       ::CORBA::Boolean bx;
      if (!value_reader.read_boolean(bx)) return false;
      bv = bx;
    }
    value.opendds_rtps_relay_application_participant(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 88u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::BuiltinEndpointSet_t bv;
    if (!value_reader.read_uint32(bv)) return false;
    value.builtin_endpoints(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 89u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::PropertyQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.property(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 96u: {
    if (!value_reader.begin_union_member()) return false;
     ::CORBA::Long bv;
    if (!value_reader.read_int32(bv)) return false;
    value.type_max_size_serialized(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 98u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::EntityName_t bv;
    if (!vread(value_reader, bv)) return false;
    value.entity_name(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 112u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::KeyHash_t bv;
    if (!vread(value_reader, bv)) return false;
    value.key_hash(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 113u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::StatusInfo_t bv;
    if (!vread(value_reader, bv)) return false;
    value.status_info(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 85u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::ContentFilterInfo_t bv;
    if (!vread(value_reader, bv)) return false;
    value.content_filter_info(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 86u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::SequenceNumber_t bv;
    if (!vread(value_reader, bv)) return false;
    value.coherent_set(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 97u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::OriginalWriterInfo_t bv;
    if (!vread(value_reader, bv)) return false;
    value.original_writer_info(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 45057u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::TransportLocator bv;
    if (!vread(value_reader, bv)) return false;
    value.opendds_locator(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 45059u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::IceGeneral_t bv;
    if (!vread(value_reader, bv)) return false;
    value.ice_general(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 45060u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::IceCandidate_t bv;
    if (!vread(value_reader, bv)) return false;
    value.ice_candidate(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 15u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::DomainId_t bv;
    if (!value_reader.read_int32(bv)) return false;
    value.domainId(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 16404u: {
    if (!value_reader.begin_union_member()) return false;
    std::string bv;
    {
      String x;
      if (!value_reader.read_string(x)) return false;
      bv = x.c_str();
    }
    value.domainTag(bv.c_str());
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 119u: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::BuiltinEndpointQos_t bv;
    if (!value_reader.read_uint32(bv)) return false;
    value.builtinEndpointQos(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 117u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::OctetSeq bv;
    if (!value_reader.begin_sequence()) return false;
    for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
      OpenDDS::DCPS::grow(bv);
      if (!value_reader.begin_element()) return false;
      if (!value_reader.read_byte(bv[i])) return false;
      if (!value_reader.end_element()) return false;
    }
    if (!value_reader.end_sequence()) return false;
    value.type_information(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 115u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::DataRepresentationQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.representation(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case 116u: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::TypeConsistencyEnforcementQosPolicy bv;
    if (!vread(value_reader, bv)) return false;
    value.type_consistency(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  default: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::OctetSeq bv;
    if (!value_reader.begin_sequence()) return false;
    for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
      OpenDDS::DCPS::grow(bv);
      if (!value_reader.begin_element()) return false;
      if (!value_reader.read_byte(bv[i])) return false;
      if (!value_reader.end_element()) return false;
    }
    if (!value_reader.end_sequence()) return false;
    value.unknown_data(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  }
  if (!value_reader.end_union()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::Parameter& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_union();
  value_writer.begin_discriminator();
  value_writer.write_uint16(value._d());
  value_writer.end_discriminator();
  switch (value._d()) {
  case 5u:
  case 7u: {
    value_writer.begin_union_member("string_data");
    value_writer.write_string(value.string_data());
    value_writer.end_union_member();
    break;
  }
  case 44u: {
    value_writer.begin_union_member("user_data");
    vwrite(value_writer, value.user_data());
    value_writer.end_union_member();
    break;
  }
  case 45u: {
    value_writer.begin_union_member("group_data");
    vwrite(value_writer, value.group_data());
    value_writer.end_union_member();
    break;
  }
  case 46u: {
    value_writer.begin_union_member("topic_data");
    vwrite(value_writer, value.topic_data());
    value_writer.end_union_member();
    break;
  }
  case 29u: {
    value_writer.begin_union_member("durability");
    vwrite(value_writer, value.durability());
    value_writer.end_union_member();
    break;
  }
  case 30u: {
    value_writer.begin_union_member("durability_service");
    vwrite(value_writer, value.durability_service());
    value_writer.end_union_member();
    break;
  }
  case 35u: {
    value_writer.begin_union_member("deadline");
    vwrite(value_writer, value.deadline());
    value_writer.end_union_member();
    break;
  }
  case 39u: {
    value_writer.begin_union_member("latency_budget");
    vwrite(value_writer, value.latency_budget());
    value_writer.end_union_member();
    break;
  }
  case 27u: {
    value_writer.begin_union_member("liveliness");
    vwrite(value_writer, value.liveliness());
    value_writer.end_union_member();
    break;
  }
  case 26u: {
    value_writer.begin_union_member("reliability");
    vwrite(value_writer, value.reliability());
    value_writer.end_union_member();
    break;
  }
  case 43u: {
    value_writer.begin_union_member("lifespan");
    vwrite(value_writer, value.lifespan());
    value_writer.end_union_member();
    break;
  }
  case 37u: {
    value_writer.begin_union_member("destination_order");
    vwrite(value_writer, value.destination_order());
    value_writer.end_union_member();
    break;
  }
  case 64u: {
    value_writer.begin_union_member("history");
    vwrite(value_writer, value.history());
    value_writer.end_union_member();
    break;
  }
  case 65u: {
    value_writer.begin_union_member("resource_limits");
    vwrite(value_writer, value.resource_limits());
    value_writer.end_union_member();
    break;
  }
  case 31u: {
    value_writer.begin_union_member("ownership");
    vwrite(value_writer, value.ownership());
    value_writer.end_union_member();
    break;
  }
  case 6u: {
    value_writer.begin_union_member("ownership_strength");
    vwrite(value_writer, value.ownership_strength());
    value_writer.end_union_member();
    break;
  }
  case 33u: {
    value_writer.begin_union_member("presentation");
    vwrite(value_writer, value.presentation());
    value_writer.end_union_member();
    break;
  }
  case 41u: {
    value_writer.begin_union_member("partition");
    vwrite(value_writer, value.partition());
    value_writer.end_union_member();
    break;
  }
  case 4u: {
    value_writer.begin_union_member("time_based_filter");
    vwrite(value_writer, value.time_based_filter());
    value_writer.end_union_member();
    break;
  }
  case 73u: {
    value_writer.begin_union_member("transport_priority");
    vwrite(value_writer, value.transport_priority());
    value_writer.end_union_member();
    break;
  }
  case 21u: {
    value_writer.begin_union_member("version");
    vwrite(value_writer, value.version());
    value_writer.end_union_member();
    break;
  }
  case 22u: {
    value_writer.begin_union_member("vendor");
    vwrite(value_writer, value.vendor());
    value_writer.end_union_member();
    break;
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    value_writer.begin_union_member("locator");
    vwrite(value_writer, value.locator());
    value_writer.end_union_member();
    break;
  }
  case 67u: {
    value_writer.begin_union_member("expects_inline_qos");
    value_writer.write_boolean(value.expects_inline_qos());
    value_writer.end_union_member();
    break;
  }
  case 52u: {
    value_writer.begin_union_member("count");
    vwrite(value_writer, value.count());
    value_writer.end_union_member();
    break;
  }
  case 68u: {
    value_writer.begin_union_member("participant_builtin_endpoints");
    value_writer.write_uint32(value.participant_builtin_endpoints());
    value_writer.end_union_member();
    break;
  }
  case 2u: {
    value_writer.begin_union_member("duration");
    vwrite(value_writer, value.duration());
    value_writer.end_union_member();
    break;
  }
  case 53u: {
    value_writer.begin_union_member("content_filter_property");
    vwrite(value_writer, value.content_filter_property());
    value_writer.end_union_member();
    break;
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    value_writer.begin_union_member("guid");
    vwrite(value_writer, value.guid());
    value_writer.end_union_member();
    break;
  }
  case 45061u: {
    value_writer.begin_union_member("participant_flags");
    vwrite(value_writer, value.participant_flags());
    value_writer.end_union_member();
    break;
  }
  case 45062u: {
    value_writer.begin_union_member("opendds_rtps_relay_application_participant");
    value_writer.write_boolean(value.opendds_rtps_relay_application_participant());
    value_writer.end_union_member();
    break;
  }
  case 88u: {
    value_writer.begin_union_member("builtin_endpoints");
    value_writer.write_uint32(value.builtin_endpoints());
    value_writer.end_union_member();
    break;
  }
  case 89u: {
    value_writer.begin_union_member("property");
    vwrite(value_writer, value.property());
    value_writer.end_union_member();
    break;
  }
  case 96u: {
    value_writer.begin_union_member("type_max_size_serialized");
    value_writer.write_int32(value.type_max_size_serialized());
    value_writer.end_union_member();
    break;
  }
  case 98u: {
    value_writer.begin_union_member("entity_name");
    vwrite(value_writer, value.entity_name());
    value_writer.end_union_member();
    break;
  }
  case 112u: {
    value_writer.begin_union_member("key_hash");
    vwrite(value_writer, value.key_hash());
    value_writer.end_union_member();
    break;
  }
  case 113u: {
    value_writer.begin_union_member("status_info");
    vwrite(value_writer, value.status_info());
    value_writer.end_union_member();
    break;
  }
  case 85u: {
    value_writer.begin_union_member("content_filter_info");
    vwrite(value_writer, value.content_filter_info());
    value_writer.end_union_member();
    break;
  }
  case 86u: {
    value_writer.begin_union_member("coherent_set");
    vwrite(value_writer, value.coherent_set());
    value_writer.end_union_member();
    break;
  }
  case 97u: {
    value_writer.begin_union_member("original_writer_info");
    vwrite(value_writer, value.original_writer_info());
    value_writer.end_union_member();
    break;
  }
  case 45057u: {
    value_writer.begin_union_member("opendds_locator");
    vwrite(value_writer, value.opendds_locator());
    value_writer.end_union_member();
    break;
  }
  case 45059u: {
    value_writer.begin_union_member("ice_general");
    vwrite(value_writer, value.ice_general());
    value_writer.end_union_member();
    break;
  }
  case 45060u: {
    value_writer.begin_union_member("ice_candidate");
    vwrite(value_writer, value.ice_candidate());
    value_writer.end_union_member();
    break;
  }
  case 15u: {
    value_writer.begin_union_member("domainId");
    value_writer.write_int32(value.domainId());
    value_writer.end_union_member();
    break;
  }
  case 16404u: {
    value_writer.begin_union_member("domainTag");
    value_writer.write_string(value.domainTag());
    value_writer.end_union_member();
    break;
  }
  case 119u: {
    value_writer.begin_union_member("builtinEndpointQos");
    value_writer.write_uint32(value.builtinEndpointQos());
    value_writer.end_union_member();
    break;
  }
  case 117u: {
    value_writer.begin_union_member("type_information");
    value_writer.begin_sequence();
    value_writer.write_byte_array (value.type_information().get_buffer(), value.type_information().length());
    value_writer.end_sequence();
    value_writer.end_union_member();
    break;
  }
  case 115u: {
    value_writer.begin_union_member("representation");
    vwrite(value_writer, value.representation());
    value_writer.end_union_member();
    break;
  }
  case 116u: {
    value_writer.begin_union_member("type_consistency");
    vwrite(value_writer, value.type_consistency());
    value_writer.end_union_member();
    break;
  }
  default: {
    value_writer.begin_union_member("unknown_data");
    value_writer.begin_sequence();
    value_writer.write_byte_array (value.unknown_data().get_buffer(), value.unknown_data().length());
    value_writer.end_sequence();
    value_writer.end_union_member();
    break;
  }
  }
  value_writer.end_union();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(uni);
   ::CORBA::UShort temp;
    temp = 0;
  uni._d(temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case 5u:
  case 7u: {
    primitive_serialized_size_ulong(encoding, size);
    size += ACE_OS::strlen(uni.string_data()) + 1;
    break;
  }
  case 44u: {
    serialized_size(encoding, size, uni.user_data());
    break;
  }
  case 45u: {
    serialized_size(encoding, size, uni.group_data());
    break;
  }
  case 46u: {
    serialized_size(encoding, size, uni.topic_data());
    break;
  }
  case 29u: {
    serialized_size(encoding, size, uni.durability());
    break;
  }
  case 30u: {
    serialized_size(encoding, size, uni.durability_service());
    break;
  }
  case 35u: {
    serialized_size(encoding, size, uni.deadline());
    break;
  }
  case 39u: {
    serialized_size(encoding, size, uni.latency_budget());
    break;
  }
  case 27u: {
    serialized_size(encoding, size, uni.liveliness());
    break;
  }
  case 26u: {
    serialized_size(encoding, size, uni.reliability());
    break;
  }
  case 43u: {
    serialized_size(encoding, size, uni.lifespan());
    break;
  }
  case 37u: {
    serialized_size(encoding, size, uni.destination_order());
    break;
  }
  case 64u: {
    serialized_size(encoding, size, uni.history());
    break;
  }
  case 65u: {
    serialized_size(encoding, size, uni.resource_limits());
    break;
  }
  case 31u: {
    serialized_size(encoding, size, uni.ownership());
    break;
  }
  case 6u: {
    serialized_size(encoding, size, uni.ownership_strength());
    break;
  }
  case 33u: {
    serialized_size(encoding, size, uni.presentation());
    break;
  }
  case 41u: {
    serialized_size(encoding, size, uni.partition());
    break;
  }
  case 4u: {
    serialized_size(encoding, size, uni.time_based_filter());
    break;
  }
  case 73u: {
    serialized_size(encoding, size, uni.transport_priority());
    break;
  }
  case 21u: {
    serialized_size(encoding, size, uni.version());
    break;
  }
  case 22u: {
    serialized_size(encoding, size, uni.vendor());
    break;
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    serialized_size(encoding, size, uni.locator());
    break;
  }
  case 67u: {
    primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(uni.expects_inline_qos()));
    break;
  }
  case 52u: {
    serialized_size(encoding, size, uni.count());
    break;
  }
  case 68u: {
    primitive_serialized_size(encoding, size, uni.participant_builtin_endpoints());
    break;
  }
  case 2u: {
    serialized_size(encoding, size, uni.duration());
    break;
  }
  case 53u: {
    serialized_size(encoding, size, uni.content_filter_property());
    break;
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    serialized_size(encoding, size, uni.guid());
    break;
  }
  case 45061u: {
    serialized_size(encoding, size, uni.participant_flags());
    break;
  }
  case 45062u: {
    primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(uni.opendds_rtps_relay_application_participant()));
    break;
  }
  case 88u: {
    primitive_serialized_size(encoding, size, uni.builtin_endpoints());
    break;
  }
  case 89u: {
    serialized_size(encoding, size, uni.property());
    break;
  }
  case 96u: {
    primitive_serialized_size(encoding, size, uni.type_max_size_serialized());
    break;
  }
  case 98u: {
    serialized_size(encoding, size, uni.entity_name());
    break;
  }
  case 112u: {
    serialized_size(encoding, size, uni.key_hash());
    break;
  }
  case 113u: {
    serialized_size(encoding, size, uni.status_info());
    break;
  }
  case 85u: {
    serialized_size(encoding, size, uni.content_filter_info());
    break;
  }
  case 86u: {
    serialized_size(encoding, size, uni.coherent_set());
    break;
  }
  case 97u: {
    serialized_size(encoding, size, uni.original_writer_info());
    break;
  }
  case 45057u: {
    serialized_size(encoding, size, uni.opendds_locator());
    break;
  }
  case 45059u: {
    serialized_size(encoding, size, uni.ice_general());
    break;
  }
  case 45060u: {
    serialized_size(encoding, size, uni.ice_candidate());
    break;
  }
  case 15u: {
    primitive_serialized_size(encoding, size, uni.domainId());
    break;
  }
  case 16404u: {
    primitive_serialized_size_ulong(encoding, size);
    size += ACE_OS::strlen(uni.domainTag()) + 1;
    break;
  }
  case 119u: {
    primitive_serialized_size(encoding, size, uni.builtinEndpointQos());
    break;
  }
  case 117u: {
    serialized_size(encoding, size, uni.type_information());
    break;
  }
  case 115u: {
    serialized_size(encoding, size, uni.representation());
    break;
  }
  case 116u: {
    serialized_size(encoding, size, uni.type_consistency());
    break;
  }
  default: {
    serialized_size(encoding, size, uni.unknown_data());
    break;
  }
  }
  if (uni._d() == RTPS::PID_XTYPES_TYPE_INFORMATION) {
    // Parameter union uses OctetSeq but this is not actually a sequence
    size -= 4;
  }
  size += 4; // parameterId & length
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  size_t size = serialized_size(strm.encoding(), uni);
  size -= 4; // parameterId & length
  const size_t post_pad = 4 - (size % 4);
  const size_t total = size + ((post_pad < 4) ? post_pad : 0);
  if (size > ACE_UINT16_MAX || !(strm << ACE_CDR::UShort(total))) {
    return false;
  }
  const Serializer::ScopedAlignmentContext sac(strm);
  if (uni._d() == RTPS::PID_XTYPES_TYPE_INFORMATION) {
    if (!strm.write_octet_array(uni.type_information().get_buffer(), uni.type_information().length())) {
      return false;
    }
  } else if (!insertParamData(strm, uni)) {
    return false;
  }
  if (post_pad < 4 && strm.encoding().alignment() != Encoding::ALIGN_NONE) {
    static const ACE_CDR::Octet padding[3] = {0};
    return strm.write_octet_array(padding, ACE_CDR::ULong(post_pad));
  }
  return true;
}

bool insertParamData(Serializer& strm, const  ::OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case 5u:
  case 7u: {
    return (strm << ACE_OutputCDR::from_string(uni.string_data(), 256));
  }
  case 44u: {
    return (strm << uni.user_data());
  }
  case 45u: {
    return (strm << uni.group_data());
  }
  case 46u: {
    return (strm << uni.topic_data());
  }
  case 29u: {
    return (strm << uni.durability());
  }
  case 30u: {
    return (strm << uni.durability_service());
  }
  case 35u: {
    return (strm << uni.deadline());
  }
  case 39u: {
    return (strm << uni.latency_budget());
  }
  case 27u: {
    return (strm << uni.liveliness());
  }
  case 26u: {
    return (strm << uni.reliability());
  }
  case 43u: {
    return (strm << uni.lifespan());
  }
  case 37u: {
    return (strm << uni.destination_order());
  }
  case 64u: {
    return (strm << uni.history());
  }
  case 65u: {
    return (strm << uni.resource_limits());
  }
  case 31u: {
    return (strm << uni.ownership());
  }
  case 6u: {
    return (strm << uni.ownership_strength());
  }
  case 33u: {
    return (strm << uni.presentation());
  }
  case 41u: {
    return (strm << uni.partition());
  }
  case 4u: {
    return (strm << uni.time_based_filter());
  }
  case 73u: {
    return (strm << uni.transport_priority());
  }
  case 21u: {
    return (strm << uni.version());
  }
  case 22u: {
    return (strm << uni.vendor());
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    return (strm << uni.locator());
  }
  case 67u: {
    return (strm << ACE_OutputCDR::from_boolean(uni.expects_inline_qos()));
  }
  case 52u: {
    return (strm << uni.count());
  }
  case 68u: {
    return (strm << uni.participant_builtin_endpoints());
  }
  case 2u: {
    return (strm << uni.duration());
  }
  case 53u: {
    return (strm << uni.content_filter_property());
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    return (strm << uni.guid());
  }
  case 45061u: {
    return (strm << uni.participant_flags());
  }
  case 45062u: {
    return (strm << ACE_OutputCDR::from_boolean(uni.opendds_rtps_relay_application_participant()));
  }
  case 88u: {
    return (strm << uni.builtin_endpoints());
  }
  case 89u: {
    return (strm << uni.property());
  }
  case 96u: {
    return (strm << uni.type_max_size_serialized());
  }
  case 98u: {
    return (strm << uni.entity_name());
  }
  case 112u: {
    return (strm << uni.key_hash());
  }
  case 113u: {
    return (strm << uni.status_info());
  }
  case 85u: {
    return (strm << uni.content_filter_info());
  }
  case 86u: {
    return (strm << uni.coherent_set());
  }
  case 97u: {
    return (strm << uni.original_writer_info());
  }
  case 45057u: {
    return (strm << uni.opendds_locator());
  }
  case 45059u: {
    return (strm << uni.ice_general());
  }
  case 45060u: {
    return (strm << uni.ice_candidate());
  }
  case 15u: {
    return (strm << uni.domainId());
  }
  case 16404u: {
    return (strm << ACE_OutputCDR::from_string(uni.domainTag(), 256));
  }
  case 119u: {
    return (strm << uni.builtinEndpointQos());
  }
  case 117u: {
    return (strm << uni.type_information());
  }
  case 115u: {
    return (strm << uni.representation());
  }
  case 116u: {
    return (strm << uni.type_consistency());
  }
  default: {
    return (strm << uni.unknown_data());
  }
  }
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  ACE_CDR::UShort disc, size;
  if (!(strm >> disc) || !(strm >> size)) {
    return false;
  }
  if (disc == OpenDDS::RTPS::PID_SENTINEL) {
    uni._d(OpenDDS::RTPS::PID_SENTINEL);
    return true;
  }
  if (size == 0) {
    uni._d(disc);
    return true;
  }
  if (size > strm.length()) {
    return false;
  }
  if (disc == RTPS::PID_PROPERTY_LIST) {
    // support special case deserialization of DDS::PropertyQosPolicy
    Message_Block_Ptr param(strm.trim(size));
    strm.skip(size);
    Serializer strm2(param.get(), Encoding(Encoding::KIND_XCDR1, strm.swap_bytes()));
    ::DDS::PropertyQosPolicy tmp;
    if (strm2 >> tmp) {
      uni.property(tmp);
      return true;
    } else {
      return false;
    }
  }
  const Serializer::ScopedAlignmentContext sac(strm, size);
  if (disc == RTPS::PID_XTYPES_TYPE_INFORMATION) {
    DDS::OctetSeq type_info(size);
    type_info.length(size);
    if (!strm.read_octet_array(type_info.get_buffer(), size)) {
      return false;
    }
    uni.type_information(type_info);
    return true;
  }
  switch (disc) {
  case 5u:
  case 7u: {
    OPENDDS_STRING tmp;
    if (strm >> Serializer::ToBoundedString<char>(tmp, 256)) {
      uni.string_data(tmp.c_str());
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 44u: {
     ::DDS::UserDataQosPolicy tmp;
    if (strm >> tmp) {
      uni.user_data(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 45u: {
     ::DDS::GroupDataQosPolicy tmp;
    if (strm >> tmp) {
      uni.group_data(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 46u: {
     ::DDS::TopicDataQosPolicy tmp;
    if (strm >> tmp) {
      uni.topic_data(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 29u: {
     ::DDS::DurabilityQosPolicy tmp;
    if (strm >> tmp) {
      uni.durability(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 30u: {
     ::DDS::DurabilityServiceQosPolicy tmp;
    if (strm >> tmp) {
      uni.durability_service(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 35u: {
     ::DDS::DeadlineQosPolicy tmp;
    if (strm >> tmp) {
      uni.deadline(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 39u: {
     ::DDS::LatencyBudgetQosPolicy tmp;
    if (strm >> tmp) {
      uni.latency_budget(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 27u: {
     ::DDS::LivelinessQosPolicy tmp;
    if (strm >> tmp) {
      uni.liveliness(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 26u: {
     ::OpenDDS::RTPS::ReliabilityQosPolicyRtps tmp;
    if (strm >> tmp) {
      uni.reliability(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 43u: {
     ::DDS::LifespanQosPolicy tmp;
    if (strm >> tmp) {
      uni.lifespan(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 37u: {
     ::DDS::DestinationOrderQosPolicy tmp;
    if (strm >> tmp) {
      uni.destination_order(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 64u: {
     ::DDS::HistoryQosPolicy tmp;
    if (strm >> tmp) {
      uni.history(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 65u: {
     ::DDS::ResourceLimitsQosPolicy tmp;
    if (strm >> tmp) {
      uni.resource_limits(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 31u: {
     ::DDS::OwnershipQosPolicy tmp;
    if (strm >> tmp) {
      uni.ownership(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 6u: {
     ::DDS::OwnershipStrengthQosPolicy tmp;
    if (strm >> tmp) {
      uni.ownership_strength(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 33u: {
     ::DDS::PresentationQosPolicy tmp;
    if (strm >> tmp) {
      uni.presentation(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 41u: {
     ::DDS::PartitionQosPolicy tmp;
    if (strm >> tmp) {
      uni.partition(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 4u: {
     ::DDS::TimeBasedFilterQosPolicy tmp;
    if (strm >> tmp) {
      uni.time_based_filter(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 73u: {
     ::DDS::TransportPriorityQosPolicy tmp;
    if (strm >> tmp) {
      uni.transport_priority(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 21u: {
     ::OpenDDS::RTPS::ProtocolVersion_t tmp;
    if (strm >> tmp) {
      uni.version(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 22u: {
     ::OpenDDS::RTPS::VendorId_t tmp;
    if (strm >> tmp) {
      uni.vendor(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
     ::OpenDDS::DCPS::Locator_t tmp;
    if (strm >> tmp) {
      uni.locator(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 67u: {
     ::CORBA::Boolean tmp;
    if (strm >> ACE_InputCDR::to_boolean(tmp)) {
      uni.expects_inline_qos(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 52u: {
     ::OpenDDS::RTPS::Count_t tmp;
    if (strm >> tmp) {
      uni.count(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 68u: {
     ::CORBA::ULong tmp;
    if (strm >> tmp) {
      uni.participant_builtin_endpoints(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 2u: {
     ::OpenDDS::RTPS::Duration_t tmp;
    if (strm >> tmp) {
      uni.duration(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 53u: {
     ::OpenDDS::DCPS::ContentFilterProperty_t tmp;
    if (strm >> tmp) {
      uni.content_filter_property(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
     ::OpenDDS::DCPS::GUID_t tmp;
    if (strm >> tmp) {
      uni.guid(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 45061u: {
     ::OpenDDS::RTPS::OpenDDSParticipantFlags_t tmp;
    if (strm >> tmp) {
      uni.participant_flags(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 45062u: {
     ::CORBA::Boolean tmp;
    if (strm >> ACE_InputCDR::to_boolean(tmp)) {
      uni.opendds_rtps_relay_application_participant(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 88u: {
     ::OpenDDS::RTPS::BuiltinEndpointSet_t tmp;
    if (strm >> tmp) {
      uni.builtin_endpoints(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 89u: {
     ::DDS::PropertyQosPolicy tmp;
    if (strm >> tmp) {
      uni.property(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 96u: {
     ::CORBA::Long tmp;
    if (strm >> tmp) {
      uni.type_max_size_serialized(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 98u: {
     ::OpenDDS::RTPS::EntityName_t tmp;
    if (strm >> tmp) {
      uni.entity_name(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 112u: {
     ::OpenDDS::RTPS::KeyHash_t tmp;
    if (strm >> tmp) {
      uni.key_hash(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 113u: {
     ::OpenDDS::RTPS::StatusInfo_t tmp;
    if (strm >> tmp) {
      uni.status_info(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 85u: {
     ::OpenDDS::RTPS::ContentFilterInfo_t tmp;
    if (strm >> tmp) {
      uni.content_filter_info(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 86u: {
     ::OpenDDS::RTPS::SequenceNumber_t tmp;
    if (strm >> tmp) {
      uni.coherent_set(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 97u: {
     ::OpenDDS::RTPS::OriginalWriterInfo_t tmp;
    if (strm >> tmp) {
      uni.original_writer_info(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 45057u: {
     ::OpenDDS::DCPS::TransportLocator tmp;
    if (strm >> tmp) {
      uni.opendds_locator(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 45059u: {
     ::OpenDDS::RTPS::IceGeneral_t tmp;
    if (strm >> tmp) {
      uni.ice_general(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 45060u: {
     ::OpenDDS::RTPS::IceCandidate_t tmp;
    if (strm >> tmp) {
      uni.ice_candidate(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 15u: {
     ::DDS::DomainId_t tmp;
    if (strm >> tmp) {
      uni.domainId(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 16404u: {
    OPENDDS_STRING tmp;
    if (strm >> Serializer::ToBoundedString<char>(tmp, 256)) {
      uni.domainTag(tmp.c_str());
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 119u: {
     ::OpenDDS::RTPS::BuiltinEndpointQos_t tmp;
    if (strm >> tmp) {
      uni.builtinEndpointQos(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 117u: {
     ::DDS::OctetSeq tmp;
    if (strm >> tmp) {
      uni.type_information(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 115u: {
     ::DDS::DataRepresentationQosPolicy tmp;
    if (strm >> tmp) {
      uni.representation(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case 116u: {
     ::DDS::TypeConsistencyEnforcementQosPolicy tmp;
    if (strm >> tmp) {
      uni.type_consistency(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  default:
    {
      uni.unknown_data(DDS::OctetSeq(size));
      uni.unknown_data().length(size);
      if (!strm.read_octet_array(uni.unknown_data().get_buffer(), size)) {
        return false;
      }
      uni._d(disc);
    }
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::Parameter> : MetaStruct {
  typedef  ::OpenDDS::RTPS::Parameter T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::Parameter& typed = *static_cast<const  ::OpenDDS::RTPS::Parameter*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Parameter)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    ACE_UNUSED_ARG(ser);
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::OpenDDS::RTPS::Parameter");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Parameter)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    ACE_UNUSED_ARG(stru);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Parameter)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Parameter)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Parameter)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::Parameter>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::Parameter> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::Parameter*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  const bool is_mutable = 0;
  unsigned member_id;
  size_t field_size;
  bool must_understand = false;
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
   ::CORBA::UShort disc;
  if (!(ser >> disc)) {
    return false;
  }
  switch (disc) {
  case 5u:
  case 7u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    ACE_CDR::ULong len;
    if (!(ser >> len)) return false;
    if (!ser.skip(len)) return false;
    return true;
  }
  case 44u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::UserDataQosPolicy*>(0))) return false;
    return true;
  }
  case 45u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::GroupDataQosPolicy*>(0))) return false;
    return true;
  }
  case 46u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::TopicDataQosPolicy*>(0))) return false;
    return true;
  }
  case 29u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::DurabilityQosPolicy*>(0))) return false;
    return true;
  }
  case 30u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::DurabilityServiceQosPolicy*>(0))) return false;
    return true;
  }
  case 35u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::DeadlineQosPolicy*>(0))) return false;
    return true;
  }
  case 39u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::LatencyBudgetQosPolicy*>(0))) return false;
    return true;
  }
  case 27u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::LivelinessQosPolicy*>(0))) return false;
    return true;
  }
  case 26u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::ReliabilityQosPolicyRtps*>(0))) return false;
    return true;
  }
  case 43u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::LifespanQosPolicy*>(0))) return false;
    return true;
  }
  case 37u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::DestinationOrderQosPolicy*>(0))) return false;
    return true;
  }
  case 64u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::HistoryQosPolicy*>(0))) return false;
    return true;
  }
  case 65u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::ResourceLimitsQosPolicy*>(0))) return false;
    return true;
  }
  case 31u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::OwnershipQosPolicy*>(0))) return false;
    return true;
  }
  case 6u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::OwnershipStrengthQosPolicy*>(0))) return false;
    return true;
  }
  case 33u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::PresentationQosPolicy*>(0))) return false;
    return true;
  }
  case 41u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::PartitionQosPolicy*>(0))) return false;
    return true;
  }
  case 4u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::TimeBasedFilterQosPolicy*>(0))) return false;
    return true;
  }
  case 73u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::TransportPriorityQosPolicy*>(0))) return false;
    return true;
  }
  case 21u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::ProtocolVersion_t*>(0))) return false;
    return true;
  }
  case 22u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::VendorId_t*>(0))) return false;
    return true;
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::Locator_t*>(0))) return false;
    return true;
  }
  case 67u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 1)) return false;
    return true;
  }
  case 52u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::Count_t*>(0))) return false;
    return true;
  }
  case 68u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 2u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::Duration_t*>(0))) return false;
    return true;
  }
  case 53u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::ContentFilterProperty_t*>(0))) return false;
    return true;
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) return false;
    return true;
  }
  case 45061u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t*>(0))) return false;
    return true;
  }
  case 45062u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 1)) return false;
    return true;
  }
  case 88u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 89u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::PropertyQosPolicy*>(0))) return false;
    return true;
  }
  case 96u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 98u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::EntityName_t*>(0))) return false;
    return true;
  }
  case 112u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::KeyHash_t*>(0))) return false;
    return true;
  }
  case 113u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::StatusInfo_t*>(0))) return false;
    return true;
  }
  case 85u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::ContentFilterInfo_t*>(0))) return false;
    return true;
  }
  case 86u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) return false;
    return true;
  }
  case 97u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::OriginalWriterInfo_t*>(0))) return false;
    return true;
  }
  case 45057u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::TransportLocator*>(0))) return false;
    return true;
  }
  case 45059u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::IceGeneral_t*>(0))) return false;
    return true;
  }
  case 45060u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::IceCandidate_t*>(0))) return false;
    return true;
  }
  case 15u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 16404u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    ACE_CDR::ULong len;
    if (!(ser >> len)) return false;
    if (!ser.skip(len)) return false;
    return true;
  }
  case 119u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 117u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::OctetSeq*>(0))) return false;
    return true;
  }
  case 115u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::DataRepresentationQosPolicy*>(0))) return false;
    return true;
  }
  case 116u: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::TypeConsistencyEnforcementQosPolicy*>(0))) return false;
    return true;
  }
  default: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::OctetSeq*>(0))) return false;
    return true;
  }
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: Parameter */


/* Begin CONST: FLAG_E */


/* End CONST: FLAG_E */


/* Begin CONST: FLAG_Q */


/* End CONST: FLAG_Q */


/* Begin CONST: FLAG_F */


/* End CONST: FLAG_F */


/* Begin CONST: FLAG_I */


/* End CONST: FLAG_I */


/* Begin CONST: FLAG_M */


/* End CONST: FLAG_M */


/* Begin CONST: FLAG_D */


/* End CONST: FLAG_D */


/* Begin CONST: FLAG_L */


/* End CONST: FLAG_L */


/* Begin CONST: FLAG_K_IN_FRAG */


/* End CONST: FLAG_K_IN_FRAG */


/* Begin CONST: FLAG_K_IN_DATA */


/* End CONST: FLAG_K_IN_DATA */


/* Begin CONST: FLAG_N_IN_FRAG */


/* End CONST: FLAG_N_IN_FRAG */


/* Begin CONST: FLAG_N_IN_DATA */


/* End CONST: FLAG_N_IN_DATA */


/* Begin STRUCT: SubmessageHeader */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_SubmessageHeader_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_SubmessageHeader_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::SubmessageHeader& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"submessageId",0},{"flags",1},{"submessageLength",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_byte(value.submessageId)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_byte(value.flags)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint16(value.submessageLength)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::SubmessageHeader& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("submessageId");
  value_writer.write_byte(value.submessageId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("flags");
  value_writer.write_byte(value.flags);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("submessageLength");
  value_writer.write_uint16(value.submessageLength);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.submessageId = 0;
  stru.flags = 0;
  stru.submessageLength = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.submessageId));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.flags));
  primitive_serialized_size(encoding, size, stru.submessageLength);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  strm.swap_bytes(ACE_CDR_BYTE_ORDER != (stru.flags & 1));
  return (strm << ACE_OutputCDR::from_octet(stru.submessageId))
    && (strm << ACE_OutputCDR::from_octet(stru.flags))
    && (strm << stru.submessageLength);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_octet(stru.submessageId))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_octet(stru.flags))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.submessageLength)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::SubmessageHeader>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.value.submessageId));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.value.flags));
  primitive_serialized_size(encoding, size, stru.value.submessageLength);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::SubmessageHeader>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_octet(stru.value.submessageId))
    && (strm << ACE_OutputCDR::from_octet(stru.value.flags))
    && (strm << stru.value.submessageLength);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::SubmessageHeader>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_octet(stru.value.submessageId))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_octet(stru.value.flags))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.submessageLength)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::SubmessageHeader> : MetaStruct {
  typedef  ::OpenDDS::RTPS::SubmessageHeader T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("submessageId", 0),
      std::make_pair("flags", 1),
      std::make_pair("submessageLength", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SubmessageHeader)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::SubmessageHeader& typed = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "submessageId") == 0) {
      return typed.submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return typed.flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return typed.submessageLength;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SubmessageHeader)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "submessageId") {
      ACE_CDR::Octet val;
      if (!(strm >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'submessageId' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'submessageId' could not be skipped");
      }
    }
    if (base_field == "flags") {
      ACE_CDR::Octet val;
      if (!(strm >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'flags' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'flags' could not be skipped");
      }
    }
    if (base_field == "submessageLength") {
      ACE_CDR::UShort val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'submessageLength' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'submessageLength' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "submessageId") == 0) {
      return make_field_cmp(&T::submessageId, next);
    }
    if (std::strcmp(field, "flags") == 0) {
      return make_field_cmp(&T::flags, next);
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return make_field_cmp(&T::submessageLength, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SubmessageHeader)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"submessageId", "flags", "submessageLength", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "submessageId") == 0) {
      return &static_cast<const T*>(stru)->submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return &static_cast<const T*>(stru)->flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return &static_cast<const T*>(stru)->submessageLength;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SubmessageHeader)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "submessageId") == 0) {
      static_cast<T*>(lhs)->submessageId = *static_cast<const  ::CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "flags") == 0) {
      static_cast<T*>(lhs)->flags = *static_cast<const  ::CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      static_cast<T*>(lhs)->submessageLength = *static_cast<const  ::CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SubmessageHeader)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "submessageId") == 0) {
      return static_cast<const T*>(lhs)->submessageId == static_cast<const T*>(rhs)->submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return static_cast<const T*>(lhs)->flags == static_cast<const T*>(rhs)->flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return static_cast<const T*>(lhs)->submessageLength == static_cast<const T*>(rhs)->submessageLength;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SubmessageHeader)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::SubmessageHeader> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::SubmessageHeader*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::SubmessageHeader>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubmessageHeader */


/* Begin STRUCT: FragmentNumber_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_FragmentNumber_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(211, 69, 47, 26, 143, 144, 252, 240, 92, 219, 42, 193, 194, 64));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_FragmentNumber_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::FragmentNumber_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_uint32(value.value)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::FragmentNumber_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.write_uint32(value.value);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::FragmentNumber_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::FragmentNumber_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::FragmentNumber_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::FragmentNumber_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::FragmentNumber_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumber_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::FragmentNumber_t& typed = *static_cast<const  ::OpenDDS::RTPS::FragmentNumber_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumber_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "value") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumber_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumber_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumber_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumber_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::FragmentNumber_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::FragmentNumber_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: FragmentNumber_t */


/* Begin STRUCT: FragmentNumberSet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_FragmentNumberSet_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(174, 143, 129, 76, 253, 100, 99, 188, 219, 244, 101, 109, 25, 41));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_FragmentNumberSet_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::FragmentNumberSet& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"bitmapBase",0},{"numBits",1},{"bitmap",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.bitmapBase)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.numBits)) return false;
      break;
    }
    case 2: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.bitmap);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_int32(value.bitmap[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::FragmentNumberSet& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("bitmapBase");
  vwrite(value_writer, value.bitmapBase);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("numBits");
  value_writer.write_uint32(value.numBits);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("bitmap");
  value_writer.begin_sequence();
  value_writer.write_int32_array (value.bitmap.get_buffer(), value.bitmap.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.bitmapBase);
  stru.numBits = 0;
  stru.bitmap.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size += 8 + 4 * ((stru.numBits + 31) / 32); // RTPS Custom
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm << stru.bitmapBase) && (strm << stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (stru.bitmap.length() < M) {
      return false;
    }
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm << stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm >> stru.bitmapBase) && (strm >> stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (M > 8) {
      return false;
    }
    stru.bitmap.length(M);
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm >> stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::FragmentNumberSet> : MetaStruct {
  typedef  ::OpenDDS::RTPS::FragmentNumberSet T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("bitmapBase", 0),
      std::make_pair("numBits", 1),
      std::make_pair("bitmap", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumberSet)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::FragmentNumberSet& typed = *static_cast<const  ::OpenDDS::RTPS::FragmentNumberSet*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.bitmapBase, field + 11);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return typed.numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumberSet)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "bitmapBase") {
      return getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::FragmentNumber_t*>(0))) {
        throw std::runtime_error("Field 'bitmapBase' could not be skipped");
      }
    }
    if (base_field == "numBits") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'numBits' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'numBits' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::LongSeq8*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return make_struct_cmp(&T::bitmapBase, getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 11), next);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return make_field_cmp(&T::numBits, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumberSet)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"bitmapBase", "numBits", "bitmap", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bitmapBase") == 0) {
      return &static_cast<const T*>(stru)->bitmapBase;
    }
    if (std::strcmp(field, "numBits") == 0) {
      return &static_cast<const T*>(stru)->numBits;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      return &static_cast<const T*>(stru)->bitmap;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumberSet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bitmapBase") == 0) {
      static_cast<T*>(lhs)->bitmapBase = *static_cast<const  ::OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "numBits") == 0) {
      static_cast<T*>(lhs)->numBits = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      static_cast<T*>(lhs)->bitmap = *static_cast<const  ::OpenDDS::RTPS::LongSeq8*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumberSet)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "numBits") == 0) {
      return static_cast<const T*>(lhs)->numBits == static_cast<const T*>(rhs)->numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::FragmentNumberSet)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::FragmentNumberSet>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::FragmentNumberSet> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::FragmentNumberSet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::FragmentNumberSet>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: FragmentNumberSet */


/* Begin STRUCT: AckNackSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_AckNackSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(28, 163, 101, 61, 222, 61, 181, 14, 249, 2, 35, 3, 27, 80));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_AckNackSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::AckNackSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"readerId",1},{"writerId",2},{"readerSNState",3},{"count",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.readerId)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.writerId)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.readerSNState)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.count)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::AckNackSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerId");
  vwrite(value_writer, value.readerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerId");
  vwrite(value_writer, value.writerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerSNState");
  vwrite(value_writer, value.readerSNState);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("count");
  vwrite(value_writer, value.count);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  set_default(stru.readerId);
  set_default(stru.writerId);
  set_default(stru.readerSNState);
  set_default(stru.count);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  serialized_size(encoding, size, stru.readerId);
  serialized_size(encoding, size, stru.writerId);
  serialized_size(encoding, size, stru.readerSNState);
  serialized_size(encoding, size, stru.count);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.readerSNState)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerSNState)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::AckNackSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId));
  serialized_size(encoding, size, stru.value.readerSNState);
  serialized_size(encoding, size, stru.value.count);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::AckNackSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId))
    && (strm << stru.value.readerSNState)
    && (strm << stru.value.count);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::AckNackSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_readerId_nested_key_only(stru.value.readerId);
  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_writerId_nested_key_only(stru.value.writerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.readerSNState)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::AckNackSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::AckNackSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("readerId", 1),
      std::make_pair("writerId", 2),
      std::make_pair("readerSNState", 3),
      std::make_pair("count", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::AckNackSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::AckNackSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::AckNackSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumberSet>().getValue(&typed.readerSNState, field + 14);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::AckNackSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "readerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (base_field == "writerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (base_field == "readerSNState") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumberSet>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumberSet*>(0))) {
        throw std::runtime_error("Field 'readerSNState' could not be skipped");
      }
    }
    if (base_field == "count") {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return make_struct_cmp(&T::readerSNState, getMetaStruct< ::OpenDDS::RTPS::SequenceNumberSet>().create_qc_comparator(field + 14), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct< ::OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::AckNackSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "readerSNState", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "readerSNState") == 0) {
      return &static_cast<const T*>(stru)->readerSNState;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::AckNackSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerSNState") == 0) {
      static_cast<T*>(lhs)->readerSNState = *static_cast<const  ::OpenDDS::RTPS::SequenceNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const  ::OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::AckNackSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::AckNackSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::AckNackSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::AckNackSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::AckNackSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::AckNackSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: AckNackSubmessage */


/* Begin STRUCT: GapSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_GapSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(255, 4, 174, 218, 37, 5, 222, 128, 186, 53, 194, 162, 215, 91));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_GapSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::GapSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"readerId",1},{"writerId",2},{"gapStart",3},{"gapList",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.readerId)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.writerId)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.gapStart)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.gapList)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::GapSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerId");
  vwrite(value_writer, value.readerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerId");
  vwrite(value_writer, value.writerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("gapStart");
  vwrite(value_writer, value.gapStart);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("gapList");
  vwrite(value_writer, value.gapList);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  set_default(stru.readerId);
  set_default(stru.writerId);
  set_default(stru.gapStart);
  set_default(stru.gapList);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  serialized_size(encoding, size, stru.readerId);
  serialized_size(encoding, size, stru.writerId);
  serialized_size(encoding, size, stru.gapStart);
  serialized_size(encoding, size, stru.gapList);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.gapStart)
    && (strm << stru.gapList);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.gapStart)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.gapList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::GapSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId));
  serialized_size(encoding, size, stru.value.gapStart);
  serialized_size(encoding, size, stru.value.gapList);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::GapSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId))
    && (strm << stru.value.gapStart)
    && (strm << stru.value.gapList);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::GapSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_readerId_nested_key_only(stru.value.readerId);
  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_writerId_nested_key_only(stru.value.writerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.gapStart)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.gapList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::GapSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::GapSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("readerId", 1),
      std::make_pair("writerId", 2),
      std::make_pair("gapStart", 3),
      std::make_pair("gapList", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::GapSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::GapSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::GapSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.gapStart, field + 9);
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumberSet>().getValue(&typed.gapList, field + 8);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::GapSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "readerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (base_field == "writerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (base_field == "gapStart") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'gapStart' could not be skipped");
      }
    }
    if (base_field == "gapList") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumberSet>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumberSet*>(0))) {
        throw std::runtime_error("Field 'gapList' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return make_struct_cmp(&T::gapStart, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return make_struct_cmp(&T::gapList, getMetaStruct< ::OpenDDS::RTPS::SequenceNumberSet>().create_qc_comparator(field + 8), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::GapSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "gapStart", "gapList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "gapStart") == 0) {
      return &static_cast<const T*>(stru)->gapStart;
    }
    if (std::strcmp(field, "gapList") == 0) {
      return &static_cast<const T*>(stru)->gapList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::GapSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "gapStart") == 0) {
      static_cast<T*>(lhs)->gapStart = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "gapList") == 0) {
      static_cast<T*>(lhs)->gapList = *static_cast<const  ::OpenDDS::RTPS::SequenceNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::GapSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::GapSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::GapSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::GapSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::GapSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::GapSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GapSubmessage */


/* Begin STRUCT: InfoReplySubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_InfoReplySubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(188, 91, 255, 173, 137, 11, 90, 63, 130, 182, 219, 225, 235, 130));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_InfoReplySubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::InfoReplySubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"unicastLocatorList",1},{"multicastLocatorList",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.unicastLocatorList);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.unicastLocatorList[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 2: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.multicastLocatorList);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.multicastLocatorList[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::InfoReplySubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("unicastLocatorList");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.unicastLocatorList.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.unicastLocatorList[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("multicastLocatorList");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.multicastLocatorList.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.multicastLocatorList[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  stru.unicastLocatorList.length(0);
  stru.multicastLocatorList.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  serialized_size(encoding, size, stru.unicastLocatorList);
  if (stru.smHeader.flags & 2) {
    serialized_size(encoding, size, stru.multicastLocatorList);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.unicastLocatorList)
    && (!(stru.smHeader.flags & 2) || (strm << stru.multicastLocatorList));
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.unicastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if ((stru.smHeader.flags & 2) && !(strm >> stru.multicastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoReplySubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, stru.value.unicastLocatorList);
  serialized_size(encoding, size, stru.value.multicastLocatorList);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoReplySubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << stru.value.unicastLocatorList)
    && (strm << stru.value.multicastLocatorList);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::InfoReplySubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.unicastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.multicastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::InfoReplySubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::InfoReplySubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("unicastLocatorList", 1),
      std::make_pair("multicastLocatorList", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplySubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::InfoReplySubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::InfoReplySubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplySubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::LocatorList*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::LocatorList*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplySubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unicastLocatorList", "multicastLocatorList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->unicastLocatorList;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->multicastLocatorList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplySubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      static_cast<T*>(lhs)->unicastLocatorList = *static_cast<const  ::OpenDDS::RTPS::LocatorList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      static_cast<T*>(lhs)->multicastLocatorList = *static_cast<const  ::OpenDDS::RTPS::LocatorList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplySubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplySubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::InfoReplySubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::InfoReplySubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::InfoReplySubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::InfoReplySubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoReplySubmessage */


/* Begin STRUCT: NackFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_NackFragSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(198, 31, 110, 3, 217, 217, 69, 24, 16, 60, 254, 93, 63, 254));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_NackFragSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::NackFragSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"readerId",1},{"writerId",2},{"writerSN",3},{"fragmentNumberState",4},{"count",5},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.readerId)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.writerId)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.writerSN)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.fragmentNumberState)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.count)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::NackFragSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerId");
  vwrite(value_writer, value.readerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerId");
  vwrite(value_writer, value.writerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerSN");
  vwrite(value_writer, value.writerSN);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("fragmentNumberState");
  vwrite(value_writer, value.fragmentNumberState);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("count");
  vwrite(value_writer, value.count);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  set_default(stru.readerId);
  set_default(stru.writerId);
  set_default(stru.writerSN);
  set_default(stru.fragmentNumberState);
  set_default(stru.count);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  serialized_size(encoding, size, stru.readerId);
  serialized_size(encoding, size, stru.writerId);
  serialized_size(encoding, size, stru.writerSN);
  serialized_size(encoding, size, stru.fragmentNumberState);
  serialized_size(encoding, size, stru.count);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.fragmentNumberState)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.fragmentNumberState)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::NackFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId));
  serialized_size(encoding, size, stru.value.writerSN);
  serialized_size(encoding, size, stru.value.fragmentNumberState);
  serialized_size(encoding, size, stru.value.count);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::NackFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId))
    && (strm << stru.value.writerSN)
    && (strm << stru.value.fragmentNumberState)
    && (strm << stru.value.count);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::NackFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_readerId_nested_key_only(stru.value.readerId);
  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_writerId_nested_key_only(stru.value.writerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.writerSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.fragmentNumberState)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::NackFragSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::NackFragSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("readerId", 1),
      std::make_pair("writerId", 2),
      std::make_pair("writerSN", 3),
      std::make_pair("fragmentNumberState", 4),
      std::make_pair("count", 5),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 6);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::NackFragSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::NackFragSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::NackFragSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::FragmentNumberSet>().getValue(&typed.fragmentNumberState, field + 20);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::NackFragSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "readerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (base_field == "writerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (base_field == "writerSN") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'writerSN' could not be skipped");
      }
    }
    if (base_field == "fragmentNumberState") {
      return getMetaStruct< ::OpenDDS::RTPS::FragmentNumberSet>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::FragmentNumberSet*>(0))) {
        throw std::runtime_error("Field 'fragmentNumberState' could not be skipped");
      }
    }
    if (base_field == "count") {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return make_struct_cmp(&T::fragmentNumberState, getMetaStruct< ::OpenDDS::RTPS::FragmentNumberSet>().create_qc_comparator(field + 20), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct< ::OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::NackFragSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "writerSN", "fragmentNumberState", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "fragmentNumberState") == 0) {
      return &static_cast<const T*>(stru)->fragmentNumberState;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::NackFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentNumberState") == 0) {
      static_cast<T*>(lhs)->fragmentNumberState = *static_cast<const  ::OpenDDS::RTPS::FragmentNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const  ::OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::NackFragSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::NackFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::NackFragSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::NackFragSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::NackFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::NackFragSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: NackFragSubmessage */


/* Begin STRUCT: ParticipantProxy_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_ParticipantProxy_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(222, 70, 220, 15, 61, 238, 235, 97, 172, 112, 61, 247, 50, 154));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_ParticipantProxy_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::ParticipantProxy_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"domainId",0},{"domainTag",1},{"protocolVersion",2},{"guidPrefix",3},{"vendorId",4},{"expectsInlineQos",5},{"availableBuiltinEndpoints",6},{"builtinEndpointQos",7},{"metatrafficUnicastLocatorList",8},{"metatrafficMulticastLocatorList",9},{"defaultMulticastLocatorList",10},{"defaultUnicastLocatorList",11},{"manualLivelinessCount",12},{"property",13},{"opendds_participant_flags",14},{"opendds_rtps_relay_application_participant",15},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.domainId)) return false;
      break;
    }
    case 1: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.domainTag = x.c_str();
      }
      break;
    }
    case 2: {
      if (!vread(value_reader, value.protocolVersion)) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.guidPrefix, 12)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.vendorId)) return false;
      break;
    }
    case 5: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.expectsInlineQos = bx;
      }
      break;
    }
    case 6: {
      if (!value_reader.read_uint32(value.availableBuiltinEndpoints)) return false;
      break;
    }
    case 7: {
      if (!value_reader.read_uint32(value.builtinEndpointQos)) return false;
      break;
    }
    case 8: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.metatrafficUnicastLocatorList);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.metatrafficUnicastLocatorList[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 9: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.metatrafficMulticastLocatorList);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.metatrafficMulticastLocatorList[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 10: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.defaultMulticastLocatorList);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.defaultMulticastLocatorList[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 11: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.defaultUnicastLocatorList);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.defaultUnicastLocatorList[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 12: {
      if (!vread(value_reader, value.manualLivelinessCount)) return false;
      break;
    }
    case 13: {
      if (!vread(value_reader, value.property)) return false;
      break;
    }
    case 14: {
      if (!vread(value_reader, value.opendds_participant_flags)) return false;
      break;
    }
    case 15: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.opendds_rtps_relay_application_participant = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::ParticipantProxy_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("domainId");
  value_writer.write_int32(value.domainId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("domainTag");
  value_writer.write_string(value.domainTag);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("protocolVersion");
  vwrite(value_writer, value.protocolVersion);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("guidPrefix");
  value_writer.begin_array();
  value_writer.write_byte_array (value.guidPrefix, 12);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("vendorId");
  vwrite(value_writer, value.vendorId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("expectsInlineQos");
  value_writer.write_boolean(value.expectsInlineQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("availableBuiltinEndpoints");
  value_writer.write_uint32(value.availableBuiltinEndpoints);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("builtinEndpointQos");
  value_writer.write_uint32(value.builtinEndpointQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("metatrafficUnicastLocatorList");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.metatrafficUnicastLocatorList.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.metatrafficUnicastLocatorList[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("metatrafficMulticastLocatorList");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.metatrafficMulticastLocatorList.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.metatrafficMulticastLocatorList[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("defaultMulticastLocatorList");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.defaultMulticastLocatorList.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.defaultMulticastLocatorList[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("defaultUnicastLocatorList");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.defaultUnicastLocatorList.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.defaultUnicastLocatorList[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("manualLivelinessCount");
  vwrite(value_writer, value.manualLivelinessCount);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("property");
  vwrite(value_writer, value.property);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("opendds_participant_flags");
  vwrite(value_writer, value.opendds_participant_flags);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("opendds_rtps_relay_application_participant");
  value_writer.write_boolean(value.opendds_rtps_relay_application_participant);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.domainId = 0;
  stru.domainTag = "";
  set_default(stru.protocolVersion);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_temp(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  set_default(stru_guidPrefix_temp);
  set_default(stru.vendorId);
  stru.expectsInlineQos = 0;
  stru.availableBuiltinEndpoints = 0;
  stru.builtinEndpointQos = 0;
  stru.metatrafficUnicastLocatorList.length(0);
  stru.metatrafficMulticastLocatorList.length(0);
  stru.defaultMulticastLocatorList.length(0);
  stru.defaultUnicastLocatorList.length(0);
  set_default(stru.manualLivelinessCount);
  set_default(stru.property);
  set_default(stru.opendds_participant_flags);
  stru.opendds_rtps_relay_application_participant = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  primitive_serialized_size(encoding, size, stru.domainId);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.domainTag.in()) + 1;
  serialized_size(encoding, size, stru.protocolVersion);
  serialized_size(encoding, size, stru_guidPrefix_forany);
  serialized_size(encoding, size, stru.vendorId);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.expectsInlineQos));
  primitive_serialized_size(encoding, size, stru.availableBuiltinEndpoints);
  primitive_serialized_size(encoding, size, stru.builtinEndpointQos);
  serialized_size(encoding, size, stru.metatrafficUnicastLocatorList);
  serialized_size(encoding, size, stru.metatrafficMulticastLocatorList);
  serialized_size(encoding, size, stru.defaultMulticastLocatorList);
  serialized_size(encoding, size, stru.defaultUnicastLocatorList);
  serialized_size(encoding, size, stru.manualLivelinessCount);
  serialized_size(encoding, size, stru.property);
  serialized_size(encoding, size, stru.opendds_participant_flags);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.opendds_rtps_relay_application_participant));
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.domainId)
    && (strm << ACE_OutputCDR::from_string(stru.domainTag.in(), 256))
    && (strm << stru.protocolVersion)
    && (strm << stru_guidPrefix_forany)
    && (strm << stru.vendorId)
    && (strm << ACE_OutputCDR::from_boolean(stru.expectsInlineQos))
    && (strm << stru.availableBuiltinEndpoints)
    && (strm << stru.builtinEndpointQos)
    && (strm << stru.metatrafficUnicastLocatorList)
    && (strm << stru.metatrafficMulticastLocatorList)
    && (strm << stru.defaultMulticastLocatorList)
    && (strm << stru.defaultUnicastLocatorList)
    && (strm << stru.manualLivelinessCount)
    && (strm << stru.property)
    && (strm << stru.opendds_participant_flags)
    && (strm << ACE_OutputCDR::from_boolean(stru.opendds_rtps_relay_application_participant));
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.domainId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_string(stru.domainTag.out(), 256))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.protocolVersion)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_guidPrefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.vendorId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.expectsInlineQos))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.availableBuiltinEndpoints)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.builtinEndpointQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.metatrafficUnicastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.metatrafficMulticastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.defaultMulticastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.defaultUnicastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.manualLivelinessCount)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.property)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.opendds_participant_flags)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.opendds_rtps_relay_application_participant))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::ParticipantProxy_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  primitive_serialized_size(encoding, size, stru.value.domainId);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.domainTag.in()) + 1;
  serialized_size(encoding, size, stru.value.protocolVersion);
  serialized_size(encoding, size, stru_value_guidPrefix_forany);
  serialized_size(encoding, size, stru.value.vendorId);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.expectsInlineQos));
  primitive_serialized_size(encoding, size, stru.value.availableBuiltinEndpoints);
  primitive_serialized_size(encoding, size, stru.value.builtinEndpointQos);
  serialized_size(encoding, size, stru.value.metatrafficUnicastLocatorList);
  serialized_size(encoding, size, stru.value.metatrafficMulticastLocatorList);
  serialized_size(encoding, size, stru.value.defaultMulticastLocatorList);
  serialized_size(encoding, size, stru.value.defaultUnicastLocatorList);
  serialized_size(encoding, size, stru.value.manualLivelinessCount);
  serialized_size(encoding, size, stru.value.property);
  serialized_size(encoding, size, stru.value.opendds_participant_flags);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.opendds_rtps_relay_application_participant));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::ParticipantProxy_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  return (strm << stru.value.domainId)
    && (strm << ACE_OutputCDR::from_string(stru.value.domainTag.in(), 256))
    && (strm << stru.value.protocolVersion)
    && (strm << stru_value_guidPrefix_forany)
    && (strm << stru.value.vendorId)
    && (strm << ACE_OutputCDR::from_boolean(stru.value.expectsInlineQos))
    && (strm << stru.value.availableBuiltinEndpoints)
    && (strm << stru.value.builtinEndpointQos)
    && (strm << stru.value.metatrafficUnicastLocatorList)
    && (strm << stru.value.metatrafficMulticastLocatorList)
    && (strm << stru.value.defaultMulticastLocatorList)
    && (strm << stru.value.defaultUnicastLocatorList)
    && (strm << stru.value.manualLivelinessCount)
    && (strm << stru.value.property)
    && (strm << stru.value.opendds_participant_flags)
    && (strm << ACE_OutputCDR::from_boolean(stru.value.opendds_rtps_relay_application_participant));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::ParticipantProxy_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.domainId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_string(stru.value.domainTag.out(), 256))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.protocolVersion)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guidPrefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.vendorId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.expectsInlineQos))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.availableBuiltinEndpoints)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.builtinEndpointQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.metatrafficUnicastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.metatrafficMulticastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.defaultMulticastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.defaultUnicastLocatorList)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.manualLivelinessCount)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.property)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.opendds_participant_flags)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.opendds_rtps_relay_application_participant))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::ParticipantProxy_t> : MetaStruct {
  typedef  ::OpenDDS::RTPS::ParticipantProxy_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("domainId", 0),
      std::make_pair("domainTag", 1),
      std::make_pair("protocolVersion", 2),
      std::make_pair("guidPrefix", 3),
      std::make_pair("vendorId", 4),
      std::make_pair("expectsInlineQos", 5),
      std::make_pair("availableBuiltinEndpoints", 6),
      std::make_pair("builtinEndpointQos", 7),
      std::make_pair("metatrafficUnicastLocatorList", 8),
      std::make_pair("metatrafficMulticastLocatorList", 9),
      std::make_pair("defaultMulticastLocatorList", 10),
      std::make_pair("defaultUnicastLocatorList", 11),
      std::make_pair("manualLivelinessCount", 12),
      std::make_pair("property", 13),
      std::make_pair("opendds_participant_flags", 14),
      std::make_pair("opendds_rtps_relay_application_participant", 15),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 16);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantProxy_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::ParticipantProxy_t& typed = *static_cast<const  ::OpenDDS::RTPS::ParticipantProxy_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "domainId") == 0) {
      return typed.domainId;
    }
    if (std::strcmp(field, "domainTag") == 0) {
      return typed.domainTag.in();
    }
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.protocolVersion, field + 16);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return typed.expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return typed.availableBuiltinEndpoints;
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      return typed.builtinEndpointQos;
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(&typed.manualLivelinessCount, field + 22);
    }
    if (std::strncmp(field, "property.", 9) == 0) {
      return getMetaStruct< ::DDS::PropertyQosPolicy>().getValue(&typed.property, field + 9);
    }
    if (std::strncmp(field, "opendds_participant_flags.", 26) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t>().getValue(&typed.opendds_participant_flags, field + 26);
    }
    if (std::strcmp(field, "opendds_rtps_relay_application_participant") == 0) {
      return typed.opendds_rtps_relay_application_participant;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantProxy_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "domainId") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'domainId' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'domainId' could not be skipped");
      }
    }
    if (base_field == "domainTag") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'domainTag' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'domainTag' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'domainTag' contents could not be skipped");
      }
    }
    if (base_field == "protocolVersion") {
      return getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::ProtocolVersion_t*>(0))) {
        throw std::runtime_error("Field 'protocolVersion' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "vendorId") {
      return getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::VendorId_t*>(0))) {
        throw std::runtime_error("Field 'vendorId' could not be skipped");
      }
    }
    if (base_field == "expectsInlineQos") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be skipped");
      }
    }
    if (base_field == "availableBuiltinEndpoints") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'availableBuiltinEndpoints' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'availableBuiltinEndpoints' could not be skipped");
      }
    }
    if (base_field == "builtinEndpointQos") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'builtinEndpointQos' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'builtinEndpointQos' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::LocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::LocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::LocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::LocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "manualLivelinessCount") {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'manualLivelinessCount' could not be skipped");
      }
    }
    if (base_field == "property") {
      return getMetaStruct< ::DDS::PropertyQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PropertyQosPolicy*>(0))) {
        throw std::runtime_error("Field 'property' could not be skipped");
      }
    }
    if (base_field == "opendds_participant_flags") {
      return getMetaStruct< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t*>(0))) {
        throw std::runtime_error("Field 'opendds_participant_flags' could not be skipped");
      }
    }
    if (base_field == "opendds_rtps_relay_application_participant") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'opendds_rtps_relay_application_participant' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'opendds_rtps_relay_application_participant' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "domainId") == 0) {
      return make_field_cmp(&T::domainId, next);
    }
    if (std::strcmp(field, "domainTag") == 0) {
      return make_field_cmp(&T::domainTag, next);
    }
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return make_struct_cmp(&T::protocolVersion, getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return make_field_cmp(&T::expectsInlineQos, next);
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return make_field_cmp(&T::availableBuiltinEndpoints, next);
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      return make_field_cmp(&T::builtinEndpointQos, next);
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return make_struct_cmp(&T::manualLivelinessCount, getMetaStruct< ::OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 22), next);
    }
    if (std::strncmp(field, "property.", 9) == 0) {
      return make_struct_cmp(&T::property, getMetaStruct< ::DDS::PropertyQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "opendds_participant_flags.", 26) == 0) {
      return make_struct_cmp(&T::opendds_participant_flags, getMetaStruct< ::OpenDDS::RTPS::OpenDDSParticipantFlags_t>().create_qc_comparator(field + 26), next);
    }
    if (std::strcmp(field, "opendds_rtps_relay_application_participant") == 0) {
      return make_field_cmp(&T::opendds_rtps_relay_application_participant, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantProxy_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"domainId", "domainTag", "protocolVersion", "guidPrefix", "vendorId", "expectsInlineQos", "availableBuiltinEndpoints", "builtinEndpointQos", "metatrafficUnicastLocatorList", "metatrafficMulticastLocatorList", "defaultMulticastLocatorList", "defaultUnicastLocatorList", "manualLivelinessCount", "property", "opendds_participant_flags", "opendds_rtps_relay_application_participant", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "domainId") == 0) {
      return &static_cast<const T*>(stru)->domainId;
    }
    if (std::strcmp(field, "domainTag") == 0) {
      return &static_cast<const T*>(stru)->domainTag;
    }
    if (std::strcmp(field, "protocolVersion") == 0) {
      return &static_cast<const T*>(stru)->protocolVersion;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return &static_cast<const T*>(stru)->expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return &static_cast<const T*>(stru)->availableBuiltinEndpoints;
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      return &static_cast<const T*>(stru)->builtinEndpointQos;
    }
    if (std::strcmp(field, "metatrafficUnicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->metatrafficUnicastLocatorList;
    }
    if (std::strcmp(field, "metatrafficMulticastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->metatrafficMulticastLocatorList;
    }
    if (std::strcmp(field, "defaultMulticastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->defaultMulticastLocatorList;
    }
    if (std::strcmp(field, "defaultUnicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->defaultUnicastLocatorList;
    }
    if (std::strcmp(field, "manualLivelinessCount") == 0) {
      return &static_cast<const T*>(stru)->manualLivelinessCount;
    }
    if (std::strcmp(field, "property") == 0) {
      return &static_cast<const T*>(stru)->property;
    }
    if (std::strcmp(field, "opendds_participant_flags") == 0) {
      return &static_cast<const T*>(stru)->opendds_participant_flags;
    }
    if (std::strcmp(field, "opendds_rtps_relay_application_participant") == 0) {
      return &static_cast<const T*>(stru)->opendds_rtps_relay_application_participant;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "domainId") == 0) {
      static_cast<T*>(lhs)->domainId = *static_cast<const  ::DDS::DomainId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "domainTag") == 0) {
      static_cast<T*>(lhs)->domainTag = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "protocolVersion") == 0) {
      static_cast<T*>(lhs)->protocolVersion = *static_cast<const  ::OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
       ::OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const  ::OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const  ::OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const  ::OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      static_cast<T*>(lhs)->expectsInlineQos = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      static_cast<T*>(lhs)->availableBuiltinEndpoints = *static_cast<const  ::OpenDDS::RTPS::BuiltinEndpointSet_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      static_cast<T*>(lhs)->builtinEndpointQos = *static_cast<const  ::OpenDDS::RTPS::BuiltinEndpointQos_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "metatrafficUnicastLocatorList") == 0) {
      static_cast<T*>(lhs)->metatrafficUnicastLocatorList = *static_cast<const  ::OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "metatrafficMulticastLocatorList") == 0) {
      static_cast<T*>(lhs)->metatrafficMulticastLocatorList = *static_cast<const  ::OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "defaultMulticastLocatorList") == 0) {
      static_cast<T*>(lhs)->defaultMulticastLocatorList = *static_cast<const  ::OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "defaultUnicastLocatorList") == 0) {
      static_cast<T*>(lhs)->defaultUnicastLocatorList = *static_cast<const  ::OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "manualLivelinessCount") == 0) {
      static_cast<T*>(lhs)->manualLivelinessCount = *static_cast<const  ::OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "property") == 0) {
      static_cast<T*>(lhs)->property = *static_cast<const  ::DDS::PropertyQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "opendds_participant_flags") == 0) {
      static_cast<T*>(lhs)->opendds_participant_flags = *static_cast<const  ::OpenDDS::RTPS::OpenDDSParticipantFlags_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "opendds_rtps_relay_application_participant") == 0) {
      static_cast<T*>(lhs)->opendds_rtps_relay_application_participant = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantProxy_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "domainId") == 0) {
      return static_cast<const T*>(lhs)->domainId == static_cast<const T*>(rhs)->domainId;
    }
    if (std::strcmp(field, "domainTag") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->domainTag.in(), static_cast<const T*>(rhs)->domainTag.in());
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return static_cast<const T*>(lhs)->expectsInlineQos == static_cast<const T*>(rhs)->expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return static_cast<const T*>(lhs)->availableBuiltinEndpoints == static_cast<const T*>(rhs)->availableBuiltinEndpoints;
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      return static_cast<const T*>(lhs)->builtinEndpointQos == static_cast<const T*>(rhs)->builtinEndpointQos;
    }
    if (std::strcmp(field, "opendds_rtps_relay_application_participant") == 0) {
      return static_cast<const T*>(lhs)->opendds_rtps_relay_application_participant == static_cast<const T*>(rhs)->opendds_rtps_relay_application_participant;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::ParticipantProxy_t>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::ParticipantProxy_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::ParticipantProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::ParticipantProxy_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantProxy_t */


/* Begin STRUCT: SPDPdiscoveredParticipantData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_SPDPdiscoveredParticipantData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(211, 252, 222, 70, 78, 152, 101, 78, 245, 173, 45, 230, 81, 25));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_SPDPdiscoveredParticipantData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"ddsParticipantData",0},{"participantProxy",1},{"leaseDuration",2},{"discoveredAt",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.ddsParticipantData)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.participantProxy)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.leaseDuration)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.discoveredAt)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("ddsParticipantData");
  vwrite(value_writer, value.ddsParticipantData);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("participantProxy");
  vwrite(value_writer, value.participantProxy);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("leaseDuration");
  vwrite(value_writer, value.leaseDuration);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("discoveredAt");
  vwrite(value_writer, value.discoveredAt);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.ddsParticipantData);
  set_default(stru.participantProxy);
  set_default(stru.leaseDuration);
  set_default(stru.discoveredAt);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.ddsParticipantData);
  serialized_size(encoding, size, stru.participantProxy);
  serialized_size(encoding, size, stru.leaseDuration);
  serialized_size(encoding, size, stru.discoveredAt);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.ddsParticipantData)
    && (strm << stru.participantProxy)
    && (strm << stru.leaseDuration)
    && (strm << stru.discoveredAt);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ddsParticipantData)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.participantProxy)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.leaseDuration)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.discoveredAt)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::DDS::ParticipantBuiltinTopicData>(stru.value.ddsParticipantData));
  serialized_size(encoding, size, stru.value.participantProxy);
  serialized_size(encoding, size, stru.value.leaseDuration);
  serialized_size(encoding, size, stru.value.discoveredAt);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::DDS::ParticipantBuiltinTopicData>(stru.value.ddsParticipantData))
    && (strm << stru.value.participantProxy)
    && (strm << stru.value.leaseDuration)
    && (strm << stru.value.discoveredAt);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::SPDPdiscoveredParticipantData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::DDS::ParticipantBuiltinTopicData> stru_value_ddsParticipantData_nested_key_only(stru.value.ddsParticipantData);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_ddsParticipantData_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.participantProxy)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.leaseDuration)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.discoveredAt)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::SPDPdiscoveredParticipantData> : MetaStruct {
  typedef  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("ddsParticipantData", 0),
      std::make_pair("participantProxy", 1),
      std::make_pair("leaseDuration", 2),
      std::make_pair("discoveredAt", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData& typed = *static_cast<const  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return getMetaStruct< ::DDS::ParticipantBuiltinTopicData>().getValue(&typed.ddsParticipantData, field + 19);
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::ParticipantProxy_t>().getValue(&typed.participantProxy, field + 17);
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::Duration_t>().getValue(&typed.leaseDuration, field + 14);
    }
    if (std::strncmp(field, "discoveredAt.", 13) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().getValue(&typed.discoveredAt, field + 13);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "ddsParticipantData") {
      return getMetaStruct< ::DDS::ParticipantBuiltinTopicData>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ParticipantBuiltinTopicData*>(0))) {
        throw std::runtime_error("Field 'ddsParticipantData' could not be skipped");
      }
    }
    if (base_field == "participantProxy") {
      return getMetaStruct< ::OpenDDS::RTPS::ParticipantProxy_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::ParticipantProxy_t*>(0))) {
        throw std::runtime_error("Field 'participantProxy' could not be skipped");
      }
    }
    if (base_field == "leaseDuration") {
      return getMetaStruct< ::OpenDDS::RTPS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'leaseDuration' could not be skipped");
      }
    }
    if (base_field == "discoveredAt") {
      return getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::MonotonicTime_t*>(0))) {
        throw std::runtime_error("Field 'discoveredAt' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return make_struct_cmp(&T::ddsParticipantData, getMetaStruct< ::DDS::ParticipantBuiltinTopicData>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return make_struct_cmp(&T::participantProxy, getMetaStruct< ::OpenDDS::RTPS::ParticipantProxy_t>().create_qc_comparator(field + 17), next);
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return make_struct_cmp(&T::leaseDuration, getMetaStruct< ::OpenDDS::RTPS::Duration_t>().create_qc_comparator(field + 14), next);
    }
    if (std::strncmp(field, "discoveredAt.", 13) == 0) {
      return make_struct_cmp(&T::discoveredAt, getMetaStruct< ::OpenDDS::DCPS::MonotonicTime_t>().create_qc_comparator(field + 13), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsParticipantData", "participantProxy", "leaseDuration", "discoveredAt", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsParticipantData") == 0) {
      return &static_cast<const T*>(stru)->ddsParticipantData;
    }
    if (std::strcmp(field, "participantProxy") == 0) {
      return &static_cast<const T*>(stru)->participantProxy;
    }
    if (std::strcmp(field, "leaseDuration") == 0) {
      return &static_cast<const T*>(stru)->leaseDuration;
    }
    if (std::strcmp(field, "discoveredAt") == 0) {
      return &static_cast<const T*>(stru)->discoveredAt;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsParticipantData") == 0) {
      static_cast<T*>(lhs)->ddsParticipantData = *static_cast<const  ::DDS::ParticipantBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participantProxy") == 0) {
      static_cast<T*>(lhs)->participantProxy = *static_cast<const  ::OpenDDS::RTPS::ParticipantProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "leaseDuration") == 0) {
      static_cast<T*>(lhs)->leaseDuration = *static_cast<const  ::OpenDDS::RTPS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "discoveredAt") == 0) {
      static_cast<T*>(lhs)->discoveredAt = *static_cast<const  ::OpenDDS::DCPS::MonotonicTime_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::SPDPdiscoveredParticipantData>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::SPDPdiscoveredParticipantData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::SPDPdiscoveredParticipantData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::SPDPdiscoveredParticipantData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SPDPdiscoveredParticipantData */


/* Begin STRUCT: ParticipantMessageData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_ParticipantMessageData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(168, 192, 24, 83, 50, 210, 165, 196, 183, 194, 47, 48, 178, 159));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_ParticipantMessageData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::ParticipantMessageData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"participantGuid",0},{"data",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.participantGuid)) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.data);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.data[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::ParticipantMessageData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("participantGuid");
  vwrite(value_writer, value.participantGuid);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("data");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.data.get_buffer(), value.data.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.participantGuid);
  stru.data.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.participantGuid);
  serialized_size(encoding, size, stru.data);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.participantGuid)
    && (strm << stru.data);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.participantGuid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::ParticipantMessageData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.participantGuid));
  serialized_size(encoding, size, stru.value.data);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::ParticipantMessageData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.participantGuid))
    && (strm << stru.value.data);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::ParticipantMessageData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_participantGuid_nested_key_only(stru.value.participantGuid);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_participantGuid_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::ParticipantMessageData> : MetaStruct {
  typedef  ::OpenDDS::RTPS::ParticipantMessageData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("participantGuid", 0),
      std::make_pair("data", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantMessageData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::ParticipantMessageData& typed = *static_cast<const  ::OpenDDS::RTPS::ParticipantMessageData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.participantGuid, field + 16);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantMessageData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "participantGuid") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'participantGuid' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return make_struct_cmp(&T::participantGuid, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 16), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantMessageData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"participantGuid", "data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "participantGuid") == 0) {
      return &static_cast<const T*>(stru)->participantGuid;
    }
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantMessageData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "participantGuid") == 0) {
      static_cast<T*>(lhs)->participantGuid = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data") == 0) {
      static_cast<T*>(lhs)->data = *static_cast<const  ::DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantMessageData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::ParticipantMessageData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::ParticipantMessageData>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::ParticipantMessageData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::ParticipantMessageData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::ParticipantMessageData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantMessageData */


/* Begin STRUCT: Header */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Header_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(135, 85, 81, 27, 49, 2, 203, 211, 40, 79, 154, 88, 201, 112));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Header_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::Header& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"prefix",0},{"version",1},{"vendorId",2},{"guidPrefix",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.prefix, 4)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.version)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.vendorId)) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.guidPrefix, 12)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::Header& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("prefix");
  value_writer.begin_array();
  value_writer.write_byte_array (value.prefix, 4);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("version");
  vwrite(value_writer, value.version);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("vendorId");
  vwrite(value_writer, value.vendorId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("guidPrefix");
  value_writer.begin_array();
  value_writer.write_byte_array (value.guidPrefix, 12);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(stru);
   ::OpenDDS::RTPS::OctetArray4_forany stru_prefix_temp(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  set_default(stru_prefix_temp);
  set_default(stru.version);
  set_default(stru.vendorId);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_temp(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  set_default(stru_guidPrefix_temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::RTPS::OctetArray4_forany stru_prefix_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  serialized_size(encoding, size, stru_prefix_forany);
  serialized_size(encoding, size, stru.version);
  serialized_size(encoding, size, stru.vendorId);
  serialized_size(encoding, size, stru_guidPrefix_forany);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::RTPS::OctetArray4_forany stru_prefix_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru_prefix_forany)
    && (strm << stru.version)
    && (strm << stru.vendorId)
    && (strm << stru_guidPrefix_forany);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::RTPS::OctetArray4_forany stru_prefix_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_prefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.version)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.vendorId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_guidPrefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::Header>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::RTPS::OctetArray4_forany stru_value_prefix_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value.prefix));
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  serialized_size(encoding, size, stru_value_prefix_forany);
  serialized_size(encoding, size, stru.value.version);
  serialized_size(encoding, size, stru.value.vendorId);
  serialized_size(encoding, size, stru_value_guidPrefix_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::Header>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::RTPS::OctetArray4_forany stru_value_prefix_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value.prefix));
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  return (strm << stru_value_prefix_forany)
    && (strm << stru.value.version)
    && (strm << stru.value.vendorId)
    && (strm << stru_value_guidPrefix_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::Header>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::RTPS::OctetArray4_forany stru_value_prefix_forany(const_cast< ::OpenDDS::RTPS::OctetArray4_slice*>(stru.value.prefix));
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_prefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.version)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.vendorId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guidPrefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::Header> : MetaStruct {
  typedef  ::OpenDDS::RTPS::Header T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("prefix", 0),
      std::make_pair("version", 1),
      std::make_pair("vendorId", 2),
      std::make_pair("guidPrefix", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Header)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::Header& typed = *static_cast<const  ::OpenDDS::RTPS::Header*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.version, field + 8);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Header)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::OctetArray4_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "version") {
      return getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::ProtocolVersion_t*>(0))) {
        throw std::runtime_error("Field 'version' could not be skipped");
      }
    }
    if (base_field == "vendorId") {
      return getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::VendorId_t*>(0))) {
        throw std::runtime_error("Field 'vendorId' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "version.", 8) == 0) {
      return make_struct_cmp(&T::version, getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Header)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"prefix", "version", "vendorId", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "prefix") == 0) {
      return &static_cast<const T*>(stru)->prefix;
    }
    if (std::strcmp(field, "version") == 0) {
      return &static_cast<const T*>(stru)->version;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Header)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "prefix") == 0) {
       ::OpenDDS::RTPS::OctetArray4* lhsArr = &static_cast<T*>(lhs)->prefix;
      const  ::OpenDDS::RTPS::OctetArray4* rhsArr = static_cast<const  ::OpenDDS::RTPS::OctetArray4*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "version") == 0) {
      static_cast<T*>(lhs)->version = *static_cast<const  ::OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const  ::OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
       ::OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const  ::OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const  ::OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Header)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Header)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::Header>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::Header> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::Header*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::Header>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Header */


/* Begin STRUCT: DataSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_DataSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(37, 118, 24, 23, 239, 173, 163, 127, 104, 159, 172, 143, 54, 229));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_DataSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::DataSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"extraFlags",1},{"octetsToInlineQos",2},{"readerId",3},{"writerId",4},{"writerSN",5},{"inlineQos",6},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint16(value.extraFlags)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint16(value.octetsToInlineQos)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.readerId)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.writerId)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.writerSN)) return false;
      break;
    }
    case 6: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.inlineQos);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.inlineQos[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::DataSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("extraFlags");
  value_writer.write_uint16(value.extraFlags);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("octetsToInlineQos");
  value_writer.write_uint16(value.octetsToInlineQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerId");
  vwrite(value_writer, value.readerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerId");
  vwrite(value_writer, value.writerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerSN");
  vwrite(value_writer, value.writerSN);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("inlineQos");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.inlineQos.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.inlineQos[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  stru.extraFlags = 0;
  stru.octetsToInlineQos = 0;
  set_default(stru.readerId);
  set_default(stru.writerId);
  set_default(stru.writerSN);
  stru.inlineQos.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  primitive_serialized_size(encoding, size, stru.extraFlags);
  primitive_serialized_size(encoding, size, stru.octetsToInlineQos);
  serialized_size(encoding, size, stru.readerId);
  serialized_size(encoding, size, stru.writerId);
  serialized_size(encoding, size, stru.writerSN);
  if (stru.smHeader.flags & 2) {
    serialized_size(encoding, size, stru.inlineQos);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.extraFlags)
    && (strm << stru.octetsToInlineQos)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (!(stru.smHeader.flags & 2) || (strm << stru.inlineQos));
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.extraFlags)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.octetsToInlineQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!strm.skip(stru.octetsToInlineQos - 16)) {
    return false;
  }
  if ((stru.smHeader.flags & 2) && !(strm >> stru.inlineQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::DataSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  primitive_serialized_size(encoding, size, stru.value.extraFlags);
  primitive_serialized_size(encoding, size, stru.value.octetsToInlineQos);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId));
  serialized_size(encoding, size, stru.value.writerSN);
  serialized_size(encoding, size, stru.value.inlineQos);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::DataSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << stru.value.extraFlags)
    && (strm << stru.value.octetsToInlineQos)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId))
    && (strm << stru.value.writerSN)
    && (strm << stru.value.inlineQos);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::DataSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_readerId_nested_key_only(stru.value.readerId);
  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_writerId_nested_key_only(stru.value.writerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.extraFlags)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.octetsToInlineQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.writerSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.inlineQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::DataSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::DataSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("extraFlags", 1),
      std::make_pair("octetsToInlineQos", 2),
      std::make_pair("readerId", 3),
      std::make_pair("writerId", 4),
      std::make_pair("writerSN", 5),
      std::make_pair("inlineQos", 6),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 7);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::DataSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::DataSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return typed.extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return typed.octetsToInlineQos;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "extraFlags") {
      ACE_CDR::UShort val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'extraFlags' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'extraFlags' could not be skipped");
      }
    }
    if (base_field == "octetsToInlineQos") {
      ACE_CDR::UShort val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be skipped");
      }
    }
    if (base_field == "readerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (base_field == "writerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (base_field == "writerSN") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'writerSN' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::ParameterList*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return make_field_cmp(&T::extraFlags, next);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return make_field_cmp(&T::octetsToInlineQos, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "extraFlags", "octetsToInlineQos", "readerId", "writerId", "writerSN", "inlineQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return &static_cast<const T*>(stru)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return &static_cast<const T*>(stru)->octetsToInlineQos;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      return &static_cast<const T*>(stru)->inlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      static_cast<T*>(lhs)->extraFlags = *static_cast<const  ::CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      static_cast<T*>(lhs)->octetsToInlineQos = *static_cast<const  ::CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      static_cast<T*>(lhs)->inlineQos = *static_cast<const  ::OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "extraFlags") == 0) {
      return static_cast<const T*>(lhs)->extraFlags == static_cast<const T*>(rhs)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return static_cast<const T*>(lhs)->octetsToInlineQos == static_cast<const T*>(rhs)->octetsToInlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::DataSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::DataSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::DataSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::DataSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataSubmessage */


/* Begin STRUCT: DataFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_DataFragSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(145, 105, 114, 192, 4, 141, 200, 90, 70, 173, 35, 248, 103, 55));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_DataFragSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::DataFragSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"extraFlags",1},{"octetsToInlineQos",2},{"readerId",3},{"writerId",4},{"writerSN",5},{"fragmentStartingNum",6},{"fragmentsInSubmessage",7},{"fragmentSize",8},{"sampleSize",9},{"inlineQos",10},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint16(value.extraFlags)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint16(value.octetsToInlineQos)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.readerId)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.writerId)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.writerSN)) return false;
      break;
    }
    case 6: {
      if (!vread(value_reader, value.fragmentStartingNum)) return false;
      break;
    }
    case 7: {
      if (!value_reader.read_uint16(value.fragmentsInSubmessage)) return false;
      break;
    }
    case 8: {
      if (!value_reader.read_uint16(value.fragmentSize)) return false;
      break;
    }
    case 9: {
      if (!value_reader.read_uint32(value.sampleSize)) return false;
      break;
    }
    case 10: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.inlineQos);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.inlineQos[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::DataFragSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("extraFlags");
  value_writer.write_uint16(value.extraFlags);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("octetsToInlineQos");
  value_writer.write_uint16(value.octetsToInlineQos);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerId");
  vwrite(value_writer, value.readerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerId");
  vwrite(value_writer, value.writerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerSN");
  vwrite(value_writer, value.writerSN);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("fragmentStartingNum");
  vwrite(value_writer, value.fragmentStartingNum);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("fragmentsInSubmessage");
  value_writer.write_uint16(value.fragmentsInSubmessage);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("fragmentSize");
  value_writer.write_uint16(value.fragmentSize);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("sampleSize");
  value_writer.write_uint32(value.sampleSize);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("inlineQos");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.inlineQos.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.inlineQos[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  stru.extraFlags = 0;
  stru.octetsToInlineQos = 0;
  set_default(stru.readerId);
  set_default(stru.writerId);
  set_default(stru.writerSN);
  set_default(stru.fragmentStartingNum);
  stru.fragmentsInSubmessage = 0;
  stru.fragmentSize = 0;
  stru.sampleSize = 0;
  stru.inlineQos.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  primitive_serialized_size(encoding, size, stru.extraFlags);
  primitive_serialized_size(encoding, size, stru.octetsToInlineQos);
  serialized_size(encoding, size, stru.readerId);
  serialized_size(encoding, size, stru.writerId);
  serialized_size(encoding, size, stru.writerSN);
  serialized_size(encoding, size, stru.fragmentStartingNum);
  primitive_serialized_size(encoding, size, stru.fragmentsInSubmessage);
  primitive_serialized_size(encoding, size, stru.fragmentSize);
  primitive_serialized_size(encoding, size, stru.sampleSize);
  if (stru.smHeader.flags & 2) {
    serialized_size(encoding, size, stru.inlineQos);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.extraFlags)
    && (strm << stru.octetsToInlineQos)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.fragmentStartingNum)
    && (strm << stru.fragmentsInSubmessage)
    && (strm << stru.fragmentSize)
    && (strm << stru.sampleSize)
    && (!(stru.smHeader.flags & 2) || (strm << stru.inlineQos));
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.extraFlags)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.octetsToInlineQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.fragmentStartingNum)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.fragmentsInSubmessage)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.fragmentSize)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.sampleSize)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!strm.skip(stru.octetsToInlineQos - 28)) {
    return false;
  }
  if ((stru.smHeader.flags & 2) && !(strm >> stru.inlineQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::DataFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  primitive_serialized_size(encoding, size, stru.value.extraFlags);
  primitive_serialized_size(encoding, size, stru.value.octetsToInlineQos);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId));
  serialized_size(encoding, size, stru.value.writerSN);
  serialized_size(encoding, size, stru.value.fragmentStartingNum);
  primitive_serialized_size(encoding, size, stru.value.fragmentsInSubmessage);
  primitive_serialized_size(encoding, size, stru.value.fragmentSize);
  primitive_serialized_size(encoding, size, stru.value.sampleSize);
  serialized_size(encoding, size, stru.value.inlineQos);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::DataFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << stru.value.extraFlags)
    && (strm << stru.value.octetsToInlineQos)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId))
    && (strm << stru.value.writerSN)
    && (strm << stru.value.fragmentStartingNum)
    && (strm << stru.value.fragmentsInSubmessage)
    && (strm << stru.value.fragmentSize)
    && (strm << stru.value.sampleSize)
    && (strm << stru.value.inlineQos);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::DataFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_readerId_nested_key_only(stru.value.readerId);
  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_writerId_nested_key_only(stru.value.writerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.extraFlags)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.octetsToInlineQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.writerSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.fragmentStartingNum)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.fragmentsInSubmessage)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.fragmentSize)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.sampleSize)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.inlineQos)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::DataFragSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::DataFragSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("extraFlags", 1),
      std::make_pair("octetsToInlineQos", 2),
      std::make_pair("readerId", 3),
      std::make_pair("writerId", 4),
      std::make_pair("writerSN", 5),
      std::make_pair("fragmentStartingNum", 6),
      std::make_pair("fragmentsInSubmessage", 7),
      std::make_pair("fragmentSize", 8),
      std::make_pair("sampleSize", 9),
      std::make_pair("inlineQos", 10),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 11);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataFragSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::DataFragSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::DataFragSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return typed.extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return typed.octetsToInlineQos;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.fragmentStartingNum, field + 20);
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return typed.fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return typed.fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return typed.sampleSize;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataFragSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "extraFlags") {
      ACE_CDR::UShort val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'extraFlags' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'extraFlags' could not be skipped");
      }
    }
    if (base_field == "octetsToInlineQos") {
      ACE_CDR::UShort val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be skipped");
      }
    }
    if (base_field == "readerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (base_field == "writerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (base_field == "writerSN") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'writerSN' could not be skipped");
      }
    }
    if (base_field == "fragmentStartingNum") {
      return getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::FragmentNumber_t*>(0))) {
        throw std::runtime_error("Field 'fragmentStartingNum' could not be skipped");
      }
    }
    if (base_field == "fragmentsInSubmessage") {
      ACE_CDR::UShort val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'fragmentsInSubmessage' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'fragmentsInSubmessage' could not be skipped");
      }
    }
    if (base_field == "fragmentSize") {
      ACE_CDR::UShort val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'fragmentSize' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'fragmentSize' could not be skipped");
      }
    }
    if (base_field == "sampleSize") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sampleSize' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sampleSize' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::ParameterList*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return make_field_cmp(&T::extraFlags, next);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return make_field_cmp(&T::octetsToInlineQos, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return make_struct_cmp(&T::fragmentStartingNum, getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 20), next);
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return make_field_cmp(&T::fragmentsInSubmessage, next);
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return make_field_cmp(&T::fragmentSize, next);
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return make_field_cmp(&T::sampleSize, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataFragSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "extraFlags", "octetsToInlineQos", "readerId", "writerId", "writerSN", "fragmentStartingNum", "fragmentsInSubmessage", "fragmentSize", "sampleSize", "inlineQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return &static_cast<const T*>(stru)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return &static_cast<const T*>(stru)->octetsToInlineQos;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "fragmentStartingNum") == 0) {
      return &static_cast<const T*>(stru)->fragmentStartingNum;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return &static_cast<const T*>(stru)->fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return &static_cast<const T*>(stru)->fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return &static_cast<const T*>(stru)->sampleSize;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      return &static_cast<const T*>(stru)->inlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      static_cast<T*>(lhs)->extraFlags = *static_cast<const  ::CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      static_cast<T*>(lhs)->octetsToInlineQos = *static_cast<const  ::CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentStartingNum") == 0) {
      static_cast<T*>(lhs)->fragmentStartingNum = *static_cast<const  ::OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      static_cast<T*>(lhs)->fragmentsInSubmessage = *static_cast<const  ::CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      static_cast<T*>(lhs)->fragmentSize = *static_cast<const  ::CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      static_cast<T*>(lhs)->sampleSize = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      static_cast<T*>(lhs)->inlineQos = *static_cast<const  ::OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataFragSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "extraFlags") == 0) {
      return static_cast<const T*>(lhs)->extraFlags == static_cast<const T*>(rhs)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return static_cast<const T*>(lhs)->octetsToInlineQos == static_cast<const T*>(rhs)->octetsToInlineQos;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return static_cast<const T*>(lhs)->fragmentsInSubmessage == static_cast<const T*>(rhs)->fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return static_cast<const T*>(lhs)->fragmentSize == static_cast<const T*>(rhs)->fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return static_cast<const T*>(lhs)->sampleSize == static_cast<const T*>(rhs)->sampleSize;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DataFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::DataFragSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::DataFragSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::DataFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::DataFragSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataFragSubmessage */


/* Begin STRUCT: HeartBeatSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_HeartBeatSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 216, 152, 127, 197, 0, 10, 17, 138, 213, 145, 90, 204, 148));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_HeartBeatSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::HeartBeatSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"readerId",1},{"writerId",2},{"firstSN",3},{"lastSN",4},{"count",5},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.readerId)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.writerId)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.firstSN)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.lastSN)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.count)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::HeartBeatSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerId");
  vwrite(value_writer, value.readerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerId");
  vwrite(value_writer, value.writerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("firstSN");
  vwrite(value_writer, value.firstSN);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("lastSN");
  vwrite(value_writer, value.lastSN);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("count");
  vwrite(value_writer, value.count);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  set_default(stru.readerId);
  set_default(stru.writerId);
  set_default(stru.firstSN);
  set_default(stru.lastSN);
  set_default(stru.count);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  serialized_size(encoding, size, stru.readerId);
  serialized_size(encoding, size, stru.writerId);
  serialized_size(encoding, size, stru.firstSN);
  serialized_size(encoding, size, stru.lastSN);
  serialized_size(encoding, size, stru.count);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.firstSN)
    && (strm << stru.lastSN)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.firstSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.lastSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::HeartBeatSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId));
  serialized_size(encoding, size, stru.value.firstSN);
  serialized_size(encoding, size, stru.value.lastSN);
  serialized_size(encoding, size, stru.value.count);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::HeartBeatSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId))
    && (strm << stru.value.firstSN)
    && (strm << stru.value.lastSN)
    && (strm << stru.value.count);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::HeartBeatSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_readerId_nested_key_only(stru.value.readerId);
  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_writerId_nested_key_only(stru.value.writerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.firstSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.lastSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::HeartBeatSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::HeartBeatSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("readerId", 1),
      std::make_pair("writerId", 2),
      std::make_pair("firstSN", 3),
      std::make_pair("lastSN", 4),
      std::make_pair("count", 5),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 6);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::HeartBeatSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::HeartBeatSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.firstSN, field + 8);
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.lastSN, field + 7);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "readerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (base_field == "writerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (base_field == "firstSN") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'firstSN' could not be skipped");
      }
    }
    if (base_field == "lastSN") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'lastSN' could not be skipped");
      }
    }
    if (base_field == "count") {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return make_struct_cmp(&T::firstSN, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return make_struct_cmp(&T::lastSN, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct< ::OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "firstSN", "lastSN", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "firstSN") == 0) {
      return &static_cast<const T*>(stru)->firstSN;
    }
    if (std::strcmp(field, "lastSN") == 0) {
      return &static_cast<const T*>(stru)->lastSN;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "firstSN") == 0) {
      static_cast<T*>(lhs)->firstSN = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lastSN") == 0) {
      static_cast<T*>(lhs)->lastSN = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const  ::OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::HeartBeatSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::HeartBeatSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::HeartBeatSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::HeartBeatSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HeartBeatSubmessage */


/* Begin STRUCT: HeartBeatFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_HeartBeatFragSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(26, 90, 222, 159, 124, 27, 74, 53, 0, 110, 7, 177, 194, 34));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_HeartBeatFragSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::HeartBeatFragSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"readerId",1},{"writerId",2},{"writerSN",3},{"lastFragmentNum",4},{"count",5},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.readerId)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.writerId)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.writerSN)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.lastFragmentNum)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.count)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::HeartBeatFragSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readerId");
  vwrite(value_writer, value.readerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerId");
  vwrite(value_writer, value.writerId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writerSN");
  vwrite(value_writer, value.writerSN);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("lastFragmentNum");
  vwrite(value_writer, value.lastFragmentNum);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("count");
  vwrite(value_writer, value.count);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  set_default(stru.readerId);
  set_default(stru.writerId);
  set_default(stru.writerSN);
  set_default(stru.lastFragmentNum);
  set_default(stru.count);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  serialized_size(encoding, size, stru.readerId);
  serialized_size(encoding, size, stru.writerId);
  serialized_size(encoding, size, stru.writerSN);
  serialized_size(encoding, size, stru.lastFragmentNum);
  serialized_size(encoding, size, stru.count);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.lastFragmentNum)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writerSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.lastFragmentNum)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::HeartBeatFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId));
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId));
  serialized_size(encoding, size, stru.value.writerSN);
  serialized_size(encoding, size, stru.value.lastFragmentNum);
  serialized_size(encoding, size, stru.value.count);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::HeartBeatFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.readerId))
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::EntityId_t>(stru.value.writerId))
    && (strm << stru.value.writerSN)
    && (strm << stru.value.lastFragmentNum)
    && (strm << stru.value.count);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::HeartBeatFragSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_readerId_nested_key_only(stru.value.readerId);
  NestedKeyOnly< ::OpenDDS::DCPS::EntityId_t> stru_value_writerId_nested_key_only(stru.value.writerId);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_readerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_writerId_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.writerSN)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.lastFragmentNum)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::HeartBeatFragSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::HeartBeatFragSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("readerId", 1),
      std::make_pair("writerId", 2),
      std::make_pair("writerSN", 3),
      std::make_pair("lastFragmentNum", 4),
      std::make_pair("count", 5),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 6);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatFragSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::HeartBeatFragSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::HeartBeatFragSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.lastFragmentNum, field + 16);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "readerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (base_field == "writerId") {
      return getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (base_field == "writerSN") {
      return getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'writerSN' could not be skipped");
      }
    }
    if (base_field == "lastFragmentNum") {
      return getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::FragmentNumber_t*>(0))) {
        throw std::runtime_error("Field 'lastFragmentNum' could not be skipped");
      }
    }
    if (base_field == "count") {
      return getMetaStruct< ::OpenDDS::RTPS::Count_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct< ::OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct< ::OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return make_struct_cmp(&T::lastFragmentNum, getMetaStruct< ::OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct< ::OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "writerSN", "lastFragmentNum", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "lastFragmentNum") == 0) {
      return &static_cast<const T*>(stru)->lastFragmentNum;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const  ::OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const  ::OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lastFragmentNum") == 0) {
      static_cast<T*>(lhs)->lastFragmentNum = *static_cast<const  ::OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const  ::OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::HeartBeatFragSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::HeartBeatFragSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::HeartBeatFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::HeartBeatFragSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HeartBeatFragSubmessage */


/* Begin STRUCT: InfoDestinationSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_InfoDestinationSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(220, 252, 235, 15, 216, 123, 170, 85, 138, 235, 133, 193, 175, 9));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_InfoDestinationSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::InfoDestinationSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"guidPrefix",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.guidPrefix, 12)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::InfoDestinationSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("guidPrefix");
  value_writer.begin_array();
  value_writer.write_byte_array (value.guidPrefix, 12);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_temp(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  set_default(stru_guidPrefix_temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  serialized_size(encoding, size, stru.smHeader);
  serialized_size(encoding, size, stru_guidPrefix_forany);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.smHeader)
    && (strm << stru_guidPrefix_forany);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_guidPrefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoDestinationSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, stru_value_guidPrefix_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoDestinationSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  return (strm << stru.value.smHeader)
    && (strm << stru_value_guidPrefix_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::InfoDestinationSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guidPrefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::InfoDestinationSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::InfoDestinationSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("guidPrefix", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoDestinationSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::InfoDestinationSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::InfoDestinationSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
       ::OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const  ::OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const  ::OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoDestinationSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoDestinationSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::InfoDestinationSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::InfoDestinationSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::InfoDestinationSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::InfoDestinationSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoDestinationSubmessage */


/* Begin STRUCT: InfoSourceSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_InfoSourceSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(241, 215, 115, 29, 74, 144, 179, 155, 104, 243, 189, 42, 144, 110));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_InfoSourceSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::InfoSourceSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"unused",1},{"version",2},{"vendorId",3},{"guidPrefix",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.unused)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.version)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.vendorId)) return false;
      break;
    }
    case 4: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.guidPrefix, 12)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::InfoSourceSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("unused");
  value_writer.write_int32(value.unused);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("version");
  vwrite(value_writer, value.version);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("vendorId");
  vwrite(value_writer, value.vendorId);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("guidPrefix");
  value_writer.begin_array();
  value_writer.write_byte_array (value.guidPrefix, 12);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  stru.unused = 0;
  set_default(stru.version);
  set_default(stru.vendorId);
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_temp(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  set_default(stru_guidPrefix_temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  serialized_size(encoding, size, stru.smHeader);
  primitive_serialized_size(encoding, size, stru.unused);
  serialized_size(encoding, size, stru.version);
  serialized_size(encoding, size, stru.vendorId);
  serialized_size(encoding, size, stru_guidPrefix_forany);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.smHeader)
    && (strm << stru.unused)
    && (strm << stru.version)
    && (strm << stru.vendorId)
    && (strm << stru_guidPrefix_forany);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.unused)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.version)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.vendorId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_guidPrefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoSourceSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  serialized_size(encoding, size, stru.value.smHeader);
  primitive_serialized_size(encoding, size, stru.value.unused);
  serialized_size(encoding, size, stru.value.version);
  serialized_size(encoding, size, stru.value.vendorId);
  serialized_size(encoding, size, stru_value_guidPrefix_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoSourceSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  return (strm << stru.value.smHeader)
    && (strm << stru.value.unused)
    && (strm << stru.value.version)
    && (strm << stru.value.vendorId)
    && (strm << stru_value_guidPrefix_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::InfoSourceSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::OpenDDS::DCPS::GuidPrefix_t_forany stru_value_guidPrefix_forany(const_cast< ::OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.value.guidPrefix));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.unused)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.version)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.vendorId)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guidPrefix_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::InfoSourceSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::InfoSourceSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("unused", 1),
      std::make_pair("version", 2),
      std::make_pair("vendorId", 3),
      std::make_pair("guidPrefix", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoSourceSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::InfoSourceSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::InfoSourceSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "unused") == 0) {
      return typed.unused;
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.version, field + 8);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "unused") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'unused' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'unused' could not be skipped");
      }
    }
    if (base_field == "version") {
      return getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::ProtocolVersion_t*>(0))) {
        throw std::runtime_error("Field 'version' could not be skipped");
      }
    }
    if (base_field == "vendorId") {
      return getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::VendorId_t*>(0))) {
        throw std::runtime_error("Field 'vendorId' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "unused") == 0) {
      return make_field_cmp(&T::unused, next);
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return make_struct_cmp(&T::version, getMetaStruct< ::OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct< ::OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoSourceSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unused", "version", "vendorId", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unused") == 0) {
      return &static_cast<const T*>(stru)->unused;
    }
    if (std::strcmp(field, "version") == 0) {
      return &static_cast<const T*>(stru)->version;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unused") == 0) {
      static_cast<T*>(lhs)->unused = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "version") == 0) {
      static_cast<T*>(lhs)->version = *static_cast<const  ::OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const  ::OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
       ::OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const  ::OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const  ::OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoSourceSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "unused") == 0) {
      return static_cast<const T*>(lhs)->unused == static_cast<const T*>(rhs)->unused;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoSourceSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::InfoSourceSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::InfoSourceSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::InfoSourceSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::InfoSourceSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoSourceSubmessage */


/* Begin STRUCT: InfoTimestampSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_InfoTimestampSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(89, 229, 192, 159, 193, 43, 151, 40, 114, 54, 88, 1, 0, 21));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_InfoTimestampSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::InfoTimestampSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"timestamp",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.timestamp)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::InfoTimestampSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("timestamp");
  vwrite(value_writer, value.timestamp);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  set_default(stru.timestamp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  if (!(stru.smHeader.flags & 2)) {
    serialized_size(encoding, size, stru.timestamp);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (!(!(stru.smHeader.flags & 2)) || (strm << stru.timestamp));
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if ((!(stru.smHeader.flags & 2)) && !(strm >> stru.timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoTimestampSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, stru.value.timestamp);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoTimestampSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << stru.value.timestamp);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::InfoTimestampSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::InfoTimestampSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::InfoTimestampSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("timestamp", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoTimestampSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::InfoTimestampSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::InfoTimestampSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::Timestamp_t>().getValue(&typed.timestamp, field + 10);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "timestamp") {
      return getMetaStruct< ::OpenDDS::RTPS::Time_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::Time_t*>(0))) {
        throw std::runtime_error("Field 'timestamp' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return make_struct_cmp(&T::timestamp, getMetaStruct< ::OpenDDS::RTPS::Timestamp_t>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "timestamp", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "timestamp") == 0) {
      return &static_cast<const T*>(stru)->timestamp;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "timestamp") == 0) {
      static_cast<T*>(lhs)->timestamp = *static_cast<const  ::OpenDDS::RTPS::Timestamp_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoTimestampSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoTimestampSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::InfoTimestampSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::InfoTimestampSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::InfoTimestampSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::InfoTimestampSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoTimestampSubmessage */


/* Begin STRUCT: PadSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_PadSubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(111, 0, 172, 23, 200, 153, 190, 187, 205, 142, 149, 204, 41, 21));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_PadSubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::PadSubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::PadSubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::PadSubmessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::PadSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::PadSubmessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::PadSubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::PadSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::PadSubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::PadSubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::PadSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::PadSubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::PadSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::PadSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::PadSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::PadSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::PadSubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::PadSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::PadSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::PadSubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PadSubmessage */


/* Begin STRUCT: InfoReplyIp4Submessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_InfoReplyIp4Submessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(228, 22, 64, 100, 44, 121, 150, 142, 57, 135, 196, 14, 115, 14));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_InfoReplyIp4Submessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::InfoReplyIp4Submessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"unicastLocator",1},{"multicastLocator",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.unicastLocator)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.multicastLocator)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::InfoReplyIp4Submessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("unicastLocator");
  vwrite(value_writer, value.unicastLocator);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("multicastLocator");
  vwrite(value_writer, value.multicastLocator);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  set_default(stru.unicastLocator);
  set_default(stru.multicastLocator);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.smHeader);
  serialized_size(encoding, size, stru.unicastLocator);
  if (stru.smHeader.flags & 2) {
    serialized_size(encoding, size, stru.multicastLocator);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.smHeader)
    && (strm << stru.unicastLocator)
    && (!(stru.smHeader.flags & 2) || (strm << stru.multicastLocator));
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.unicastLocator)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if ((stru.smHeader.flags & 2) && !(strm >> stru.multicastLocator)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoReplyIp4Submessage>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.smHeader);
  serialized_size(encoding, size, stru.value.unicastLocator);
  serialized_size(encoding, size, stru.value.multicastLocator);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::InfoReplyIp4Submessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.smHeader)
    && (strm << stru.value.unicastLocator)
    && (strm << stru.value.multicastLocator);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::InfoReplyIp4Submessage>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.smHeader)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.unicastLocator)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.multicastLocator)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::InfoReplyIp4Submessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::InfoReplyIp4Submessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("unicastLocator", 1),
      std::make_pair("multicastLocator", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplyIp4Submessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::InfoReplyIp4Submessage& typed = *static_cast<const  ::OpenDDS::RTPS::InfoReplyIp4Submessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::LocatorUDPv4_t>().getValue(&typed.unicastLocator, field + 15);
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::LocatorUDPv4_t>().getValue(&typed.multicastLocator, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (base_field == "unicastLocator") {
      return getMetaStruct< ::OpenDDS::RTPS::LocatorUDPv4_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::LocatorUDPv4_t*>(0))) {
        throw std::runtime_error("Field 'unicastLocator' could not be skipped");
      }
    }
    if (base_field == "multicastLocator") {
      return getMetaStruct< ::OpenDDS::RTPS::LocatorUDPv4_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::LocatorUDPv4_t*>(0))) {
        throw std::runtime_error("Field 'multicastLocator' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return make_struct_cmp(&T::unicastLocator, getMetaStruct< ::OpenDDS::RTPS::LocatorUDPv4_t>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return make_struct_cmp(&T::multicastLocator, getMetaStruct< ::OpenDDS::RTPS::LocatorUDPv4_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unicastLocator", "multicastLocator", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unicastLocator") == 0) {
      return &static_cast<const T*>(stru)->unicastLocator;
    }
    if (std::strcmp(field, "multicastLocator") == 0) {
      return &static_cast<const T*>(stru)->multicastLocator;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocator") == 0) {
      static_cast<T*>(lhs)->unicastLocator = *static_cast<const  ::OpenDDS::RTPS::LocatorUDPv4_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocator") == 0) {
      static_cast<T*>(lhs)->multicastLocator = *static_cast<const  ::OpenDDS::RTPS::LocatorUDPv4_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::InfoReplyIp4Submessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::InfoReplyIp4Submessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::InfoReplyIp4Submessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::InfoReplyIp4Submessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoReplyIp4Submessage */


/* Begin STRUCT: SecuritySubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_SecuritySubmessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 18, 77, 133, 10, 184, 210, 12, 27, 14, 223, 163, 116, 74));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_SecuritySubmessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::SecuritySubmessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"smHeader",0},{"content",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.smHeader)) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.content);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.content[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::SecuritySubmessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("smHeader");
  vwrite(value_writer, value.smHeader);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("content");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.content.get_buffer(), value.content.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::SecuritySubmessage& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.smHeader);
  stru.content.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::SecuritySubmessage& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  serialized_size(encoding, size, stru.smHeader);
  primitive_serialized_size_octet(encoding, size, stru.content.length());
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::SecuritySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && strm.write_octet_array(stru.content.get_buffer(), stru.content.length());
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::SecuritySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if (strm >> stru.smHeader) {
    stru.content.length(stru.smHeader.submessageLength);
    if (strm.read_octet_array(stru.content.get_buffer(),
                              stru.smHeader.submessageLength)) {
      return true;
    }
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::SecuritySubmessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::SecuritySubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("smHeader", 0),
      std::make_pair("content", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SecuritySubmessage)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::SecuritySubmessage& typed = *static_cast<const  ::OpenDDS::RTPS::SecuritySubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SecuritySubmessage)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "smHeader") {
      return getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct< ::OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SecuritySubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "content", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "content") == 0) {
      return &static_cast<const T*>(stru)->content;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SecuritySubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const  ::OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "content") == 0) {
      static_cast<T*>(lhs)->content = *static_cast<const  ::DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SecuritySubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::SecuritySubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::SecuritySubmessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::SecuritySubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::SecuritySubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::SecuritySubmessage>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SecuritySubmessage */


/* Begin ENUM: SubmessageKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_SubmessageKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(147, 176, 57, 236, 194, 129, 36, 216, 44, 165, 133, 49, 248, 141));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_SubmessageKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::SubmessageKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"SUBMESSAGE_NONE",0},{"PAD",1},{"RESERVED_2",2},{"RESERVED_3",3},{"RESERVED_4",4},{"RESERVED_5",5},{"ACKNACK",6},{"HEARTBEAT",7},{"GAP",8},{"INFO_TS",9},{"RESERVED_10",10},{"RESERVED_11",11},{"INFO_SRC",12},{"INFO_REPLY_IP4",13},{"INFO_DST",14},{"INFO_REPLY",15},{"RESERVED_16",16},{"RESERVED_17",17},{"NACK_FRAG",18},{"HEARTBEAT_FRAG",19},{"RESERVED_20",20},{"DATA",21},{"DATA_FRAG",22},{"RESERVED_23",23},{"RESERVED_24",24},{"RESERVED_25",25},{"RESERVED_26",26},{"RESERVED_27",27},{"RESERVED_28",28},{"RESERVED_29",29},{"RESERVED_30",30},{"RESERVED_31",31},{"RESERVED_32",32},{"RESERVED_33",33},{"RESERVED_34",34},{"RESERVED_35",35},{"RESERVED_36",36},{"RESERVED_37",37},{"RESERVED_38",38},{"RESERVED_39",39},{"RESERVED_40",40},{"RESERVED_41",41},{"RESERVED_42",42},{"RESERVED_43",43},{"RESERVED_44",44},{"RESERVED_45",45},{"RESERVED_46",46},{"RESERVED_47",47},{"SEC_BODY",48},{"SEC_PREFIX",49},{"SEC_POSTFIX",50},{"SRTPS_PREFIX",51},{"SRTPS_POSTFIX",52},{"RESERVED_53_SECURITY",53},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::SubmessageKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case OpenDDS::RTPS::SUBMESSAGE_NONE:
    value_writer.write_enum("SUBMESSAGE_NONE", OpenDDS::RTPS::SUBMESSAGE_NONE);
    break;
  case OpenDDS::RTPS::PAD:
    value_writer.write_enum("PAD", OpenDDS::RTPS::PAD);
    break;
  case OpenDDS::RTPS::RESERVED_2:
    value_writer.write_enum("RESERVED_2", OpenDDS::RTPS::RESERVED_2);
    break;
  case OpenDDS::RTPS::RESERVED_3:
    value_writer.write_enum("RESERVED_3", OpenDDS::RTPS::RESERVED_3);
    break;
  case OpenDDS::RTPS::RESERVED_4:
    value_writer.write_enum("RESERVED_4", OpenDDS::RTPS::RESERVED_4);
    break;
  case OpenDDS::RTPS::RESERVED_5:
    value_writer.write_enum("RESERVED_5", OpenDDS::RTPS::RESERVED_5);
    break;
  case OpenDDS::RTPS::ACKNACK:
    value_writer.write_enum("ACKNACK", OpenDDS::RTPS::ACKNACK);
    break;
  case OpenDDS::RTPS::HEARTBEAT:
    value_writer.write_enum("HEARTBEAT", OpenDDS::RTPS::HEARTBEAT);
    break;
  case OpenDDS::RTPS::GAP:
    value_writer.write_enum("GAP", OpenDDS::RTPS::GAP);
    break;
  case OpenDDS::RTPS::INFO_TS:
    value_writer.write_enum("INFO_TS", OpenDDS::RTPS::INFO_TS);
    break;
  case OpenDDS::RTPS::RESERVED_10:
    value_writer.write_enum("RESERVED_10", OpenDDS::RTPS::RESERVED_10);
    break;
  case OpenDDS::RTPS::RESERVED_11:
    value_writer.write_enum("RESERVED_11", OpenDDS::RTPS::RESERVED_11);
    break;
  case OpenDDS::RTPS::INFO_SRC:
    value_writer.write_enum("INFO_SRC", OpenDDS::RTPS::INFO_SRC);
    break;
  case OpenDDS::RTPS::INFO_REPLY_IP4:
    value_writer.write_enum("INFO_REPLY_IP4", OpenDDS::RTPS::INFO_REPLY_IP4);
    break;
  case OpenDDS::RTPS::INFO_DST:
    value_writer.write_enum("INFO_DST", OpenDDS::RTPS::INFO_DST);
    break;
  case OpenDDS::RTPS::INFO_REPLY:
    value_writer.write_enum("INFO_REPLY", OpenDDS::RTPS::INFO_REPLY);
    break;
  case OpenDDS::RTPS::RESERVED_16:
    value_writer.write_enum("RESERVED_16", OpenDDS::RTPS::RESERVED_16);
    break;
  case OpenDDS::RTPS::RESERVED_17:
    value_writer.write_enum("RESERVED_17", OpenDDS::RTPS::RESERVED_17);
    break;
  case OpenDDS::RTPS::NACK_FRAG:
    value_writer.write_enum("NACK_FRAG", OpenDDS::RTPS::NACK_FRAG);
    break;
  case OpenDDS::RTPS::HEARTBEAT_FRAG:
    value_writer.write_enum("HEARTBEAT_FRAG", OpenDDS::RTPS::HEARTBEAT_FRAG);
    break;
  case OpenDDS::RTPS::RESERVED_20:
    value_writer.write_enum("RESERVED_20", OpenDDS::RTPS::RESERVED_20);
    break;
  case OpenDDS::RTPS::DATA:
    value_writer.write_enum("DATA", OpenDDS::RTPS::DATA);
    break;
  case OpenDDS::RTPS::DATA_FRAG:
    value_writer.write_enum("DATA_FRAG", OpenDDS::RTPS::DATA_FRAG);
    break;
  case OpenDDS::RTPS::RESERVED_23:
    value_writer.write_enum("RESERVED_23", OpenDDS::RTPS::RESERVED_23);
    break;
  case OpenDDS::RTPS::RESERVED_24:
    value_writer.write_enum("RESERVED_24", OpenDDS::RTPS::RESERVED_24);
    break;
  case OpenDDS::RTPS::RESERVED_25:
    value_writer.write_enum("RESERVED_25", OpenDDS::RTPS::RESERVED_25);
    break;
  case OpenDDS::RTPS::RESERVED_26:
    value_writer.write_enum("RESERVED_26", OpenDDS::RTPS::RESERVED_26);
    break;
  case OpenDDS::RTPS::RESERVED_27:
    value_writer.write_enum("RESERVED_27", OpenDDS::RTPS::RESERVED_27);
    break;
  case OpenDDS::RTPS::RESERVED_28:
    value_writer.write_enum("RESERVED_28", OpenDDS::RTPS::RESERVED_28);
    break;
  case OpenDDS::RTPS::RESERVED_29:
    value_writer.write_enum("RESERVED_29", OpenDDS::RTPS::RESERVED_29);
    break;
  case OpenDDS::RTPS::RESERVED_30:
    value_writer.write_enum("RESERVED_30", OpenDDS::RTPS::RESERVED_30);
    break;
  case OpenDDS::RTPS::RESERVED_31:
    value_writer.write_enum("RESERVED_31", OpenDDS::RTPS::RESERVED_31);
    break;
  case OpenDDS::RTPS::RESERVED_32:
    value_writer.write_enum("RESERVED_32", OpenDDS::RTPS::RESERVED_32);
    break;
  case OpenDDS::RTPS::RESERVED_33:
    value_writer.write_enum("RESERVED_33", OpenDDS::RTPS::RESERVED_33);
    break;
  case OpenDDS::RTPS::RESERVED_34:
    value_writer.write_enum("RESERVED_34", OpenDDS::RTPS::RESERVED_34);
    break;
  case OpenDDS::RTPS::RESERVED_35:
    value_writer.write_enum("RESERVED_35", OpenDDS::RTPS::RESERVED_35);
    break;
  case OpenDDS::RTPS::RESERVED_36:
    value_writer.write_enum("RESERVED_36", OpenDDS::RTPS::RESERVED_36);
    break;
  case OpenDDS::RTPS::RESERVED_37:
    value_writer.write_enum("RESERVED_37", OpenDDS::RTPS::RESERVED_37);
    break;
  case OpenDDS::RTPS::RESERVED_38:
    value_writer.write_enum("RESERVED_38", OpenDDS::RTPS::RESERVED_38);
    break;
  case OpenDDS::RTPS::RESERVED_39:
    value_writer.write_enum("RESERVED_39", OpenDDS::RTPS::RESERVED_39);
    break;
  case OpenDDS::RTPS::RESERVED_40:
    value_writer.write_enum("RESERVED_40", OpenDDS::RTPS::RESERVED_40);
    break;
  case OpenDDS::RTPS::RESERVED_41:
    value_writer.write_enum("RESERVED_41", OpenDDS::RTPS::RESERVED_41);
    break;
  case OpenDDS::RTPS::RESERVED_42:
    value_writer.write_enum("RESERVED_42", OpenDDS::RTPS::RESERVED_42);
    break;
  case OpenDDS::RTPS::RESERVED_43:
    value_writer.write_enum("RESERVED_43", OpenDDS::RTPS::RESERVED_43);
    break;
  case OpenDDS::RTPS::RESERVED_44:
    value_writer.write_enum("RESERVED_44", OpenDDS::RTPS::RESERVED_44);
    break;
  case OpenDDS::RTPS::RESERVED_45:
    value_writer.write_enum("RESERVED_45", OpenDDS::RTPS::RESERVED_45);
    break;
  case OpenDDS::RTPS::RESERVED_46:
    value_writer.write_enum("RESERVED_46", OpenDDS::RTPS::RESERVED_46);
    break;
  case OpenDDS::RTPS::RESERVED_47:
    value_writer.write_enum("RESERVED_47", OpenDDS::RTPS::RESERVED_47);
    break;
  case OpenDDS::RTPS::SEC_BODY:
    value_writer.write_enum("SEC_BODY", OpenDDS::RTPS::SEC_BODY);
    break;
  case OpenDDS::RTPS::SEC_PREFIX:
    value_writer.write_enum("SEC_PREFIX", OpenDDS::RTPS::SEC_PREFIX);
    break;
  case OpenDDS::RTPS::SEC_POSTFIX:
    value_writer.write_enum("SEC_POSTFIX", OpenDDS::RTPS::SEC_POSTFIX);
    break;
  case OpenDDS::RTPS::SRTPS_PREFIX:
    value_writer.write_enum("SRTPS_PREFIX", OpenDDS::RTPS::SRTPS_PREFIX);
    break;
  case OpenDDS::RTPS::SRTPS_POSTFIX:
    value_writer.write_enum("SRTPS_POSTFIX", OpenDDS::RTPS::SRTPS_POSTFIX);
    break;
  case OpenDDS::RTPS::RESERVED_53_SECURITY:
    value_writer.write_enum("RESERVED_53_SECURITY", OpenDDS::RTPS::RESERVED_53_SECURITY);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::SubmessageKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 54) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::OpenDDS::RTPS::SubmessageKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::SubmessageKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 54) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::OpenDDS::RTPS::SubmessageKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_RTPS_SubmessageKind_names[] = {
  "SUBMESSAGE_NONE",
  "PAD",
  "RESERVED_2",
  "RESERVED_3",
  "RESERVED_4",
  "RESERVED_5",
  "ACKNACK",
  "HEARTBEAT",
  "GAP",
  "INFO_TS",
  "RESERVED_10",
  "RESERVED_11",
  "INFO_SRC",
  "INFO_REPLY_IP4",
  "INFO_DST",
  "INFO_REPLY",
  "RESERVED_16",
  "RESERVED_17",
  "NACK_FRAG",
  "HEARTBEAT_FRAG",
  "RESERVED_20",
  "DATA",
  "DATA_FRAG",
  "RESERVED_23",
  "RESERVED_24",
  "RESERVED_25",
  "RESERVED_26",
  "RESERVED_27",
  "RESERVED_28",
  "RESERVED_29",
  "RESERVED_30",
  "RESERVED_31",
  "RESERVED_32",
  "RESERVED_33",
  "RESERVED_34",
  "RESERVED_35",
  "RESERVED_36",
  "RESERVED_37",
  "RESERVED_38",
  "RESERVED_39",
  "RESERVED_40",
  "RESERVED_41",
  "RESERVED_42",
  "RESERVED_43",
  "RESERVED_44",
  "RESERVED_45",
  "RESERVED_46",
  "RESERVED_47",
  "SEC_BODY",
  "SEC_PREFIX",
  "SEC_POSTFIX",
  "SRTPS_PREFIX",
  "SRTPS_POSTFIX",
  "RESERVED_53_SECURITY"
};
const size_t gen_OpenDDS_RTPS_SubmessageKind_names_size = 54;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: SubmessageKind */


/* Begin UNION: Submessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Submessage_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(102, 170, 145, 4, 80, 244, 15, 54, 224, 255, 110, 254, 204, 151));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Submessage_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::Submessage& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  if (!value_reader.begin_union()) return false;
  if (!value_reader.begin_discriminator()) return false;
  {
     ::OpenDDS::RTPS::SubmessageKind d;
    if (!vread(value_reader, d)) return false;
    value._d(d);
  }
  if (!value_reader.end_discriminator()) return false;
  switch (value._d()) {
  case  ::OpenDDS::RTPS::PAD: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::PadSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.pad_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::ACKNACK: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::AckNackSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.acknack_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::HEARTBEAT: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::HeartBeatSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.heartbeat_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::GAP: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::GapSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.gap_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::INFO_TS: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::InfoTimestampSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.info_ts_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::INFO_SRC: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::InfoSourceSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.info_src_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::INFO_REPLY_IP4: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::InfoReplyIp4Submessage bv;
    if (!vread(value_reader, bv)) return false;
    value.info_reply_ipv4_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::INFO_DST: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::InfoDestinationSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.info_dst_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::INFO_REPLY: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::InfoReplySubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.info_reply_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::NACK_FRAG: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::NackFragSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.nack_frag_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::HEARTBEAT_FRAG: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::HeartBeatFragSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.hb_frag_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::DATA: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::DataSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.data_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::DATA_FRAG: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::DataFragSubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.data_frag_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::RTPS::SEC_BODY:
  case  ::OpenDDS::RTPS::SEC_PREFIX:
  case  ::OpenDDS::RTPS::SEC_POSTFIX:
  case  ::OpenDDS::RTPS::SRTPS_PREFIX:
  case  ::OpenDDS::RTPS::SRTPS_POSTFIX: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::SecuritySubmessage bv;
    if (!vread(value_reader, bv)) return false;
    value.security_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  default: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::RTPS::SubmessageHeader bv;
    if (!vread(value_reader, bv)) return false;
    value.unknown_sm(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  }
  if (!value_reader.end_union()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::Submessage& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_union();
  value_writer.begin_discriminator();
  vwrite(value_writer, value._d());
  value_writer.end_discriminator();
  switch (value._d()) {
  case  ::OpenDDS::RTPS::PAD: {
    value_writer.begin_union_member("pad_sm");
    vwrite(value_writer, value.pad_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::ACKNACK: {
    value_writer.begin_union_member("acknack_sm");
    vwrite(value_writer, value.acknack_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::HEARTBEAT: {
    value_writer.begin_union_member("heartbeat_sm");
    vwrite(value_writer, value.heartbeat_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::GAP: {
    value_writer.begin_union_member("gap_sm");
    vwrite(value_writer, value.gap_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::INFO_TS: {
    value_writer.begin_union_member("info_ts_sm");
    vwrite(value_writer, value.info_ts_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::INFO_SRC: {
    value_writer.begin_union_member("info_src_sm");
    vwrite(value_writer, value.info_src_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::INFO_REPLY_IP4: {
    value_writer.begin_union_member("info_reply_ipv4_sm");
    vwrite(value_writer, value.info_reply_ipv4_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::INFO_DST: {
    value_writer.begin_union_member("info_dst_sm");
    vwrite(value_writer, value.info_dst_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::INFO_REPLY: {
    value_writer.begin_union_member("info_reply_sm");
    vwrite(value_writer, value.info_reply_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::NACK_FRAG: {
    value_writer.begin_union_member("nack_frag_sm");
    vwrite(value_writer, value.nack_frag_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::HEARTBEAT_FRAG: {
    value_writer.begin_union_member("hb_frag_sm");
    vwrite(value_writer, value.hb_frag_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::DATA: {
    value_writer.begin_union_member("data_sm");
    vwrite(value_writer, value.data_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::DATA_FRAG: {
    value_writer.begin_union_member("data_frag_sm");
    vwrite(value_writer, value.data_frag_sm());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::RTPS::SEC_BODY:
  case  ::OpenDDS::RTPS::SEC_PREFIX:
  case  ::OpenDDS::RTPS::SEC_POSTFIX:
  case  ::OpenDDS::RTPS::SRTPS_PREFIX:
  case  ::OpenDDS::RTPS::SRTPS_POSTFIX: {
    value_writer.begin_union_member("security_sm");
    vwrite(value_writer, value.security_sm());
    value_writer.end_union_member();
    break;
  }
  default: {
    value_writer.begin_union_member("unknown_sm");
    vwrite(value_writer, value.unknown_sm());
    value_writer.end_union_member();
    break;
  }
  }
  value_writer.end_union();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(uni);
   ::OpenDDS::RTPS::SubmessageKind temp;
    temp =  ::OpenDDS::RTPS::SUBMESSAGE_NONE;
  uni._d(temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case  ::OpenDDS::RTPS::PAD: {
    serialized_size(encoding, size, uni.pad_sm());
    break;
  }
  case  ::OpenDDS::RTPS::ACKNACK: {
    serialized_size(encoding, size, uni.acknack_sm());
    break;
  }
  case  ::OpenDDS::RTPS::HEARTBEAT: {
    serialized_size(encoding, size, uni.heartbeat_sm());
    break;
  }
  case  ::OpenDDS::RTPS::GAP: {
    serialized_size(encoding, size, uni.gap_sm());
    break;
  }
  case  ::OpenDDS::RTPS::INFO_TS: {
    serialized_size(encoding, size, uni.info_ts_sm());
    break;
  }
  case  ::OpenDDS::RTPS::INFO_SRC: {
    serialized_size(encoding, size, uni.info_src_sm());
    break;
  }
  case  ::OpenDDS::RTPS::INFO_REPLY_IP4: {
    serialized_size(encoding, size, uni.info_reply_ipv4_sm());
    break;
  }
  case  ::OpenDDS::RTPS::INFO_DST: {
    serialized_size(encoding, size, uni.info_dst_sm());
    break;
  }
  case  ::OpenDDS::RTPS::INFO_REPLY: {
    serialized_size(encoding, size, uni.info_reply_sm());
    break;
  }
  case  ::OpenDDS::RTPS::NACK_FRAG: {
    serialized_size(encoding, size, uni.nack_frag_sm());
    break;
  }
  case  ::OpenDDS::RTPS::HEARTBEAT_FRAG: {
    serialized_size(encoding, size, uni.hb_frag_sm());
    break;
  }
  case  ::OpenDDS::RTPS::DATA: {
    serialized_size(encoding, size, uni.data_sm());
    break;
  }
  case  ::OpenDDS::RTPS::DATA_FRAG: {
    serialized_size(encoding, size, uni.data_frag_sm());
    break;
  }
  case  ::OpenDDS::RTPS::SEC_BODY:
  case  ::OpenDDS::RTPS::SEC_PREFIX:
  case  ::OpenDDS::RTPS::SEC_POSTFIX:
  case  ::OpenDDS::RTPS::SRTPS_PREFIX:
  case  ::OpenDDS::RTPS::SRTPS_POSTFIX: {
    serialized_size(encoding, size, uni.security_sm());
    break;
  }
  default: {
    serialized_size(encoding, size, uni.unknown_sm());
    break;
  }
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case  ::OpenDDS::RTPS::PAD: {
    return (strm << uni.pad_sm());
  }
  case  ::OpenDDS::RTPS::ACKNACK: {
    return (strm << uni.acknack_sm());
  }
  case  ::OpenDDS::RTPS::HEARTBEAT: {
    return (strm << uni.heartbeat_sm());
  }
  case  ::OpenDDS::RTPS::GAP: {
    return (strm << uni.gap_sm());
  }
  case  ::OpenDDS::RTPS::INFO_TS: {
    return (strm << uni.info_ts_sm());
  }
  case  ::OpenDDS::RTPS::INFO_SRC: {
    return (strm << uni.info_src_sm());
  }
  case  ::OpenDDS::RTPS::INFO_REPLY_IP4: {
    return (strm << uni.info_reply_ipv4_sm());
  }
  case  ::OpenDDS::RTPS::INFO_DST: {
    return (strm << uni.info_dst_sm());
  }
  case  ::OpenDDS::RTPS::INFO_REPLY: {
    return (strm << uni.info_reply_sm());
  }
  case  ::OpenDDS::RTPS::NACK_FRAG: {
    return (strm << uni.nack_frag_sm());
  }
  case  ::OpenDDS::RTPS::HEARTBEAT_FRAG: {
    return (strm << uni.hb_frag_sm());
  }
  case  ::OpenDDS::RTPS::DATA: {
    return (strm << uni.data_sm());
  }
  case  ::OpenDDS::RTPS::DATA_FRAG: {
    return (strm << uni.data_frag_sm());
  }
  case  ::OpenDDS::RTPS::SEC_BODY:
  case  ::OpenDDS::RTPS::SEC_PREFIX:
  case  ::OpenDDS::RTPS::SEC_POSTFIX:
  case  ::OpenDDS::RTPS::SRTPS_PREFIX:
  case  ::OpenDDS::RTPS::SRTPS_POSTFIX: {
    return (strm << uni.security_sm());
  }
  default: {
    return (strm << uni.unknown_sm());
  }
  }
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  // unused
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::Submessage> : MetaStruct {
  typedef  ::OpenDDS::RTPS::Submessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::Submessage& typed = *static_cast<const  ::OpenDDS::RTPS::Submessage*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Submessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    ACE_UNUSED_ARG(ser);
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::OpenDDS::RTPS::Submessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Submessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    ACE_UNUSED_ARG(stru);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Submessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Submessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Submessage)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::Submessage>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::Submessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::Submessage*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  const bool is_mutable = 0;
  unsigned member_id;
  size_t field_size;
  bool must_understand = false;
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::RTPS::SubmessageKind disc;
  if (!(ser >> disc)) {
    return false;
  }
  switch (disc) {
  case  ::OpenDDS::RTPS::PAD: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::PadSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::ACKNACK: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::AckNackSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::HEARTBEAT: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::HeartBeatSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::GAP: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::GapSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::INFO_TS: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::InfoTimestampSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::INFO_SRC: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::InfoSourceSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::INFO_REPLY_IP4: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::InfoReplyIp4Submessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::INFO_DST: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::InfoDestinationSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::INFO_REPLY: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::InfoReplySubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::NACK_FRAG: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::NackFragSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::HEARTBEAT_FRAG: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::HeartBeatFragSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::DATA: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::DataSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::DATA_FRAG: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::DataFragSubmessage*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::RTPS::SEC_BODY:
  case  ::OpenDDS::RTPS::SEC_PREFIX:
  case  ::OpenDDS::RTPS::SEC_POSTFIX:
  case  ::OpenDDS::RTPS::SRTPS_PREFIX:
  case  ::OpenDDS::RTPS::SRTPS_POSTFIX: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::SecuritySubmessage*>(0))) return false;
    return true;
  }
  default: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::RTPS::SubmessageHeader*>(0))) return false;
    return true;
  }
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: Submessage */


/* Begin TYPEDEF: SubmessageSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_SubmessageSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(95, 161, 68, 139, 247, 60, 212, 207, 132, 249, 27, 100, 21, 47));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_SubmessageSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::RTPS::SubmessageSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::RTPS::SubmessageSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::SubmessageSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SubmessageSeq */


/* Begin STRUCT: DiscoveredTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_DiscoveredTopicData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(55, 33, 86, 126, 128, 2, 32, 173, 145, 239, 112, 171, 236, 133));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_DiscoveredTopicData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::DiscoveredTopicData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"ddsTopicData",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.ddsTopicData)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::DiscoveredTopicData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("ddsTopicData");
  vwrite(value_writer, value.ddsTopicData);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.ddsTopicData);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.ddsTopicData);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.ddsTopicData);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ddsTopicData)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::DiscoveredTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::DDS::TopicBuiltinTopicData>(stru.value.ddsTopicData));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::DiscoveredTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::DDS::TopicBuiltinTopicData>(stru.value.ddsTopicData));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::DiscoveredTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::DDS::TopicBuiltinTopicData> stru_value_ddsTopicData_nested_key_only(stru.value.ddsTopicData);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_ddsTopicData_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::DiscoveredTopicData> : MetaStruct {
  typedef  ::OpenDDS::RTPS::DiscoveredTopicData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("ddsTopicData", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DiscoveredTopicData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::DiscoveredTopicData& typed = *static_cast<const  ::OpenDDS::RTPS::DiscoveredTopicData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return getMetaStruct< ::DDS::TopicBuiltinTopicData>().getValue(&typed.ddsTopicData, field + 13);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DiscoveredTopicData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "ddsTopicData") {
      return getMetaStruct< ::DDS::TopicBuiltinTopicData>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TopicBuiltinTopicData*>(0))) {
        throw std::runtime_error("Field 'ddsTopicData' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return make_struct_cmp(&T::ddsTopicData, getMetaStruct< ::DDS::TopicBuiltinTopicData>().create_qc_comparator(field + 13), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DiscoveredTopicData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsTopicData", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsTopicData") == 0) {
      return &static_cast<const T*>(stru)->ddsTopicData;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DiscoveredTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsTopicData") == 0) {
      static_cast<T*>(lhs)->ddsTopicData = *static_cast<const  ::DDS::TopicBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DiscoveredTopicData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::DiscoveredTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::DiscoveredTopicData>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::DiscoveredTopicData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::DiscoveredTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::DiscoveredTopicData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DiscoveredTopicData */


/* Begin STRUCT: Message */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_RTPS_Message_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(78, 228, 180, 27, 81, 71, 76, 201, 151, 212, 238, 77, 239, 150));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_RTPS_Message_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::RTPS::Message& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"hdr",0},{"submessages",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.hdr)) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.submessages);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.submessages[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::RTPS::Message& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("hdr");
  vwrite(value_writer, value.hdr);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("submessages");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.submessages.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.submessages[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::RTPS::Message& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.hdr);
  stru.submessages.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::RTPS::Message& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.hdr);
  serialized_size(encoding, size, stru.submessages);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::RTPS::Message& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.hdr)
    && (strm << stru.submessages);
}

bool operator>>(Serializer& strm,  ::OpenDDS::RTPS::Message& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.hdr)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.submessages)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::RTPS::Message>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.hdr);
  serialized_size(encoding, size, stru.value.submessages);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::RTPS::Message>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.hdr)
    && (strm << stru.value.submessages);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::RTPS::Message>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.hdr)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.submessages)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::RTPS::Message> : MetaStruct {
  typedef  ::OpenDDS::RTPS::Message T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("hdr", 0),
      std::make_pair("submessages", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Message)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::RTPS::Message& typed = *static_cast<const  ::OpenDDS::RTPS::Message*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "hdr.", 4) == 0) {
      return getMetaStruct< ::OpenDDS::RTPS::Header>().getValue(&typed.hdr, field + 4);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Message)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "hdr") {
      return getMetaStruct< ::OpenDDS::RTPS::Header>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::Header*>(0))) {
        throw std::runtime_error("Field 'hdr' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::RTPS::SubmessageSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "hdr.", 4) == 0) {
      return make_struct_cmp(&T::hdr, getMetaStruct< ::OpenDDS::RTPS::Header>().create_qc_comparator(field + 4), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Message)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"hdr", "submessages", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "hdr") == 0) {
      return &static_cast<const T*>(stru)->hdr;
    }
    if (std::strcmp(field, "submessages") == 0) {
      return &static_cast<const T*>(stru)->submessages;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Message)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "hdr") == 0) {
      static_cast<T*>(lhs)->hdr = *static_cast<const  ::OpenDDS::RTPS::Header*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "submessages") == 0) {
      static_cast<T*>(lhs)->submessages = *static_cast<const  ::OpenDDS::RTPS::SubmessageSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Message)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::RTPS::Message)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::RTPS::Message>()
{
  static MetaStructImpl< ::OpenDDS::RTPS::Message> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::RTPS::Message*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::RTPS::Message>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Message */

/* End MODULE: RTPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

namespace {
XTypes::TypeObject minimal_to0()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(237, 176, 184, 24))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(47, 120, 168, 55))))));
}

XTypes::TypeObject minimal_to1()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(146, 200, 199, 70))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(27, 204, 23, 153))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(107, 155, 68, 175))))));
}

XTypes::TypeObject minimal_to2()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100)))))))));
}

XTypes::TypeObject minimal_to3()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(18, 113, 84, 193, 2, 246, 131, 177, 4, 117, 126, 75, 63, 142)))))))));
}

XTypes::TypeObject minimal_to4()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(3), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to5()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(120, 62, 142, 41))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(3, 240, 53, 109))))));
}

XTypes::TypeObject minimal_to6()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(4), XTypes::TypeIdentifier(XTypes::TK_INT32))))))));
}

XTypes::TypeObject minimal_to7()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to8()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(51, 88, 217, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(106, 125, 250, 119))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(244, 120, 72, 133))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(211, 69, 47, 26, 143, 144, 252, 240, 92, 219, 42, 193, 194, 64))), XTypes::MinimalMemberDetail(115, 9, 123, 39))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(226, 148, 42, 4))))));
}

XTypes::TypeObject minimal_to9()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_STRING8_LARGE, XTypes::StringLTypeDefn(256)))))));
}

XTypes::TypeObject minimal_to10()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 8, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100)))))))));
}

XTypes::TypeObject minimal_to11()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(51, 88, 217, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(106, 125, 250, 119))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(147, 235, 253, 18, 141, 198, 246, 197, 245, 92, 250, 175, 56, 124))), XTypes::MinimalMemberDetail(15, 82, 29, 118))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(226, 148, 42, 4))))));
}

XTypes::TypeObject minimal_to12()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85)))))));
}

XTypes::TypeObject minimal_to13()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(124, 184, 31, 69))))));
}

XTypes::TypeObject minimal_to14()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT16)), XTypes::MinimalMemberDetail(252, 136, 130, 44))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT16)), XTypes::MinimalMemberDetail(238, 107, 45, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(51, 88, 217, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(106, 125, 250, 119))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(244, 120, 72, 133))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(82, 136, 3, 161, 52, 193, 32, 193, 107, 215, 205, 208, 118, 237))), XTypes::MinimalMemberDetail(46, 61, 42, 108))))));
}

XTypes::TypeObject minimal_to15()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(223, 137, 245, 17, 179, 98, 96, 20, 237, 41, 215, 82, 255, 127))), XTypes::MinimalMemberDetail(104, 62, 75, 13))))));
}

XTypes::TypeObject minimal_to16()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(141, 150, 107, 34))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(83, 204, 237, 141))))));
}

XTypes::TypeObject minimal_to17()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(32, 99, 193, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(143, 108, 196, 87))))));
}

XTypes::TypeObject minimal_to18()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(106, 202, 102, 165))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(78, 88, 104, 214))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT16)), XTypes::MinimalMemberDetail(177, 222, 38, 220))))));
}

XTypes::TypeObject minimal_to19()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(157, 89, 81, 62))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 184, 244, 149, 52, 65, 12, 119, 163, 176, 63, 222, 239, 135))), XTypes::MinimalMemberDetail(141, 119, 127, 56))))));
}

XTypes::TypeObject minimal_to20()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(173, 51, 47, 234, 23, 87, 166, 82, 211, 40, 79, 240, 240, 111))), XTypes::MinimalMemberDetail(47, 15, 158, 11))))));
}

XTypes::TypeObject minimal_to21()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to22()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 124, 74, 82, 33, 209, 171, 154, 100, 92, 69, 182, 34, 215))), XTypes::MinimalMemberDetail(144, 105, 124, 76))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(28, 106, 127, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(25, 186, 87, 68))))));
}

XTypes::TypeObject minimal_to23()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(106, 77, 176, 72, 18, 12, 173, 22, 88, 169, 114, 73, 204, 116)))))));
}

XTypes::TypeObject minimal_to24()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(184, 94, 195, 20))))));
}

XTypes::TypeObject minimal_to25()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(233, 42, 172, 155))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(208, 123, 134, 189))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(11, 60, 225, 99))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(3, 0), XTypes::MinimalMemberDetail(47, 181, 127, 223))))));
}

XTypes::TypeObject minimal_to26()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TK_INT32))))))));
}

XTypes::TypeObject minimal_to27()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(212, 19, 36, 204, 216, 207, 229, 8, 101, 152, 15, 215, 71, 23))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to28()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(16), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to29()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148)))))))));
}

XTypes::TypeObject minimal_to30()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(116, 69, 156, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 4, 100, 213))))));
}

XTypes::TypeObject minimal_to31()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(106, 77, 176, 72, 18, 12, 173, 22, 88, 169, 114, 73, 204, 116))), XTypes::MinimalMemberDetail(32, 99, 193, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(125, 68, 172, 132, 224, 239, 218, 60, 192, 71, 15, 147, 30, 246))), XTypes::MinimalMemberDetail(153, 141, 15, 107))))));
}

XTypes::TypeObject minimal_to32()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(135, 85, 81, 27, 49, 2, 203, 211, 40, 79, 154, 88, 201, 112))), XTypes::MinimalMemberDetail(76, 205, 203, 199))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(95, 161, 68, 139, 247, 60, 212, 207, 132, 249, 27, 100, 21, 47))), XTypes::MinimalMemberDetail(40, 19, 63, 211))))));
}

XTypes::TypeObject minimal_to33()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(189, 234, 44, 41, 184, 44, 245, 89, 156, 86, 145, 192, 39, 61)))))))));
}

XTypes::TypeObject minimal_to34()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(103, 99, 176, 25, 62, 194, 58, 17, 243, 55, 82, 78, 3, 240))), XTypes::MinimalMemberDetail(215, 230, 213, 91))))));
}

XTypes::TypeObject minimal_to35()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(18, 160, 85, 191))))));
}

XTypes::TypeObject minimal_to36()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(102, 170, 145, 4, 80, 244, 15, 54, 224, 255, 110, 254, 204, 151)))))))));
}

XTypes::TypeObject minimal_to37()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(60, 110, 11, 138))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100))), XTypes::MinimalMemberDetail(171, 30, 7, 248))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(1, 186, 243, 107))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(185, 136, 41, 92))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(89, 157, 204, 226))))));
}

XTypes::TypeObject minimal_to38()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(62, 114, 125, 184, 14, 246, 184, 86, 96, 15, 47, 72, 182, 26))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to39()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalUnionType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalUnionHeader(XTypes::MinimalTypeDetail()), XTypes::MinimalDiscriminatorMember(XTypes::CommonDiscriminatorMember(XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(147, 176, 57, 236, 194, 129, 36, 216, 44, 165, 133, 49, 248, 141)))), XTypes::MinimalUnionMemberSeq().append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(111, 0, 172, 23, 200, 153, 190, 187, 205, 142, 149, 204, 41, 21)), XTypes::UnionCaseLabelSeq().append(1)), XTypes::MinimalMemberDetail(43, 171, 204, 59))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(28, 163, 101, 61, 222, 61, 181, 14, 249, 2, 35, 3, 27, 80)), XTypes::UnionCaseLabelSeq().append(6)), XTypes::MinimalMemberDetail(240, 173, 88, 78))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 216, 152, 127, 197, 0, 10, 17, 138, 213, 145, 90, 204, 148)), XTypes::UnionCaseLabelSeq().append(7)), XTypes::MinimalMemberDetail(190, 173, 144, 69))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(255, 4, 174, 218, 37, 5, 222, 128, 186, 53, 194, 162, 215, 91)), XTypes::UnionCaseLabelSeq().append(8)), XTypes::MinimalMemberDetail(3, 56, 249, 221))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(89, 229, 192, 159, 193, 43, 151, 40, 114, 54, 88, 1, 0, 21)), XTypes::UnionCaseLabelSeq().append(9)), XTypes::MinimalMemberDetail(161, 70, 217, 98))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(241, 215, 115, 29, 74, 144, 179, 155, 104, 243, 189, 42, 144, 110)), XTypes::UnionCaseLabelSeq().append(12)), XTypes::MinimalMemberDetail(78, 239, 100, 116))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(228, 22, 64, 100, 44, 121, 150, 142, 57, 135, 196, 14, 115, 14)), XTypes::UnionCaseLabelSeq().append(13)), XTypes::MinimalMemberDetail(87, 184, 121, 72))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(220, 252, 235, 15, 216, 123, 170, 85, 138, 235, 133, 193, 175, 9)), XTypes::UnionCaseLabelSeq().append(14)), XTypes::MinimalMemberDetail(78, 122, 127, 109))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(188, 91, 255, 173, 137, 11, 90, 63, 130, 182, 219, 225, 235, 130)), XTypes::UnionCaseLabelSeq().append(15)), XTypes::MinimalMemberDetail(158, 55, 70, 108))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(198, 31, 110, 3, 217, 217, 69, 24, 16, 60, 254, 93, 63, 254)), XTypes::UnionCaseLabelSeq().append(18)), XTypes::MinimalMemberDetail(180, 71, 201, 0))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(26, 90, 222, 159, 124, 27, 74, 53, 0, 110, 7, 177, 194, 34)), XTypes::UnionCaseLabelSeq().append(19)), XTypes::MinimalMemberDetail(7, 176, 46, 131))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(37, 118, 24, 23, 239, 173, 163, 127, 104, 159, 172, 143, 54, 229)), XTypes::UnionCaseLabelSeq().append(21)), XTypes::MinimalMemberDetail(55, 206, 136, 154))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(145, 105, 114, 192, 4, 141, 200, 90, 70, 173, 35, 248, 103, 55)), XTypes::UnionCaseLabelSeq().append(22)), XTypes::MinimalMemberDetail(34, 7, 241, 222))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 18, 77, 133, 10, 184, 210, 12, 27, 14, 223, 163, 116, 74)), XTypes::UnionCaseLabelSeq().append(48).append(49).append(50).append(51).append(52)), XTypes::MinimalMemberDetail(232, 174, 132, 92))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(14, XTypes::TRY_CONSTRUCT1 | XTypes::IS_DEFAULT, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248)), XTypes::UnionCaseLabelSeq()), XTypes::MinimalMemberDetail(205, 159, 8, 33))))));
}

XTypes::TypeObject minimal_to40()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(12, 146, 216, 130, 44, 156, 246, 196, 95, 35, 157, 166, 171, 143)))))));
}

XTypes::TypeObject minimal_to41()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(47, 136, 233, 191, 112, 193, 42, 150, 67, 246, 172, 37, 197, 132)))))))));
}

XTypes::TypeObject minimal_to42()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_UINT32))))));
}

XTypes::TypeObject minimal_to43()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(241, 66, 93, 164))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(171, 132, 108, 14))))));
}

XTypes::TypeObject minimal_to44()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))))));
}

XTypes::TypeObject minimal_to45()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(204, 65, 30, 108))))));
}

XTypes::TypeObject minimal_to46()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))), XTypes::MinimalMemberDetail(253, 35, 86, 164))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))), XTypes::MinimalMemberDetail(152, 150, 76, 59))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))), XTypes::MinimalMemberDetail(188, 129, 128, 87))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(228, 9, 248, 126))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(80, 138, 45, 158))))));
}

XTypes::TypeObject minimal_to47()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(104, 240, 63, 69))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(106, 40, 90, 134))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(230, 32, 45, 146))))));
}

XTypes::TypeObject minimal_to48()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to49()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(12, 87, 212, 43))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))), XTypes::MinimalMemberDetail(35, 210, 249, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(82, 73, 45, 112))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(167, 83, 247, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(65, 192, 149, 169))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(1, 216, 160, 135))))));
}

XTypes::TypeObject minimal_to50()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(1, 78, 93, 82, 90, 169, 236, 225, 40, 97, 126, 118, 81, 144))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(223, 134, 34, 208))))));
}

XTypes::TypeObject minimal_to51()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(251, 95, 64, 60, 163, 23, 170, 158, 193, 148, 167, 7, 12, 36)))))))));
}

XTypes::TypeObject minimal_to52()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_UINT16))))));
}

XTypes::TypeObject minimal_to53()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 90, 35, 84, 117, 166, 180, 163, 60, 216, 244, 19, 92, 13))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to54()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 90, 35, 84, 117, 166, 180, 163, 60, 216, 244, 19, 92, 13))), XTypes::MinimalMemberDetail(133, 31, 90, 201))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(110, 72, 232, 232, 110, 217, 15, 250, 174, 208, 243, 110, 194, 46))), XTypes::MinimalMemberDetail(42, 247, 47, 16))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(38, 51, 5, 107, 156, 29, 189, 228, 155, 120, 31, 109, 12, 240))), XTypes::MinimalMemberDetail(104, 62, 75, 13))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))))));
}

XTypes::TypeObject minimal_to55()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(167, 83, 247, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(65, 192, 149, 169))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(1, 216, 160, 135))))));
}

XTypes::TypeObject minimal_to56()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT32))))));
}

XTypes::TypeObject minimal_to57()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(136, 77, 152, 4))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(144, 21, 85, 251))))));
}

XTypes::TypeObject minimal_to58()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT16)), XTypes::MinimalMemberDetail(252, 136, 130, 44))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT16)), XTypes::MinimalMemberDetail(238, 107, 45, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(51, 88, 217, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(106, 125, 250, 119))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(244, 120, 72, 133))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(211, 69, 47, 26, 143, 144, 252, 240, 92, 219, 42, 193, 194, 64))), XTypes::MinimalMemberDetail(87, 42, 28, 139))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT16)), XTypes::MinimalMemberDetail(39, 152, 171, 249))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT16)), XTypes::MinimalMemberDetail(240, 245, 57, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(246, 79, 29, 66))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(82, 136, 3, 161, 52, 193, 32, 193, 107, 215, 205, 208, 118, 237))), XTypes::MinimalMemberDetail(46, 61, 42, 108))))));
}

XTypes::TypeObject minimal_to59()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(60, 110, 11, 138))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(137, 49, 111, 98))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(20, 196, 176, 107))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(95, 77, 204, 59))))));
}

XTypes::TypeObject minimal_to60()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(174, 212, 45, 90))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(154, 145, 228, 35))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(28, 218, 206, 53))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(3, 0), XTypes::MinimalMemberDetail(0, 25, 55, 247))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(4, 0), XTypes::MinimalMemberDetail(110, 69, 33, 189))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(5, 0), XTypes::MinimalMemberDetail(120, 31, 153, 24))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(6, 0), XTypes::MinimalMemberDetail(225, 198, 86, 11))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(7, 0), XTypes::MinimalMemberDetail(13, 137, 90, 10))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(8, 0), XTypes::MinimalMemberDetail(232, 10, 233, 60))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(9, 0), XTypes::MinimalMemberDetail(231, 42, 13, 113))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(10, 0), XTypes::MinimalMemberDetail(198, 127, 97, 194))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(11, 0), XTypes::MinimalMemberDetail(213, 128, 242, 35))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(12, 0), XTypes::MinimalMemberDetail(233, 83, 61, 255))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(13, 0), XTypes::MinimalMemberDetail(150, 179, 226, 232))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(14, 0), XTypes::MinimalMemberDetail(81, 77, 117, 125))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(15, 0), XTypes::MinimalMemberDetail(133, 153, 87, 56))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(16, 0), XTypes::MinimalMemberDetail(232, 116, 123, 57))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(17, 0), XTypes::MinimalMemberDetail(249, 198, 32, 27))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(18, 0), XTypes::MinimalMemberDetail(200, 143, 111, 164))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(19, 0), XTypes::MinimalMemberDetail(199, 32, 126, 99))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(20, 0), XTypes::MinimalMemberDetail(47, 156, 110, 148))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(21, 0), XTypes::MinimalMemberDetail(228, 79, 158, 52))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(22, 0), XTypes::MinimalMemberDetail(254, 15, 229, 9))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(23, 0), XTypes::MinimalMemberDetail(149, 24, 253, 37))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(24, 0), XTypes::MinimalMemberDetail(219, 18, 193, 117))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(25, 0), XTypes::MinimalMemberDetail(239, 93, 132, 228))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(26, 0), XTypes::MinimalMemberDetail(69, 1, 24, 107))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(27, 0), XTypes::MinimalMemberDetail(118, 101, 110, 136))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(28, 0), XTypes::MinimalMemberDetail(242, 197, 169, 252))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(29, 0), XTypes::MinimalMemberDetail(17, 56, 0, 143))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(30, 0), XTypes::MinimalMemberDetail(79, 228, 110, 217))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(31, 0), XTypes::MinimalMemberDetail(150, 210, 83, 172))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(32, 0), XTypes::MinimalMemberDetail(175, 85, 79, 81))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(33, 0), XTypes::MinimalMemberDetail(229, 229, 110, 239))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(34, 0), XTypes::MinimalMemberDetail(30, 194, 114, 106))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(35, 0), XTypes::MinimalMemberDetail(175, 219, 217, 225))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(36, 0), XTypes::MinimalMemberDetail(226, 253, 6, 7))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(37, 0), XTypes::MinimalMemberDetail(236, 4, 220, 165))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(38, 0), XTypes::MinimalMemberDetail(215, 100, 132, 232))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(39, 0), XTypes::MinimalMemberDetail(179, 114, 93, 180))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(40, 0), XTypes::MinimalMemberDetail(245, 118, 115, 30))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(41, 0), XTypes::MinimalMemberDetail(12, 65, 24, 63))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(42, 0), XTypes::MinimalMemberDetail(125, 14, 19, 16))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(43, 0), XTypes::MinimalMemberDetail(188, 84, 210, 81))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(44, 0), XTypes::MinimalMemberDetail(167, 113, 199, 42))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(45, 0), XTypes::MinimalMemberDetail(178, 151, 50, 75))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(46, 0), XTypes::MinimalMemberDetail(188, 245, 24, 67))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(47, 0), XTypes::MinimalMemberDetail(183, 181, 174, 150))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(48, 0), XTypes::MinimalMemberDetail(162, 174, 210, 160))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(49, 0), XTypes::MinimalMemberDetail(215, 201, 189, 246))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(50, 0), XTypes::MinimalMemberDetail(114, 245, 149, 235))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(51, 0), XTypes::MinimalMemberDetail(68, 0, 94, 147))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(52, 0), XTypes::MinimalMemberDetail(218, 105, 85, 230))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(53, 0), XTypes::MinimalMemberDetail(110, 140, 54, 100))))));
}

XTypes::TypeObject minimal_to61()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(235, 70, 9, 36))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(188, 248, 156, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(149, 57, 30, 106, 7, 12, 230, 99, 234, 186, 194, 64, 166, 141))), XTypes::MinimalMemberDetail(134, 187, 51, 117))))));
}

XTypes::TypeObject minimal_to62()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 8, XTypes::TypeIdentifier(XTypes::TK_INT32))))))));
}

XTypes::TypeObject minimal_to63()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(64, 188, 63, 150))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(5, 165, 180, 122))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(107, 61, 225, 31))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(70, 41, 47, 174))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(245, 160, 163, 241))))));
}

XTypes::TypeObject minimal_to64()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0)))))))));
}

XTypes::TypeObject minimal_to65()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(120, 62, 142, 41))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(3, 240, 53, 109))))));
}

XTypes::TypeObject minimal_to66()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(177, 178, 109, 157))))));
}

XTypes::TypeObject minimal_to67()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(12), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to68()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(34, 62, 1, 125))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(141, 119, 127, 56))))));
}

XTypes::TypeObject minimal_to69()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(122, 244, 39, 138))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(142, 251, 174, 249))))));
}

XTypes::TypeObject minimal_to70()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(34, 23, 141, 102))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(26, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(27, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(29, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(30, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))), XTypes::MinimalMemberDetail(43, 95, 162, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(31, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(35, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(37, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(39, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(43, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(13, 138, 191, 79))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(46, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(141, 115, 88, 91))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(64, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))), XTypes::MinimalMemberDetail(60, 209, 95, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(65, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))), XTypes::MinimalMemberDetail(15, 202, 164, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(73, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(27, 42, 197, 216))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(90, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(60, 110, 11, 138))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(115, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))))));
}

XTypes::TypeObject minimal_to71()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(211, 69, 47, 26, 143, 144, 252, 240, 92, 219, 42, 193, 194, 64))), XTypes::MinimalMemberDetail(235, 70, 9, 36))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(188, 248, 156, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(149, 57, 30, 106, 7, 12, 230, 99, 234, 186, 194, 64, 166, 141))), XTypes::MinimalMemberDetail(134, 187, 51, 117))))));
}

XTypes::TypeObject minimal_to72()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(144, 21, 85, 251))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))), XTypes::MinimalMemberDetail(136, 77, 152, 4))))));
}

XTypes::TypeObject minimal_to73()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT16))))));
}

XTypes::TypeObject minimal_to74()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))))));
}

XTypes::TypeObject minimal_to75()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(154, 3, 100, 185))))));
}

XTypes::TypeObject minimal_to76()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 247, 209, 52, 65, 35, 253, 153, 236, 85, 203, 16, 40, 240))), XTypes::MinimalMemberDetail(85, 140, 220, 240))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 247, 209, 52, 65, 35, 253, 153, 236, 85, 203, 16, 40, 240))), XTypes::MinimalMemberDetail(206, 181, 105, 34))))));
}

XTypes::TypeObject minimal_to77()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalUnionType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalUnionHeader(XTypes::MinimalTypeDetail()), XTypes::MinimalDiscriminatorMember(XTypes::CommonDiscriminatorMember(XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT16))), XTypes::MinimalUnionMemberSeq().append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238)), XTypes::UnionCaseLabelSeq().append(5).append(7)), XTypes::MinimalMemberDetail(105, 122, 12, 23))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23)), XTypes::UnionCaseLabelSeq().append(44)), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23)), XTypes::UnionCaseLabelSeq().append(45)), XTypes::MinimalMemberDetail(249, 86, 165, 139))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23)), XTypes::UnionCaseLabelSeq().append(46)), XTypes::MinimalMemberDetail(141, 115, 88, 91))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235)), XTypes::UnionCaseLabelSeq().append(29)), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73)), XTypes::UnionCaseLabelSeq().append(30)), XTypes::MinimalMemberDetail(43, 95, 162, 89))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97)), XTypes::UnionCaseLabelSeq().append(35)), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103)), XTypes::UnionCaseLabelSeq().append(39)), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14)), XTypes::UnionCaseLabelSeq().append(27)), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 165, 200, 168, 60, 12, 23, 106, 127, 63, 129, 60, 104, 33)), XTypes::UnionCaseLabelSeq().append(26)), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103)), XTypes::UnionCaseLabelSeq().append(43)), XTypes::MinimalMemberDetail(13, 138, 191, 79))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95)), XTypes::UnionCaseLabelSeq().append(37)), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190)), XTypes::UnionCaseLabelSeq().append(64)), XTypes::MinimalMemberDetail(60, 209, 95, 143))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25)), XTypes::UnionCaseLabelSeq().append(65)), XTypes::MinimalMemberDetail(15, 202, 164, 60))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(14, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105)), XTypes::UnionCaseLabelSeq().append(31)), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(15, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152)), XTypes::UnionCaseLabelSeq().append(6)), XTypes::MinimalMemberDetail(170, 93, 128, 221))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(16, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102)), XTypes::UnionCaseLabelSeq().append(33)), XTypes::MinimalMemberDetail(36, 134, 146, 58))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(17, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100)), XTypes::UnionCaseLabelSeq().append(41)), XTypes::MinimalMemberDetail(112, 19, 186, 155))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(18, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37)), XTypes::UnionCaseLabelSeq().append(4)), XTypes::MinimalMemberDetail(248, 53, 38, 241))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(19, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152)), XTypes::UnionCaseLabelSeq().append(73)), XTypes::MinimalMemberDetail(27, 42, 197, 216))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(20, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(110, 72, 232, 232, 110, 217, 15, 250, 174, 208, 243, 110, 194, 46)), XTypes::UnionCaseLabelSeq().append(21)), XTypes::MinimalMemberDetail(42, 247, 47, 16))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(21, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(38, 51, 5, 107, 156, 29, 189, 228, 155, 120, 31, 109, 12, 240)), XTypes::UnionCaseLabelSeq().append(22)), XTypes::MinimalMemberDetail(124, 54, 19, 219))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(22, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100)), XTypes::UnionCaseLabelSeq().append(47).append(48).append(49).append(50).append(51).append(72)), XTypes::MinimalMemberDetail(171, 30, 7, 248))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(23, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN), XTypes::UnionCaseLabelSeq().append(67)), XTypes::MinimalMemberDetail(144, 198, 95, 194))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(24, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152)), XTypes::UnionCaseLabelSeq().append(52)), XTypes::MinimalMemberDetail(226, 148, 42, 4))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(25, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32), XTypes::UnionCaseLabelSeq().append(68)), XTypes::MinimalMemberDetail(135, 252, 183, 47))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(26, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(159, 245, 110, 111, 33, 28, 122, 7, 5, 199, 96, 142, 87, 19)), XTypes::UnionCaseLabelSeq().append(2)), XTypes::MinimalMemberDetail(184, 94, 195, 20))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(27, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(119, 4, 180, 70, 2, 71, 100, 25, 64, 45, 106, 141, 80, 208)), XTypes::UnionCaseLabelSeq().append(53)), XTypes::MinimalMemberDetail(167, 60, 143, 220))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(28, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253)), XTypes::UnionCaseLabelSeq().append(80).append(82).append(87).append(90).append(45058)), XTypes::MinimalMemberDetail(30, 12, 165, 177))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(29, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(117, 115, 123, 224, 198, 52, 178, 1, 245, 119, 232, 217, 48, 219)), XTypes::UnionCaseLabelSeq().append(45061)), XTypes::MinimalMemberDetail(190, 66, 217, 165))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(30, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN), XTypes::UnionCaseLabelSeq().append(45062)), XTypes::MinimalMemberDetail(20, 89, 46, 223))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(31, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207)), XTypes::UnionCaseLabelSeq().append(88)), XTypes::MinimalMemberDetail(191, 80, 184, 171))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(32, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(74, 39, 56, 203, 127, 182, 9, 1, 220, 224, 1, 152, 231, 249)), XTypes::UnionCaseLabelSeq().append(89)), XTypes::MinimalMemberDetail(26, 141, 180, 201))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(33, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32), XTypes::UnionCaseLabelSeq().append(96)), XTypes::MinimalMemberDetail(57, 67, 143, 11))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(34, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(183, 77, 161, 2, 250, 20, 171, 40, 89, 82, 214, 220, 104, 251)), XTypes::UnionCaseLabelSeq().append(98)), XTypes::MinimalMemberDetail(133, 132, 84, 244))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(35, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181)), XTypes::UnionCaseLabelSeq().append(112)), XTypes::MinimalMemberDetail(17, 95, 53, 92))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(36, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(133, 22, 18, 238, 85, 223, 209, 176, 88, 48, 223, 166, 156, 212)), XTypes::UnionCaseLabelSeq().append(113)), XTypes::MinimalMemberDetail(179, 37, 82, 124))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(37, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(217, 115, 52, 86, 152, 78, 235, 0, 132, 179, 241, 33, 223, 229)), XTypes::UnionCaseLabelSeq().append(85)), XTypes::MinimalMemberDetail(232, 122, 163, 187))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(38, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235)), XTypes::UnionCaseLabelSeq().append(86)), XTypes::MinimalMemberDetail(45, 167, 193, 227))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(39, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(0, 236, 19, 180, 137, 206, 245, 92, 185, 48, 236, 164, 76, 231)), XTypes::UnionCaseLabelSeq().append(97)), XTypes::MinimalMemberDetail(148, 67, 24, 246))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(40, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 235, 25, 172, 15, 65, 98, 13, 167, 52, 8, 137, 206, 198)), XTypes::UnionCaseLabelSeq().append(45057)), XTypes::MinimalMemberDetail(68, 12, 51, 207))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(41, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(146, 63, 166, 114, 163, 203, 97, 205, 144, 166, 92, 200, 247, 237)), XTypes::UnionCaseLabelSeq().append(45059)), XTypes::MinimalMemberDetail(81, 214, 172, 171))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(42, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(99, 164, 202, 7, 10, 4, 116, 207, 251, 120, 151, 82, 190, 72)), XTypes::UnionCaseLabelSeq().append(45060)), XTypes::MinimalMemberDetail(80, 156, 81, 221))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(43, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211)), XTypes::UnionCaseLabelSeq().append(15)), XTypes::MinimalMemberDetail(114, 238, 118, 197))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(44, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238)), XTypes::UnionCaseLabelSeq().append(16404)), XTypes::MinimalMemberDetail(50, 127, 226, 233))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(45, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207)), XTypes::UnionCaseLabelSeq().append(119)), XTypes::MinimalMemberDetail(184, 248, 160, 67))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(46, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85)), XTypes::UnionCaseLabelSeq().append(117)), XTypes::MinimalMemberDetail(183, 35, 33, 66))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(47, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6)), XTypes::UnionCaseLabelSeq().append(115)), XTypes::MinimalMemberDetail(238, 22, 117, 90))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(48, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225)), XTypes::UnionCaseLabelSeq().append(116)), XTypes::MinimalMemberDetail(184, 135, 19, 246))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(49, XTypes::TRY_CONSTRUCT1 | XTypes::IS_DEFAULT, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85)), XTypes::UnionCaseLabelSeq()), XTypes::MinimalMemberDetail(40, 97, 158, 162))))));
}

XTypes::TypeObject minimal_to78()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(47, 136, 233, 191, 112, 193, 42, 150, 67, 246, 172, 37, 197, 132)))))));
}

XTypes::TypeObject minimal_to79()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(51, 88, 217, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(106, 125, 250, 119))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(244, 120, 72, 133))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(174, 143, 129, 76, 253, 100, 99, 188, 219, 244, 101, 109, 25, 41))), XTypes::MinimalMemberDetail(51, 134, 120, 153))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(226, 148, 42, 4))))));
}

XTypes::TypeObject minimal_to80()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(4), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to81()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(2, 5, 193, 190))))));
}

XTypes::TypeObject minimal_to82()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(176, 104, 147, 28))))));
}

XTypes::TypeObject minimal_to83()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to84()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(253, 72, 63, 147, 206, 16, 241, 72, 186, 231, 206, 213, 79, 158))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to85()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to86()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 87, 237, 35, 153, 167, 62, 144, 213, 193, 96, 70, 214, 135))), XTypes::MinimalMemberDetail(15, 163, 240, 41))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(222, 70, 220, 15, 61, 238, 235, 97, 172, 112, 61, 247, 50, 154))), XTypes::MinimalMemberDetail(147, 244, 45, 155))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(159, 245, 110, 111, 33, 28, 122, 7, 5, 199, 96, 142, 87, 19))), XTypes::MinimalMemberDetail(239, 219, 109, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(43, 92, 46, 35))))));
}

XTypes::TypeObject minimal_to87()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(43, 67, 125, 32))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(249, 191, 143, 65))))));
}

XTypes::TypeObject minimal_to88()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 132, 84, 128, 187, 1, 123, 173, 187, 231, 55, 190, 22, 206))), XTypes::MinimalMemberDetail(205, 87, 162, 109))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(8, 72, 1, 219, 209, 130, 97, 88, 183, 75, 190, 192, 122, 99))), XTypes::MinimalMemberDetail(203, 193, 201, 31))))));
}

XTypes::TypeObject minimal_to89()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))))));
}

XTypes::TypeObject minimal_to90()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(114, 238, 118, 197))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))), XTypes::MinimalMemberDetail(50, 127, 226, 233))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(110, 72, 232, 232, 110, 217, 15, 250, 174, 208, 243, 110, 194, 46))), XTypes::MinimalMemberDetail(229, 235, 27, 26))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(38, 51, 5, 107, 156, 29, 189, 228, 155, 120, 31, 109, 12, 240))), XTypes::MinimalMemberDetail(104, 62, 75, 13))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(84, 1, 88, 35))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(210, 208, 246, 73))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(184, 248, 160, 67))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(3, 25, 45, 83, 244, 194, 80, 75, 84, 30, 189, 230, 238, 219))), XTypes::MinimalMemberDetail(138, 241, 128, 193))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(3, 25, 45, 83, 244, 194, 80, 75, 84, 30, 189, 230, 238, 219))), XTypes::MinimalMemberDetail(199, 222, 38, 131))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(3, 25, 45, 83, 244, 194, 80, 75, 84, 30, 189, 230, 238, 219))), XTypes::MinimalMemberDetail(131, 158, 163, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(3, 25, 45, 83, 244, 194, 80, 75, 84, 30, 189, 230, 238, 219))), XTypes::MinimalMemberDetail(76, 69, 104, 107))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(235, 79, 104, 192))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(74, 39, 56, 203, 127, 182, 9, 1, 220, 224, 1, 152, 231, 249))), XTypes::MinimalMemberDetail(26, 141, 180, 201))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(14, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(117, 115, 123, 224, 198, 52, 178, 1, 245, 119, 232, 217, 48, 219))), XTypes::MinimalMemberDetail(55, 229, 66, 151))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(15, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(20, 89, 46, 223))))));
}

XTypes::TypeObject minimal_to91()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(2), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to92()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 175, 77, 37, 194, 231, 136, 170, 53, 228, 31, 45, 86, 160))), XTypes::MinimalMemberDetail(124, 52, 158, 225))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 175, 77, 37, 194, 231, 136, 170, 53, 228, 31, 45, 86, 160))), XTypes::MinimalMemberDetail(69, 167, 207, 238))))));
}

XTypes::TypeObject minimal_to93()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))), XTypes::MinimalMemberDetail(87, 2, 74, 74))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(61, 5, 144, 205))))));
}

XTypes::TypeObject minimal_to94()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 31, 169, 229, 223, 19, 38, 65, 134, 73, 192, 156, 90, 188))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to95()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(253, 148, 198, 162))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(110, 72, 232, 232, 110, 217, 15, 250, 174, 208, 243, 110, 194, 46))), XTypes::MinimalMemberDetail(42, 247, 47, 16))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(38, 51, 5, 107, 156, 29, 189, 228, 155, 120, 31, 109, 12, 240))), XTypes::MinimalMemberDetail(104, 62, 75, 13))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))))));
}

XTypes::TypeObject minimal_to96()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 115, 43, 233, 139, 29, 28, 130, 117, 249, 188, 147, 54, 250))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(2, 5, 193, 190))))));
}

XTypes::TypeObject minimal_to97()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(68, 71, 41, 218))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(139, 230, 147, 131))))));
}

XTypes::TypeObject minimal_to98()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(44, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(60, 110, 11, 138))))));
}

XTypes::TypeObject minimal_to99()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(160, 172, 250, 70))))));
}

XTypes::TypeObject minimal_to100()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(32, 99, 193, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(143, 108, 196, 87))))));
}

XTypes::TypeObject minimal_to101()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(107, 157, 171, 99))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(175, 93, 205, 154))))));
}

XTypes::TypeObject minimal_to102()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(116, 69, 156, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 4, 100, 213))))));
}

XTypes::TypeObject minimal_to103()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(51, 88, 217, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(106, 125, 250, 119))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(203, 124, 183, 248))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(14, 45, 141, 88))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(226, 148, 42, 4))))));
}

XTypes::TypeObject minimal_to104()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))), XTypes::MinimalMemberDetail(130, 18, 117, 64))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(51, 88, 217, 222))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(106, 125, 250, 119))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))), XTypes::MinimalMemberDetail(202, 13, 242, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(147, 235, 253, 18, 141, 198, 246, 197, 245, 92, 250, 175, 56, 124))), XTypes::MinimalMemberDetail(208, 20, 26, 7))))));
}

XTypes::TypeMap get_minimal_type_map_private()
{
  XTypes::TypeMap tm;
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(0, 236, 19, 180, 137, 206, 245, 92, 185, 48, 236, 164, 76, 231))] = minimal_to0();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(1, 78, 93, 82, 90, 169, 236, 225, 40, 97, 126, 118, 81, 144))] = minimal_to1();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(3, 25, 45, 83, 244, 194, 80, 75, 84, 30, 189, 230, 238, 219))] = minimal_to2();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(8, 72, 1, 219, 209, 130, 97, 88, 183, 75, 190, 192, 122, 99))] = minimal_to3();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))] = minimal_to4();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(12, 146, 216, 130, 44, 156, 246, 196, 95, 35, 157, 166, 171, 143))] = minimal_to5();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(18, 113, 84, 193, 2, 246, 131, 177, 4, 117, 126, 75, 63, 142))] = minimal_to6();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))] = minimal_to7();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(26, 90, 222, 159, 124, 27, 74, 53, 0, 110, 7, 177, 194, 34))] = minimal_to8();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 204, 86, 218, 178, 73, 76, 100, 206, 47, 240, 23, 107, 238))] = minimal_to9();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(27, 247, 209, 52, 65, 35, 253, 153, 236, 85, 203, 16, 40, 240))] = minimal_to10();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(28, 163, 101, 61, 222, 61, 181, 14, 249, 2, 35, 3, 27, 80))] = minimal_to11();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 184, 244, 149, 52, 65, 12, 119, 163, 176, 63, 222, 239, 135))] = minimal_to12();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37))] = minimal_to13();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(37, 118, 24, 23, 239, 173, 163, 127, 104, 159, 172, 143, 54, 229))] = minimal_to14();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(38, 51, 5, 107, 156, 29, 189, 228, 155, 120, 31, 109, 12, 240))] = minimal_to15();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(43, 202, 138, 62, 122, 243, 240, 73, 128, 154, 78, 160, 26, 235))] = minimal_to16();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(47, 136, 233, 191, 112, 193, 42, 150, 67, 246, 172, 37, 197, 132))] = minimal_to17();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 122, 31, 116, 213, 41, 63, 78, 63, 197, 131, 232, 81, 248))] = minimal_to18();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(50, 235, 25, 172, 15, 65, 98, 13, 167, 52, 8, 137, 206, 198))] = minimal_to19();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(55, 33, 86, 126, 128, 2, 32, 173, 145, 239, 112, 171, 236, 133))] = minimal_to20();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))] = minimal_to21();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))] = minimal_to22();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 81, 30, 246, 182, 164, 30, 76, 46, 244, 231, 33, 240, 210))] = minimal_to23();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))] = minimal_to24();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(62, 114, 125, 184, 14, 246, 184, 86, 96, 15, 47, 72, 182, 26))] = minimal_to25();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 132, 84, 128, 187, 1, 123, 173, 187, 231, 55, 190, 22, 206))] = minimal_to26();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))] = minimal_to27();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))] = minimal_to28();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 31, 169, 229, 223, 19, 38, 65, 134, 73, 192, 156, 90, 188))] = minimal_to29();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))] = minimal_to30();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(74, 39, 56, 203, 127, 182, 9, 1, 220, 224, 1, 152, 231, 249))] = minimal_to31();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(78, 228, 180, 27, 81, 71, 76, 201, 151, 212, 238, 77, 239, 150))] = minimal_to32();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(82, 136, 3, 161, 52, 193, 32, 193, 107, 215, 205, 208, 118, 237))] = minimal_to33();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(89, 229, 192, 159, 193, 43, 151, 40, 114, 54, 88, 1, 0, 21))] = minimal_to34();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))] = minimal_to35();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(95, 161, 68, 139, 247, 60, 212, 207, 132, 249, 27, 100, 21, 47))] = minimal_to36();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(99, 164, 202, 7, 10, 4, 116, 207, 251, 120, 151, 82, 190, 72))] = minimal_to37();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))] = minimal_to38();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(102, 170, 145, 4, 80, 244, 15, 54, 224, 255, 110, 254, 204, 151))] = minimal_to39();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(103, 99, 176, 25, 62, 194, 58, 17, 243, 55, 82, 78, 3, 240))] = minimal_to40();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(106, 77, 176, 72, 18, 12, 173, 22, 88, 169, 114, 73, 204, 116))] = minimal_to41();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))] = minimal_to42();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(110, 72, 232, 232, 110, 217, 15, 250, 174, 208, 243, 110, 194, 46))] = minimal_to43();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(111, 0, 172, 23, 200, 153, 190, 187, 205, 142, 149, 204, 41, 21))] = minimal_to44();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(117, 115, 123, 224, 198, 52, 178, 1, 245, 119, 232, 217, 48, 219))] = minimal_to45();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(119, 4, 180, 70, 2, 71, 100, 25, 64, 45, 106, 141, 80, 208))] = minimal_to46();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 124, 74, 82, 33, 209, 171, 154, 100, 92, 69, 182, 34, 215))] = minimal_to47();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))] = minimal_to48();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))] = minimal_to49();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))] = minimal_to50();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(125, 68, 172, 132, 224, 239, 218, 60, 192, 71, 15, 147, 30, 246))] = minimal_to51();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(128, 69, 94, 121, 109, 211, 67, 113, 99, 203, 83, 32, 137, 218))] = minimal_to52();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(133, 22, 18, 238, 85, 223, 209, 176, 88, 48, 223, 166, 156, 212))] = minimal_to53();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(135, 85, 81, 27, 49, 2, 203, 211, 40, 79, 154, 88, 201, 112))] = minimal_to54();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))] = minimal_to55();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))] = minimal_to56();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 175, 77, 37, 194, 231, 136, 170, 53, 228, 31, 45, 86, 160))] = minimal_to57();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(145, 105, 114, 192, 4, 141, 200, 90, 70, 173, 35, 248, 103, 55))] = minimal_to58();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(146, 63, 166, 114, 163, 203, 97, 205, 144, 166, 92, 200, 247, 237))] = minimal_to59();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(147, 176, 57, 236, 194, 129, 36, 216, 44, 165, 133, 49, 248, 141))] = minimal_to60();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(147, 235, 253, 18, 141, 198, 246, 197, 245, 92, 250, 175, 56, 124))] = minimal_to61();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(149, 57, 30, 106, 7, 12, 230, 99, 234, 186, 194, 64, 166, 141))] = minimal_to62();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225))] = minimal_to63();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))] = minimal_to64();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(159, 245, 110, 111, 33, 28, 122, 7, 5, 199, 96, 142, 87, 19))] = minimal_to65();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))] = minimal_to66();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))] = minimal_to67();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(168, 192, 24, 83, 50, 210, 165, 196, 183, 194, 47, 48, 178, 159))] = minimal_to68();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 115, 43, 233, 139, 29, 28, 130, 117, 249, 188, 147, 54, 250))] = minimal_to69();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(173, 51, 47, 234, 23, 87, 166, 82, 211, 40, 79, 240, 240, 111))] = minimal_to70();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(174, 143, 129, 76, 253, 100, 99, 188, 219, 244, 101, 109, 25, 41))] = minimal_to71();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100))] = minimal_to72();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148))] = minimal_to73();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(183, 77, 161, 2, 250, 20, 171, 40, 89, 82, 214, 220, 104, 251))] = minimal_to74();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 18, 77, 133, 10, 184, 210, 12, 27, 14, 223, 163, 116, 74))] = minimal_to75();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(188, 91, 255, 173, 137, 11, 90, 63, 130, 182, 219, 225, 235, 130))] = minimal_to76();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(189, 234, 44, 41, 184, 44, 245, 89, 156, 86, 145, 192, 39, 61))] = minimal_to77();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(196, 35, 144, 119, 219, 90, 67, 131, 234, 152, 218, 209, 208, 105))] = minimal_to78();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(198, 31, 110, 3, 217, 217, 69, 24, 16, 60, 254, 93, 63, 254))] = minimal_to79();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 90, 35, 84, 117, 166, 180, 163, 60, 216, 244, 19, 92, 13))] = minimal_to80();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(202, 165, 200, 168, 60, 12, 23, 106, 127, 63, 129, 60, 104, 33))] = minimal_to81();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))] = minimal_to82();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))] = minimal_to83();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))] = minimal_to84();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(211, 69, 47, 26, 143, 144, 252, 240, 92, 219, 42, 193, 194, 64))] = minimal_to85();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(211, 252, 222, 70, 78, 152, 101, 78, 245, 173, 45, 230, 81, 25))] = minimal_to86();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(212, 19, 36, 204, 216, 207, 229, 8, 101, 152, 15, 215, 71, 23))] = minimal_to87();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(217, 115, 52, 86, 152, 78, 235, 0, 132, 179, 241, 33, 223, 229))] = minimal_to88();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(220, 252, 235, 15, 216, 123, 170, 85, 138, 235, 133, 193, 175, 9))] = minimal_to89();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(222, 70, 220, 15, 61, 238, 235, 97, 172, 112, 61, 247, 50, 154))] = minimal_to90();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(223, 137, 245, 17, 179, 98, 96, 20, 237, 41, 215, 82, 255, 127))] = minimal_to91();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(228, 22, 64, 100, 44, 121, 150, 142, 57, 135, 196, 14, 115, 14))] = minimal_to92();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))] = minimal_to93();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))] = minimal_to94();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(241, 215, 115, 29, 74, 144, 179, 155, 104, 243, 189, 42, 144, 110))] = minimal_to95();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))] = minimal_to96();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))] = minimal_to97();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 87, 237, 35, 153, 167, 62, 144, 213, 193, 96, 70, 214, 135))] = minimal_to98();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))] = minimal_to99();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(251, 95, 64, 60, 163, 23, 170, 158, 193, 148, 167, 7, 12, 36))] = minimal_to100();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(253, 72, 63, 147, 206, 16, 241, 72, 186, 231, 206, 213, 79, 158))] = minimal_to101();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))] = minimal_to102();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 216, 152, 127, 197, 0, 10, 17, 138, 213, 145, 90, 204, 148))] = minimal_to103();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(255, 4, 174, 218, 37, 5, 222, 128, 186, 53, 194, 162, 215, 91))] = minimal_to104();
  return tm;
}

}

const XTypes::TypeMap& get_minimal_type_map()
{
  static XTypes::TypeMap tm;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), tm);
  if (tm.empty()) {
    tm = get_minimal_type_map_private();
  }
  return tm;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

