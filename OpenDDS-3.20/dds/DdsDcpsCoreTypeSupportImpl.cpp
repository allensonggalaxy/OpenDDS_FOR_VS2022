/* Generated by ..\bin\opendds_idl version 3.20.0 (ACE version 6.2a_p23) running on input file DdsDcpsCore.idl */
#include "DCPS/DdsDcps_pch.h"
#include "DdsDcpsCoreTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#ifndef OPENDDS_SAFETY_PROFILE
  #include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#endif
#ifndef OPENDDS_SAFETY_PROFILE
  #include "dds/CorbaSeq/OctetSeqTypeSupportImpl.h"
#endif
#ifndef OPENDDS_SAFETY_PROFILE
  #include "dds/CorbaSeq/ShortSeqTypeSupportImpl.h"
#endif
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/XTypes/TypeObject.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_StringSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57));
  }
  return ti;
}

static const XTypes::TypeMap& get_minimal_type_map();
template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_StringSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::StringSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    primitive_serialized_size_ulong(encoding, size);
    if (seq[i]) {
      size += ACE_OS::strlen(seq[i]) + 1;
    }
  }
}

bool operator<<(Serializer& strm, const  ::DDS::StringSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::DDS::StringSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq.get_buffer()[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::DDS::StringSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar.get_buffer()[0];
;
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::DDS::StringSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar.get_buffer()[0];
;
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::StringSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    ACE_CDR::ULong strlength;
    if (!(ser >> strlength)) return false;
    if (!ser.skip(strlength)) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InstanceHandle_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_InstanceHandle_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InstanceHandleSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(54, 134, 32, 238, 30, 39, 9, 207, 228, 231, 150, 1, 254, 148));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_InstanceHandleSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::InstanceHandleSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  primitive_serialized_size(encoding, size,  ::CORBA::Long(), seq.length());
}

bool operator<<(Serializer& strm, const  ::DDS::InstanceHandleSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm,  ::DDS::InstanceHandleSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::InstanceHandleSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  return ser.skip(length, 4);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_QosPolicyId_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_QosPolicyId_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_QosPolicyCount_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(187, 206, 175, 130, 167, 249, 57, 105, 219, 219, 138, 84, 110, 94));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_QosPolicyCount_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::QosPolicyCount& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"policy_id",0},{"count",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.policy_id)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.count)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::QosPolicyCount& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("policy_id");
  value_writer.write_int32(value.policy_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("count");
  value_writer.write_int32(value.count);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::QosPolicyCount& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.policy_id = 0;
  stru.count = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::QosPolicyCount& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.policy_id);
  primitive_serialized_size(encoding, size, stru.count);
}

bool operator<<(Serializer& strm, const  ::DDS::QosPolicyCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.policy_id)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm,  ::DDS::QosPolicyCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.policy_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::QosPolicyCount>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.policy_id);
  primitive_serialized_size(encoding, size, stru.value.count);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::QosPolicyCount>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.policy_id)
    && (strm << stru.value.count);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::QosPolicyCount>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.policy_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::QosPolicyCount> : MetaStruct {
  typedef  ::DDS::QosPolicyCount T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("policy_id", 0),
      std::make_pair("count", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::QosPolicyCount)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::QosPolicyCount& typed = *static_cast<const  ::DDS::QosPolicyCount*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "policy_id") == 0) {
      return typed.policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return typed.count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::QosPolicyCount)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "policy_id") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'policy_id' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'policy_id' could not be skipped");
      }
    }
    if (base_field == "count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "policy_id") == 0) {
      return make_field_cmp(&T::policy_id, next);
    }
    if (std::strcmp(field, "count") == 0) {
      return make_field_cmp(&T::count, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::QosPolicyCount)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"policy_id", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "policy_id") == 0) {
      return &static_cast<const T*>(stru)->policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::QosPolicyCount)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "policy_id") == 0) {
      static_cast<T*>(lhs)->policy_id = *static_cast<const  ::DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::QosPolicyCount)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "policy_id") == 0) {
      return static_cast<const T*>(lhs)->policy_id == static_cast<const T*>(rhs)->policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return static_cast<const T*>(lhs)->count == static_cast<const T*>(rhs)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::QosPolicyCount)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::QosPolicyCount>()
{
  static MetaStructImpl< ::DDS::QosPolicyCount> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::QosPolicyCount*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::QosPolicyCount>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_QosPolicyCountSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(180, 45, 19, 101, 194, 86, 184, 210, 220, 168, 163, 127, 201, 93));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_QosPolicyCountSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::QosPolicyCountSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::DDS::QosPolicyCountSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::DDS::QosPolicyCountSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::DDS::QosPolicyCountSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::DDS::QosPolicyCountSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::QosPolicyCountSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::DDS::QosPolicyCount*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OctetSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_OctetSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::OctetSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  primitive_serialized_size_octet(encoding, size, seq.length());
}

bool operator<<(Serializer& strm, const  ::DDS::OctetSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_octet_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm,  ::DDS::OctetSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  if (length == 0) {
    return true;
  }
  return strm.read_octet_array(seq.get_buffer(), length);
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::OctetSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  return ser.skip(length, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_Duration_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_Duration_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::Duration_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"sec",0},{"nanosec",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.sec)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.nanosec)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::Duration_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("sec");
  value_writer.write_int32(value.sec);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("nanosec");
  value_writer.write_uint32(value.nanosec);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::Duration_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.sec = 0;
  stru.nanosec = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::Duration_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  primitive_serialized_size(encoding, size, stru.sec);
  primitive_serialized_size(encoding, size, stru.nanosec);
}

bool operator<<(Serializer& strm, const  ::DDS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm << stru.sec)
    && (strm << stru.nanosec);
}

bool operator>>(Serializer& strm,  ::DDS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm >> stru.sec)
    && (strm >> stru.nanosec);
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::Duration_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  primitive_serialized_size(encoding, size, stru.value.sec);
  primitive_serialized_size(encoding, size, stru.value.nanosec);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::Duration_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm << stru.value.sec)
    && (strm << stru.value.nanosec);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::Duration_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm >> stru.value.sec)
    && (strm >> stru.value.nanosec);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::Duration_t> : MetaStruct {
  typedef  ::DDS::Duration_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("sec", 0),
      std::make_pair("nanosec", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Duration_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::Duration_t& typed = *static_cast<const  ::DDS::Duration_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "sec") == 0) {
      return typed.sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return typed.nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Duration_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "sec") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sec' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sec' could not be skipped");
      }
    }
    if (base_field == "nanosec") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'nanosec' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'nanosec' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sec") == 0) {
      return make_field_cmp(&T::sec, next);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return make_field_cmp(&T::nanosec, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Duration_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"sec", "nanosec", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      return &static_cast<const T*>(stru)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return &static_cast<const T*>(stru)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Duration_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sec") == 0) {
      static_cast<T*>(lhs)->sec = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      static_cast<T*>(lhs)->nanosec = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Duration_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sec") == 0) {
      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Duration_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::Duration_t>()
{
  static MetaStructImpl< ::DDS::Duration_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::Duration_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::Duration_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_Property_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(47, 136, 233, 191, 112, 193, 42, 150, 67, 246, 172, 37, 197, 132));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_Property_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::Property_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"name",0},{"value",1},{"propagate",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.name = x.c_str();
      }
      break;
    }
    case 1: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.value = x.c_str();
      }
      break;
    }
    case 2: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.propagate = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::Property_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("name");
  value_writer.write_string(value.name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("value");
  value_writer.write_string(value.value);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("propagate");
  value_writer.write_boolean(value.propagate);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::Property_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.name = "";
  stru.value = "";
  stru.propagate = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::Property_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (stru.propagate) {
    primitive_serialized_size_ulong(encoding, size);
    size += ACE_OS::strlen(stru.name.in()) + 1;
    primitive_serialized_size_ulong(encoding, size);
    size += ACE_OS::strlen(stru.value.in()) + 1;
  }
}

bool operator<<(Serializer& strm, const  ::DDS::Property_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if (stru.propagate) {
    return (strm << stru.name.in()) && (strm << stru.value.in());
  }
  return true;
}

bool operator>>(Serializer& strm,  ::DDS::Property_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  stru.propagate = true;
  return (strm >> stru.name.out()) && (strm >> stru.value.out());
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::Property_t> : MetaStruct {
  typedef  ::DDS::Property_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("name", 0),
      std::make_pair("value", 1),
      std::make_pair("propagate", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Property_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::Property_t& typed = *static_cast<const  ::DDS::Property_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    if (std::strcmp(field, "value") == 0) {
      return typed.value.in();
    }
    if (std::strcmp(field, "propagate") == 0) {
      return typed.propagate;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Property_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (base_field == "value") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'value' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'value' contents could not be skipped");
      }
    }
    if (base_field == "propagate") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'propagate' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'propagate' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    if (std::strcmp(field, "propagate") == 0) {
      return make_field_cmp(&T::propagate, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Property_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"name", "value", "propagate", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    if (std::strcmp(field, "propagate") == 0) {
      return &static_cast<const T*>(stru)->propagate;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Property_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "propagate") == 0) {
      static_cast<T*>(lhs)->propagate = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Property_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    if (std::strcmp(field, "value") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->value.in(), static_cast<const T*>(rhs)->value.in());
    }
    if (std::strcmp(field, "propagate") == 0) {
      return static_cast<const T*>(lhs)->propagate == static_cast<const T*>(rhs)->propagate;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Property_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::Property_t>()
{
  static MetaStructImpl< ::DDS::Property_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::Property_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::Property_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PropertySeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(106, 77, 176, 72, 18, 12, 173, 22, 88, 169, 114, 73, 204, 116));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_PropertySeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PropertySeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  primitive_serialized_size_ulong(encoding, size);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::DDS::PropertySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong serlen = 0;
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i].propagate) {
      ++serlen;
    }
  }
  if (!(strm << serlen)) {
    return false;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::DDS::PropertySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::PropertySeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::DDS::Property_t*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_BinaryProperty_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(251, 95, 64, 60, 163, 23, 170, 158, 193, 148, 167, 7, 12, 36));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_BinaryProperty_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::BinaryProperty_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"name",0},{"value",1},{"propagate",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.name = x.c_str();
      }
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.value);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.value[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 2: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.propagate = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::BinaryProperty_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("name");
  value_writer.write_string(value.name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("value");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.value.get_buffer(), value.value.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("propagate");
  value_writer.write_boolean(value.propagate);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::BinaryProperty_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.name = "";
  stru.value.length(0);
  stru.propagate = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::BinaryProperty_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (stru.propagate) {
    primitive_serialized_size_ulong(encoding, size);
    size += ACE_OS::strlen(stru.name.in()) + 1;
    serialized_size(encoding, size, stru.value);
  }
}

bool operator<<(Serializer& strm, const  ::DDS::BinaryProperty_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if (stru.propagate) {
    return (strm << stru.name.in()) && (strm << stru.value);
  }
  return true;
}

bool operator>>(Serializer& strm,  ::DDS::BinaryProperty_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  stru.propagate = true;
  return (strm >> stru.name.out()) && (strm >> stru.value);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::BinaryProperty_t> : MetaStruct {
  typedef  ::DDS::BinaryProperty_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("name", 0),
      std::make_pair("value", 1),
      std::make_pair("propagate", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BinaryProperty_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::BinaryProperty_t& typed = *static_cast<const  ::DDS::BinaryProperty_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    if (std::strcmp(field, "propagate") == 0) {
      return typed.propagate;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BinaryProperty_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "propagate") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'propagate' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'propagate' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    if (std::strcmp(field, "propagate") == 0) {
      return make_field_cmp(&T::propagate, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BinaryProperty_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"name", "value", "propagate", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    if (std::strcmp(field, "propagate") == 0) {
      return &static_cast<const T*>(stru)->propagate;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BinaryProperty_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "propagate") == 0) {
      static_cast<T*>(lhs)->propagate = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BinaryProperty_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    if (std::strcmp(field, "propagate") == 0) {
      return static_cast<const T*>(lhs)->propagate == static_cast<const T*>(rhs)->propagate;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BinaryProperty_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::BinaryProperty_t>()
{
  static MetaStructImpl< ::DDS::BinaryProperty_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::BinaryProperty_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::BinaryProperty_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_BinaryPropertySeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(125, 68, 172, 132, 224, 239, 218, 60, 192, 71, 15, 147, 30, 246));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_BinaryPropertySeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::BinaryPropertySeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  primitive_serialized_size_ulong(encoding, size);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::DDS::BinaryPropertySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong serlen = 0;
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i].propagate) {
      ++serlen;
    }
  }
  if (!(strm << serlen)) {
    return false;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::DDS::BinaryPropertySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::BinaryPropertySeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::DDS::BinaryProperty_t*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PropertyQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(74, 39, 56, 203, 127, 182, 9, 1, 220, 224, 1, 152, 231, 249));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_PropertyQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PropertyQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{"binary_value",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.value);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.value[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.binary_value);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.binary_value[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PropertyQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.value.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.value[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("binary_value");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.binary_value.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.binary_value[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::PropertyQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value.length(0);
  stru.binary_value.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PropertyQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  serialized_size(encoding, size, stru.value);
  serialized_size(encoding, size, stru.binary_value);
}

bool operator<<(Serializer& strm, const  ::DDS::PropertyQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value)
    && (strm << stru.binary_value);
}

bool operator>>(Serializer& strm,  ::DDS::PropertyQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if (!(strm >> stru.value)) {
    return false;
  }
  if (!strm.length() || !strm.skip(0, 4) || !strm.length()) {
    return true; // optional member missing
  }
  return strm >> stru.binary_value;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::PropertyQosPolicy> : MetaStruct {
  typedef  ::DDS::PropertyQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
      std::make_pair("binary_value", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PropertyQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::PropertyQosPolicy& typed = *static_cast<const  ::DDS::PropertyQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PropertyQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::PropertySeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::BinaryPropertySeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PropertyQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", "binary_value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    if (std::strcmp(field, "binary_value") == 0) {
      return &static_cast<const T*>(stru)->binary_value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PropertyQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::DDS::PropertySeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "binary_value") == 0) {
      static_cast<T*>(lhs)->binary_value = *static_cast<const  ::DDS::BinaryPropertySeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PropertyQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PropertyQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::PropertyQosPolicy>()
{
  static MetaStructImpl< ::DDS::PropertyQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::PropertyQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::PropertyQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_UserDataQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_UserDataQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::UserDataQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.value);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.value[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::UserDataQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.value.get_buffer(), value.value.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::UserDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::UserDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::DDS::UserDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::DDS::UserDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::UserDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::UserDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::UserDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::UserDataQosPolicy> : MetaStruct {
  typedef  ::DDS::UserDataQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::UserDataQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::UserDataQosPolicy& typed = *static_cast<const  ::DDS::UserDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::UserDataQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::UserDataQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::UserDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::UserDataQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::UserDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::UserDataQosPolicy>()
{
  static MetaStructImpl< ::DDS::UserDataQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::UserDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::UserDataQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_GroupDataQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_GroupDataQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::GroupDataQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.value);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.value[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::GroupDataQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.value.get_buffer(), value.value.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::GroupDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::GroupDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::DDS::GroupDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::DDS::GroupDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::GroupDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::GroupDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::GroupDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::GroupDataQosPolicy> : MetaStruct {
  typedef  ::DDS::GroupDataQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::GroupDataQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::GroupDataQosPolicy& typed = *static_cast<const  ::DDS::GroupDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::GroupDataQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::GroupDataQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::GroupDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::GroupDataQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::GroupDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::GroupDataQosPolicy>()
{
  static MetaStructImpl< ::DDS::GroupDataQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::GroupDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::GroupDataQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TopicDataQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_TopicDataQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TopicDataQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.value);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_byte(value.value[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TopicDataQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.begin_sequence();
  value_writer.write_byte_array (value.value.get_buffer(), value.value.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::TopicDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::TopicDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::DDS::TopicDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::DDS::TopicDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::TopicDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::TopicDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TopicDataQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::TopicDataQosPolicy> : MetaStruct {
  typedef  ::DDS::TopicDataQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicDataQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::TopicDataQosPolicy& typed = *static_cast<const  ::DDS::TopicDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicDataQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicDataQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicDataQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::TopicDataQosPolicy>()
{
  static MetaStructImpl< ::DDS::TopicDataQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::TopicDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::TopicDataQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PartitionQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_PartitionQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PartitionQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"name",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.name);
        if (!value_reader.begin_element()) return false;
        {
          String x;
          if (!value_reader.read_string(x)) return false;
          value.name[i] = x.c_str();
        }
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PartitionQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("name");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.name.length(); ++i) {
    value_writer.begin_element(i);
    value_writer.write_string(value.name[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::PartitionQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.name.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PartitionQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.name);
}

bool operator<<(Serializer& strm, const  ::DDS::PartitionQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.name);
}

bool operator>>(Serializer& strm,  ::DDS::PartitionQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.name)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::PartitionQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.name);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::PartitionQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.name);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PartitionQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.name)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::PartitionQosPolicy> : MetaStruct {
  typedef  ::DDS::PartitionQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("name", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PartitionQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::PartitionQosPolicy& typed = *static_cast<const  ::DDS::PartitionQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PartitionQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::StringSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PartitionQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"name", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PartitionQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const  ::DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PartitionQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PartitionQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::PartitionQosPolicy>()
{
  static MetaStructImpl< ::DDS::PartitionQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::PartitionQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::PartitionQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_HistoryQosPolicyKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_HistoryQosPolicyKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::HistoryQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"KEEP_LAST_HISTORY_QOS",0},{"KEEP_ALL_HISTORY_QOS",1},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::HistoryQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case DDS::KEEP_LAST_HISTORY_QOS:
    value_writer.write_enum("KEEP_LAST_HISTORY_QOS", DDS::KEEP_LAST_HISTORY_QOS);
    break;
  case DDS::KEEP_ALL_HISTORY_QOS:
    value_writer.write_enum("KEEP_ALL_HISTORY_QOS", DDS::KEEP_ALL_HISTORY_QOS);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::DDS::HistoryQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 2) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::DDS::HistoryQosPolicyKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::DDS::HistoryQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 2) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::DDS::HistoryQosPolicyKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_HistoryQosPolicyKind_names[] = {
  "KEEP_LAST_HISTORY_QOS",
  "KEEP_ALL_HISTORY_QOS"
};
const size_t gen_DDS_HistoryQosPolicyKind_names_size = 2;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DurabilityQosPolicyKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(62, 114, 125, 184, 14, 246, 184, 86, 96, 15, 47, 72, 182, 26));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DurabilityQosPolicyKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DurabilityQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"VOLATILE_DURABILITY_QOS",0},{"TRANSIENT_LOCAL_DURABILITY_QOS",1},{"TRANSIENT_DURABILITY_QOS",2},{"PERSISTENT_DURABILITY_QOS",3},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DurabilityQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case DDS::VOLATILE_DURABILITY_QOS:
    value_writer.write_enum("VOLATILE_DURABILITY_QOS", DDS::VOLATILE_DURABILITY_QOS);
    break;
  case DDS::TRANSIENT_LOCAL_DURABILITY_QOS:
    value_writer.write_enum("TRANSIENT_LOCAL_DURABILITY_QOS", DDS::TRANSIENT_LOCAL_DURABILITY_QOS);
    break;
  case DDS::TRANSIENT_DURABILITY_QOS:
    value_writer.write_enum("TRANSIENT_DURABILITY_QOS", DDS::TRANSIENT_DURABILITY_QOS);
    break;
  case DDS::PERSISTENT_DURABILITY_QOS:
    value_writer.write_enum("PERSISTENT_DURABILITY_QOS", DDS::PERSISTENT_DURABILITY_QOS);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::DDS::DurabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 4) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::DDS::DurabilityQosPolicyKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::DDS::DurabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 4) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::DDS::DurabilityQosPolicyKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_DurabilityQosPolicyKind_names[] = {
  "VOLATILE_DURABILITY_QOS",
  "TRANSIENT_LOCAL_DURABILITY_QOS",
  "TRANSIENT_DURABILITY_QOS",
  "PERSISTENT_DURABILITY_QOS"
};
const size_t gen_DDS_DurabilityQosPolicyKind_names_size = 4;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DurabilityQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DurabilityQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DurabilityQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.kind)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DurabilityQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  vwrite(value_writer, value.kind);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DurabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.kind =  ::DDS::VOLATILE_DURABILITY_QOS;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DurabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
}

bool operator<<(Serializer& strm, const  ::DDS::DurabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm,  ::DDS::DurabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DurabilityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DurabilityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.kind);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DurabilityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DurabilityQosPolicy> : MetaStruct {
  typedef  ::DDS::DurabilityQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DurabilityQosPolicy& typed = *static_cast<const  ::DDS::DurabilityQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_DurabilityQosPolicyKind_names[typed.kind];
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::DDS::DurabilityQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DurabilityQosPolicy>()
{
  static MetaStructImpl< ::DDS::DurabilityQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DurabilityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DurabilityQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DurabilityServiceQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DurabilityServiceQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DurabilityServiceQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"service_cleanup_delay",0},{"history_kind",1},{"history_depth",2},{"max_samples",3},{"max_instances",4},{"max_samples_per_instance",5},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.service_cleanup_delay)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.history_kind)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.history_depth)) return false;
      break;
    }
    case 3: {
      if (!value_reader.read_int32(value.max_samples)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_int32(value.max_instances)) return false;
      break;
    }
    case 5: {
      if (!value_reader.read_int32(value.max_samples_per_instance)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DurabilityServiceQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("service_cleanup_delay");
  vwrite(value_writer, value.service_cleanup_delay);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("history_kind");
  vwrite(value_writer, value.history_kind);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("history_depth");
  value_writer.write_int32(value.history_depth);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_samples");
  value_writer.write_int32(value.max_samples);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_instances");
  value_writer.write_int32(value.max_instances);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_samples_per_instance");
  value_writer.write_int32(value.max_samples_per_instance);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DurabilityServiceQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.service_cleanup_delay);
  stru.history_kind =  ::DDS::KEEP_LAST_HISTORY_QOS;
  stru.history_depth = 0;
  stru.max_samples = 0;
  stru.max_instances = 0;
  stru.max_samples_per_instance = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DurabilityServiceQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.service_cleanup_delay);
  primitive_serialized_size_ulong(encoding, size);
  primitive_serialized_size(encoding, size, stru.history_depth);
  primitive_serialized_size(encoding, size, stru.max_samples);
  primitive_serialized_size(encoding, size, stru.max_instances);
  primitive_serialized_size(encoding, size, stru.max_samples_per_instance);
}

bool operator<<(Serializer& strm, const  ::DDS::DurabilityServiceQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.service_cleanup_delay)
    && (strm << stru.history_kind)
    && (strm << stru.history_depth)
    && (strm << stru.max_samples)
    && (strm << stru.max_instances)
    && (strm << stru.max_samples_per_instance);
}

bool operator>>(Serializer& strm,  ::DDS::DurabilityServiceQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.service_cleanup_delay)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.history_kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.history_depth)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.max_samples)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.max_instances)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.max_samples_per_instance)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DurabilityServiceQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.service_cleanup_delay);
  primitive_serialized_size_ulong(encoding, size);
  primitive_serialized_size(encoding, size, stru.value.history_depth);
  primitive_serialized_size(encoding, size, stru.value.max_samples);
  primitive_serialized_size(encoding, size, stru.value.max_instances);
  primitive_serialized_size(encoding, size, stru.value.max_samples_per_instance);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DurabilityServiceQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.service_cleanup_delay)
    && (strm << stru.value.history_kind)
    && (strm << stru.value.history_depth)
    && (strm << stru.value.max_samples)
    && (strm << stru.value.max_instances)
    && (strm << stru.value.max_samples_per_instance);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DurabilityServiceQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.service_cleanup_delay)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.history_kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.history_depth)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.max_samples)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.max_instances)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.max_samples_per_instance)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DurabilityServiceQosPolicy> : MetaStruct {
  typedef  ::DDS::DurabilityServiceQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("service_cleanup_delay", 0),
      std::make_pair("history_kind", 1),
      std::make_pair("history_depth", 2),
      std::make_pair("max_samples", 3),
      std::make_pair("max_instances", 4),
      std::make_pair("max_samples_per_instance", 5),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 6);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityServiceQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DurabilityServiceQosPolicy& typed = *static_cast<const  ::DDS::DurabilityServiceQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.service_cleanup_delay, field + 22);
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return gen_DDS_HistoryQosPolicyKind_names[typed.history_kind];
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return typed.history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return typed.max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return typed.max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return typed.max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityServiceQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "service_cleanup_delay") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'service_cleanup_delay' could not be skipped");
      }
    }
    if (base_field == "history_kind") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'history_kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'history_kind' could not be skipped");
      }
    }
    if (base_field == "history_depth") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'history_depth' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'history_depth' could not be skipped");
      }
    }
    if (base_field == "max_samples") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_samples' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_samples' could not be skipped");
      }
    }
    if (base_field == "max_instances") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_instances' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_instances' could not be skipped");
      }
    }
    if (base_field == "max_samples_per_instance") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_samples_per_instance' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_samples_per_instance' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
      return make_struct_cmp(&T::service_cleanup_delay, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 22), next);
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return make_field_cmp(&T::history_kind, next);
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return make_field_cmp(&T::history_depth, next);
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return make_field_cmp(&T::max_samples, next);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return make_field_cmp(&T::max_instances, next);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return make_field_cmp(&T::max_samples_per_instance, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityServiceQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"service_cleanup_delay", "history_kind", "history_depth", "max_samples", "max_instances", "max_samples_per_instance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "service_cleanup_delay") == 0) {
      return &static_cast<const T*>(stru)->service_cleanup_delay;
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return &static_cast<const T*>(stru)->history_kind;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return &static_cast<const T*>(stru)->history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return &static_cast<const T*>(stru)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return &static_cast<const T*>(stru)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return &static_cast<const T*>(stru)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityServiceQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "service_cleanup_delay") == 0) {
      static_cast<T*>(lhs)->service_cleanup_delay = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history_kind") == 0) {
      static_cast<T*>(lhs)->history_kind = *static_cast<const  ::DDS::HistoryQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      static_cast<T*>(lhs)->history_depth = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      static_cast<T*>(lhs)->max_samples = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      static_cast<T*>(lhs)->max_instances = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      static_cast<T*>(lhs)->max_samples_per_instance = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityServiceQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "history_kind") == 0) {
      return static_cast<const T*>(lhs)->history_kind == static_cast<const T*>(rhs)->history_kind;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return static_cast<const T*>(lhs)->history_depth == static_cast<const T*>(rhs)->history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return static_cast<const T*>(lhs)->max_samples == static_cast<const T*>(rhs)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return static_cast<const T*>(lhs)->max_instances == static_cast<const T*>(rhs)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return static_cast<const T*>(lhs)->max_samples_per_instance == static_cast<const T*>(rhs)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DurabilityServiceQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DurabilityServiceQosPolicy>()
{
  static MetaStructImpl< ::DDS::DurabilityServiceQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DurabilityServiceQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DurabilityServiceQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DeadlineQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DeadlineQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DeadlineQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"period",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.period)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DeadlineQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("period");
  vwrite(value_writer, value.period);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DeadlineQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.period);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DeadlineQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.period);
}

bool operator<<(Serializer& strm, const  ::DDS::DeadlineQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.period);
}

bool operator>>(Serializer& strm,  ::DDS::DeadlineQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.period)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DeadlineQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.period);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DeadlineQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.period);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DeadlineQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.period)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DeadlineQosPolicy> : MetaStruct {
  typedef  ::DDS::DeadlineQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("period", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DeadlineQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DeadlineQosPolicy& typed = *static_cast<const  ::DDS::DeadlineQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "period.", 7) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.period, field + 7);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DeadlineQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "period") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'period' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "period.", 7) == 0) {
      return make_struct_cmp(&T::period, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 7), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DeadlineQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"period", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "period") == 0) {
      return &static_cast<const T*>(stru)->period;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DeadlineQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "period") == 0) {
      static_cast<T*>(lhs)->period = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DeadlineQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DeadlineQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DeadlineQosPolicy>()
{
  static MetaStructImpl< ::DDS::DeadlineQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DeadlineQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DeadlineQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LatencyBudgetQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_LatencyBudgetQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LatencyBudgetQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"duration",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.duration)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LatencyBudgetQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("duration");
  vwrite(value_writer, value.duration);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::LatencyBudgetQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.duration);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::LatencyBudgetQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.duration);
}

bool operator<<(Serializer& strm, const  ::DDS::LatencyBudgetQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.duration);
}

bool operator>>(Serializer& strm,  ::DDS::LatencyBudgetQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.duration)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::LatencyBudgetQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.duration);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::LatencyBudgetQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.duration);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::LatencyBudgetQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.duration)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::LatencyBudgetQosPolicy> : MetaStruct {
  typedef  ::DDS::LatencyBudgetQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("duration", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LatencyBudgetQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::LatencyBudgetQosPolicy& typed = *static_cast<const  ::DDS::LatencyBudgetQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.duration, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LatencyBudgetQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "duration") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'duration' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return make_struct_cmp(&T::duration, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LatencyBudgetQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "duration") == 0) {
      return &static_cast<const T*>(stru)->duration;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LatencyBudgetQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "duration") == 0) {
      static_cast<T*>(lhs)->duration = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LatencyBudgetQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LatencyBudgetQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::LatencyBudgetQosPolicy>()
{
  static MetaStructImpl< ::DDS::LatencyBudgetQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::LatencyBudgetQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::LatencyBudgetQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LivelinessQosPolicyKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(1, 78, 93, 82, 90, 169, 236, 225, 40, 97, 126, 118, 81, 144));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_LivelinessQosPolicyKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LivelinessQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"AUTOMATIC_LIVELINESS_QOS",0},{"MANUAL_BY_PARTICIPANT_LIVELINESS_QOS",1},{"MANUAL_BY_TOPIC_LIVELINESS_QOS",2},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LivelinessQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case DDS::AUTOMATIC_LIVELINESS_QOS:
    value_writer.write_enum("AUTOMATIC_LIVELINESS_QOS", DDS::AUTOMATIC_LIVELINESS_QOS);
    break;
  case DDS::MANUAL_BY_PARTICIPANT_LIVELINESS_QOS:
    value_writer.write_enum("MANUAL_BY_PARTICIPANT_LIVELINESS_QOS", DDS::MANUAL_BY_PARTICIPANT_LIVELINESS_QOS);
    break;
  case DDS::MANUAL_BY_TOPIC_LIVELINESS_QOS:
    value_writer.write_enum("MANUAL_BY_TOPIC_LIVELINESS_QOS", DDS::MANUAL_BY_TOPIC_LIVELINESS_QOS);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::DDS::LivelinessQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 3) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::DDS::LivelinessQosPolicyKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::DDS::LivelinessQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 3) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::DDS::LivelinessQosPolicyKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_LivelinessQosPolicyKind_names[] = {
  "AUTOMATIC_LIVELINESS_QOS",
  "MANUAL_BY_PARTICIPANT_LIVELINESS_QOS",
  "MANUAL_BY_TOPIC_LIVELINESS_QOS"
};
const size_t gen_DDS_LivelinessQosPolicyKind_names_size = 3;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LivelinessQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_LivelinessQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LivelinessQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{"lease_duration",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.kind)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.lease_duration)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LivelinessQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  vwrite(value_writer, value.kind);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("lease_duration");
  vwrite(value_writer, value.lease_duration);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::LivelinessQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.kind =  ::DDS::AUTOMATIC_LIVELINESS_QOS;
  set_default(stru.lease_duration);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::LivelinessQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  serialized_size(encoding, size, stru.lease_duration);
}

bool operator<<(Serializer& strm, const  ::DDS::LivelinessQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.kind)
    && (strm << stru.lease_duration);
}

bool operator>>(Serializer& strm,  ::DDS::LivelinessQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.lease_duration)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::LivelinessQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  serialized_size(encoding, size, stru.value.lease_duration);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::LivelinessQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.kind)
    && (strm << stru.value.lease_duration);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::LivelinessQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.lease_duration)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::LivelinessQosPolicy> : MetaStruct {
  typedef  ::DDS::LivelinessQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
      std::make_pair("lease_duration", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::LivelinessQosPolicy& typed = *static_cast<const  ::DDS::LivelinessQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_LivelinessQosPolicyKind_names[typed.kind];
    }
    if (std::strncmp(field, "lease_duration.", 15) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.lease_duration, field + 15);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (base_field == "lease_duration") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'lease_duration' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strncmp(field, "lease_duration.", 15) == 0) {
      return make_struct_cmp(&T::lease_duration, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "lease_duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "lease_duration") == 0) {
      return &static_cast<const T*>(stru)->lease_duration;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::DDS::LivelinessQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lease_duration") == 0) {
      static_cast<T*>(lhs)->lease_duration = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LivelinessQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::LivelinessQosPolicy>()
{
  static MetaStructImpl< ::DDS::LivelinessQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::LivelinessQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::LivelinessQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ReliabilityQosPolicyKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 115, 43, 233, 139, 29, 28, 130, 117, 249, 188, 147, 54, 250));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_ReliabilityQosPolicyKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ReliabilityQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"BEST_EFFORT_RELIABILITY_QOS",0},{"RELIABLE_RELIABILITY_QOS",1},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ReliabilityQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case DDS::BEST_EFFORT_RELIABILITY_QOS:
    value_writer.write_enum("BEST_EFFORT_RELIABILITY_QOS", DDS::BEST_EFFORT_RELIABILITY_QOS);
    break;
  case DDS::RELIABLE_RELIABILITY_QOS:
    value_writer.write_enum("RELIABLE_RELIABILITY_QOS", DDS::RELIABLE_RELIABILITY_QOS);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::DDS::ReliabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 2) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::DDS::ReliabilityQosPolicyKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::DDS::ReliabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 2) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::DDS::ReliabilityQosPolicyKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_ReliabilityQosPolicyKind_names[] = {
  "BEST_EFFORT_RELIABILITY_QOS",
  "RELIABLE_RELIABILITY_QOS"
};
const size_t gen_DDS_ReliabilityQosPolicyKind_names_size = 2;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ReliabilityQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_ReliabilityQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ReliabilityQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{"max_blocking_time",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.kind)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.max_blocking_time)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ReliabilityQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  vwrite(value_writer, value.kind);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_blocking_time");
  vwrite(value_writer, value.max_blocking_time);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::ReliabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.kind =  ::DDS::BEST_EFFORT_RELIABILITY_QOS;
  set_default(stru.max_blocking_time);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::ReliabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  serialized_size(encoding, size, stru.max_blocking_time);
}

bool operator<<(Serializer& strm, const  ::DDS::ReliabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.kind)
    && (strm << stru.max_blocking_time);
}

bool operator>>(Serializer& strm,  ::DDS::ReliabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.max_blocking_time)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::ReliabilityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  serialized_size(encoding, size, stru.value.max_blocking_time);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::ReliabilityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.kind)
    && (strm << stru.value.max_blocking_time);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::ReliabilityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.max_blocking_time)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::ReliabilityQosPolicy> : MetaStruct {
  typedef  ::DDS::ReliabilityQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
      std::make_pair("max_blocking_time", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReliabilityQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::ReliabilityQosPolicy& typed = *static_cast<const  ::DDS::ReliabilityQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_ReliabilityQosPolicyKind_names[typed.kind];
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.max_blocking_time, field + 18);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReliabilityQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (base_field == "max_blocking_time") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'max_blocking_time' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return make_struct_cmp(&T::max_blocking_time, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 18), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReliabilityQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "max_blocking_time", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "max_blocking_time") == 0) {
      return &static_cast<const T*>(stru)->max_blocking_time;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReliabilityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::DDS::ReliabilityQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_blocking_time") == 0) {
      static_cast<T*>(lhs)->max_blocking_time = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReliabilityQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReliabilityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::ReliabilityQosPolicy>()
{
  static MetaStructImpl< ::DDS::ReliabilityQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::ReliabilityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::ReliabilityQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DestinationOrderQosPolicyKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(212, 19, 36, 204, 216, 207, 229, 8, 101, 152, 15, 215, 71, 23));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DestinationOrderQosPolicyKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DestinationOrderQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS",0},{"BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS",1},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DestinationOrderQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case DDS::BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS:
    value_writer.write_enum("BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS", DDS::BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS);
    break;
  case DDS::BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS:
    value_writer.write_enum("BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS", DDS::BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::DDS::DestinationOrderQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 2) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::DDS::DestinationOrderQosPolicyKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::DDS::DestinationOrderQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 2) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::DDS::DestinationOrderQosPolicyKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_DestinationOrderQosPolicyKind_names[] = {
  "BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS",
  "BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS"
};
const size_t gen_DDS_DestinationOrderQosPolicyKind_names_size = 2;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DestinationOrderQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DestinationOrderQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DestinationOrderQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.kind)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DestinationOrderQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  vwrite(value_writer, value.kind);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DestinationOrderQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.kind =  ::DDS::BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DestinationOrderQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
}

bool operator<<(Serializer& strm, const  ::DDS::DestinationOrderQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm,  ::DDS::DestinationOrderQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DestinationOrderQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DestinationOrderQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.kind);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DestinationOrderQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DestinationOrderQosPolicy> : MetaStruct {
  typedef  ::DDS::DestinationOrderQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DestinationOrderQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DestinationOrderQosPolicy& typed = *static_cast<const  ::DDS::DestinationOrderQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_DestinationOrderQosPolicyKind_names[typed.kind];
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DestinationOrderQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DestinationOrderQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DestinationOrderQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::DDS::DestinationOrderQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DestinationOrderQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DestinationOrderQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DestinationOrderQosPolicy>()
{
  static MetaStructImpl< ::DDS::DestinationOrderQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DestinationOrderQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DestinationOrderQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_HistoryQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_HistoryQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::HistoryQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{"depth",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.kind)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.depth)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::HistoryQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  vwrite(value_writer, value.kind);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("depth");
  value_writer.write_int32(value.depth);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::HistoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.kind =  ::DDS::KEEP_LAST_HISTORY_QOS;
  stru.depth = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::HistoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  primitive_serialized_size(encoding, size, stru.depth);
}

bool operator<<(Serializer& strm, const  ::DDS::HistoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.kind)
    && (strm << stru.depth);
}

bool operator>>(Serializer& strm,  ::DDS::HistoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.depth)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::HistoryQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  primitive_serialized_size(encoding, size, stru.value.depth);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::HistoryQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.kind)
    && (strm << stru.value.depth);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::HistoryQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.depth)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::HistoryQosPolicy> : MetaStruct {
  typedef  ::DDS::HistoryQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
      std::make_pair("depth", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::HistoryQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::HistoryQosPolicy& typed = *static_cast<const  ::DDS::HistoryQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_HistoryQosPolicyKind_names[typed.kind];
    }
    if (std::strcmp(field, "depth") == 0) {
      return typed.depth;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::HistoryQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (base_field == "depth") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'depth' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'depth' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strcmp(field, "depth") == 0) {
      return make_field_cmp(&T::depth, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::HistoryQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "depth", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "depth") == 0) {
      return &static_cast<const T*>(stru)->depth;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::HistoryQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::DDS::HistoryQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "depth") == 0) {
      static_cast<T*>(lhs)->depth = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::HistoryQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    if (std::strcmp(field, "depth") == 0) {
      return static_cast<const T*>(lhs)->depth == static_cast<const T*>(rhs)->depth;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::HistoryQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::HistoryQosPolicy>()
{
  static MetaStructImpl< ::DDS::HistoryQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::HistoryQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::HistoryQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ResourceLimitsQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_ResourceLimitsQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ResourceLimitsQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"max_samples",0},{"max_instances",1},{"max_samples_per_instance",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.max_samples)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.max_instances)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_int32(value.max_samples_per_instance)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ResourceLimitsQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("max_samples");
  value_writer.write_int32(value.max_samples);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_instances");
  value_writer.write_int32(value.max_instances);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_samples_per_instance");
  value_writer.write_int32(value.max_samples_per_instance);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::ResourceLimitsQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.max_samples = 0;
  stru.max_instances = 0;
  stru.max_samples_per_instance = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::ResourceLimitsQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.max_samples);
  primitive_serialized_size(encoding, size, stru.max_instances);
  primitive_serialized_size(encoding, size, stru.max_samples_per_instance);
}

bool operator<<(Serializer& strm, const  ::DDS::ResourceLimitsQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.max_samples)
    && (strm << stru.max_instances)
    && (strm << stru.max_samples_per_instance);
}

bool operator>>(Serializer& strm,  ::DDS::ResourceLimitsQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.max_samples)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.max_instances)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.max_samples_per_instance)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::ResourceLimitsQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.max_samples);
  primitive_serialized_size(encoding, size, stru.value.max_instances);
  primitive_serialized_size(encoding, size, stru.value.max_samples_per_instance);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::ResourceLimitsQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.max_samples)
    && (strm << stru.value.max_instances)
    && (strm << stru.value.max_samples_per_instance);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::ResourceLimitsQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.max_samples)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.max_instances)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.max_samples_per_instance)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::ResourceLimitsQosPolicy> : MetaStruct {
  typedef  ::DDS::ResourceLimitsQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("max_samples", 0),
      std::make_pair("max_instances", 1),
      std::make_pair("max_samples_per_instance", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ResourceLimitsQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::ResourceLimitsQosPolicy& typed = *static_cast<const  ::DDS::ResourceLimitsQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "max_samples") == 0) {
      return typed.max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return typed.max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return typed.max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ResourceLimitsQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "max_samples") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_samples' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_samples' could not be skipped");
      }
    }
    if (base_field == "max_instances") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_instances' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_instances' could not be skipped");
      }
    }
    if (base_field == "max_samples_per_instance") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_samples_per_instance' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_samples_per_instance' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "max_samples") == 0) {
      return make_field_cmp(&T::max_samples, next);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return make_field_cmp(&T::max_instances, next);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return make_field_cmp(&T::max_samples_per_instance, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ResourceLimitsQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"max_samples", "max_instances", "max_samples_per_instance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "max_samples") == 0) {
      return &static_cast<const T*>(stru)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return &static_cast<const T*>(stru)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return &static_cast<const T*>(stru)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ResourceLimitsQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "max_samples") == 0) {
      static_cast<T*>(lhs)->max_samples = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      static_cast<T*>(lhs)->max_instances = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      static_cast<T*>(lhs)->max_samples_per_instance = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ResourceLimitsQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "max_samples") == 0) {
      return static_cast<const T*>(lhs)->max_samples == static_cast<const T*>(rhs)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return static_cast<const T*>(lhs)->max_instances == static_cast<const T*>(rhs)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return static_cast<const T*>(lhs)->max_samples_per_instance == static_cast<const T*>(rhs)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ResourceLimitsQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::ResourceLimitsQosPolicy>()
{
  static MetaStructImpl< ::DDS::ResourceLimitsQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::ResourceLimitsQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::ResourceLimitsQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TransportPriorityQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_TransportPriorityQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TransportPriorityQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.value)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TransportPriorityQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.write_int32(value.value);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::TransportPriorityQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::TransportPriorityQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::DDS::TransportPriorityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::DDS::TransportPriorityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::TransportPriorityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::TransportPriorityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TransportPriorityQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::TransportPriorityQosPolicy> : MetaStruct {
  typedef  ::DDS::TransportPriorityQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TransportPriorityQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::TransportPriorityQosPolicy& typed = *static_cast<const  ::DDS::TransportPriorityQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TransportPriorityQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "value") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TransportPriorityQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TransportPriorityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TransportPriorityQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TransportPriorityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::TransportPriorityQosPolicy>()
{
  static MetaStructImpl< ::DDS::TransportPriorityQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::TransportPriorityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::TransportPriorityQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LifespanQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_LifespanQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LifespanQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"duration",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.duration)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LifespanQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("duration");
  vwrite(value_writer, value.duration);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::LifespanQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.duration);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::LifespanQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.duration);
}

bool operator<<(Serializer& strm, const  ::DDS::LifespanQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.duration);
}

bool operator>>(Serializer& strm,  ::DDS::LifespanQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.duration)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::LifespanQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.duration);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::LifespanQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.duration);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::LifespanQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.duration)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::LifespanQosPolicy> : MetaStruct {
  typedef  ::DDS::LifespanQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("duration", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LifespanQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::LifespanQosPolicy& typed = *static_cast<const  ::DDS::LifespanQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.duration, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LifespanQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "duration") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'duration' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return make_struct_cmp(&T::duration, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LifespanQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "duration") == 0) {
      return &static_cast<const T*>(stru)->duration;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LifespanQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "duration") == 0) {
      static_cast<T*>(lhs)->duration = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LifespanQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::LifespanQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::LifespanQosPolicy>()
{
  static MetaStructImpl< ::DDS::LifespanQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::LifespanQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::LifespanQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OwnershipQosPolicyKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(253, 72, 63, 147, 206, 16, 241, 72, 186, 231, 206, 213, 79, 158));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_OwnershipQosPolicyKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::OwnershipQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"SHARED_OWNERSHIP_QOS",0},{"EXCLUSIVE_OWNERSHIP_QOS",1},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::OwnershipQosPolicyKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case DDS::SHARED_OWNERSHIP_QOS:
    value_writer.write_enum("SHARED_OWNERSHIP_QOS", DDS::SHARED_OWNERSHIP_QOS);
    break;
  case DDS::EXCLUSIVE_OWNERSHIP_QOS:
    value_writer.write_enum("EXCLUSIVE_OWNERSHIP_QOS", DDS::EXCLUSIVE_OWNERSHIP_QOS);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::DDS::OwnershipQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 2) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::DDS::OwnershipQosPolicyKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::DDS::OwnershipQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 2) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::DDS::OwnershipQosPolicyKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_OwnershipQosPolicyKind_names[] = {
  "SHARED_OWNERSHIP_QOS",
  "EXCLUSIVE_OWNERSHIP_QOS"
};
const size_t gen_DDS_OwnershipQosPolicyKind_names_size = 2;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OwnershipQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_OwnershipQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::OwnershipQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.kind)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::OwnershipQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  vwrite(value_writer, value.kind);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::OwnershipQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.kind =  ::DDS::SHARED_OWNERSHIP_QOS;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::OwnershipQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
}

bool operator<<(Serializer& strm, const  ::DDS::OwnershipQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm,  ::DDS::OwnershipQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::OwnershipQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::OwnershipQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.kind);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::OwnershipQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::OwnershipQosPolicy> : MetaStruct {
  typedef  ::DDS::OwnershipQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::OwnershipQosPolicy& typed = *static_cast<const  ::DDS::OwnershipQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_OwnershipQosPolicyKind_names[typed.kind];
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::DDS::OwnershipQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::OwnershipQosPolicy>()
{
  static MetaStructImpl< ::DDS::OwnershipQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::OwnershipQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::OwnershipQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OwnershipStrengthQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_OwnershipStrengthQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::OwnershipStrengthQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.value)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::OwnershipStrengthQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.write_int32(value.value);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::OwnershipStrengthQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::OwnershipStrengthQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::DDS::OwnershipStrengthQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::DDS::OwnershipStrengthQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::OwnershipStrengthQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::OwnershipStrengthQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::OwnershipStrengthQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::OwnershipStrengthQosPolicy> : MetaStruct {
  typedef  ::DDS::OwnershipStrengthQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipStrengthQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::OwnershipStrengthQosPolicy& typed = *static_cast<const  ::DDS::OwnershipStrengthQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipStrengthQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "value") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipStrengthQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipStrengthQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipStrengthQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::OwnershipStrengthQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::OwnershipStrengthQosPolicy>()
{
  static MetaStructImpl< ::DDS::OwnershipStrengthQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::OwnershipStrengthQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::OwnershipStrengthQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PresentationQosPolicyAccessScopeKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 124, 74, 82, 33, 209, 171, 154, 100, 92, 69, 182, 34, 215));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_PresentationQosPolicyAccessScopeKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PresentationQosPolicyAccessScopeKind& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"INSTANCE_PRESENTATION_QOS",0},{"TOPIC_PRESENTATION_QOS",1},{"GROUP_PRESENTATION_QOS",2},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PresentationQosPolicyAccessScopeKind& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case DDS::INSTANCE_PRESENTATION_QOS:
    value_writer.write_enum("INSTANCE_PRESENTATION_QOS", DDS::INSTANCE_PRESENTATION_QOS);
    break;
  case DDS::TOPIC_PRESENTATION_QOS:
    value_writer.write_enum("TOPIC_PRESENTATION_QOS", DDS::TOPIC_PRESENTATION_QOS);
    break;
  case DDS::GROUP_PRESENTATION_QOS:
    value_writer.write_enum("GROUP_PRESENTATION_QOS", DDS::GROUP_PRESENTATION_QOS);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::DDS::PresentationQosPolicyAccessScopeKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 3) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::DDS::PresentationQosPolicyAccessScopeKind (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::DDS::PresentationQosPolicyAccessScopeKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 3) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::DDS::PresentationQosPolicyAccessScopeKind>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_PresentationQosPolicyAccessScopeKind_names[] = {
  "INSTANCE_PRESENTATION_QOS",
  "TOPIC_PRESENTATION_QOS",
  "GROUP_PRESENTATION_QOS"
};
const size_t gen_DDS_PresentationQosPolicyAccessScopeKind_names_size = 3;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PresentationQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_PresentationQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PresentationQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"access_scope",0},{"coherent_access",1},{"ordered_access",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.access_scope)) return false;
      break;
    }
    case 1: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.coherent_access = bx;
      }
      break;
    }
    case 2: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.ordered_access = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PresentationQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("access_scope");
  vwrite(value_writer, value.access_scope);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("coherent_access");
  value_writer.write_boolean(value.coherent_access);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ordered_access");
  value_writer.write_boolean(value.ordered_access);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::PresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.access_scope =  ::DDS::INSTANCE_PRESENTATION_QOS;
  stru.coherent_access = 0;
  stru.ordered_access = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.coherent_access));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.ordered_access));
}

bool operator<<(Serializer& strm, const  ::DDS::PresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.access_scope)
    && (strm << ACE_OutputCDR::from_boolean(stru.coherent_access))
    && (strm << ACE_OutputCDR::from_boolean(stru.ordered_access));
}

bool operator>>(Serializer& strm,  ::DDS::PresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.access_scope)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.coherent_access))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.ordered_access))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::PresentationQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.coherent_access));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.ordered_access));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::PresentationQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.access_scope)
    && (strm << ACE_OutputCDR::from_boolean(stru.value.coherent_access))
    && (strm << ACE_OutputCDR::from_boolean(stru.value.ordered_access));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PresentationQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.access_scope)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.coherent_access))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.ordered_access))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::PresentationQosPolicy> : MetaStruct {
  typedef  ::DDS::PresentationQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("access_scope", 0),
      std::make_pair("coherent_access", 1),
      std::make_pair("ordered_access", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PresentationQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::PresentationQosPolicy& typed = *static_cast<const  ::DDS::PresentationQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "access_scope") == 0) {
      return gen_DDS_PresentationQosPolicyAccessScopeKind_names[typed.access_scope];
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return typed.coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return typed.ordered_access;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PresentationQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "access_scope") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'access_scope' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'access_scope' could not be skipped");
      }
    }
    if (base_field == "coherent_access") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'coherent_access' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'coherent_access' could not be skipped");
      }
    }
    if (base_field == "ordered_access") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'ordered_access' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'ordered_access' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "access_scope") == 0) {
      return make_field_cmp(&T::access_scope, next);
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return make_field_cmp(&T::coherent_access, next);
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return make_field_cmp(&T::ordered_access, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PresentationQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"access_scope", "coherent_access", "ordered_access", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "access_scope") == 0) {
      return &static_cast<const T*>(stru)->access_scope;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return &static_cast<const T*>(stru)->coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return &static_cast<const T*>(stru)->ordered_access;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PresentationQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "access_scope") == 0) {
      static_cast<T*>(lhs)->access_scope = *static_cast<const  ::DDS::PresentationQosPolicyAccessScopeKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      static_cast<T*>(lhs)->coherent_access = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      static_cast<T*>(lhs)->ordered_access = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PresentationQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "access_scope") == 0) {
      return static_cast<const T*>(lhs)->access_scope == static_cast<const T*>(rhs)->access_scope;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return static_cast<const T*>(lhs)->coherent_access == static_cast<const T*>(rhs)->coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return static_cast<const T*>(lhs)->ordered_access == static_cast<const T*>(rhs)->ordered_access;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PresentationQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::PresentationQosPolicy>()
{
  static MetaStructImpl< ::DDS::PresentationQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::PresentationQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::PresentationQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TimeBasedFilterQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_TimeBasedFilterQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TimeBasedFilterQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"minimum_separation",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.minimum_separation)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TimeBasedFilterQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("minimum_separation");
  vwrite(value_writer, value.minimum_separation);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::TimeBasedFilterQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.minimum_separation);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::TimeBasedFilterQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.minimum_separation);
}

bool operator<<(Serializer& strm, const  ::DDS::TimeBasedFilterQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.minimum_separation);
}

bool operator>>(Serializer& strm,  ::DDS::TimeBasedFilterQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.minimum_separation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::TimeBasedFilterQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.minimum_separation);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::TimeBasedFilterQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.minimum_separation);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TimeBasedFilterQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.minimum_separation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::TimeBasedFilterQosPolicy> : MetaStruct {
  typedef  ::DDS::TimeBasedFilterQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("minimum_separation", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TimeBasedFilterQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::TimeBasedFilterQosPolicy& typed = *static_cast<const  ::DDS::TimeBasedFilterQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.minimum_separation, field + 19);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TimeBasedFilterQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "minimum_separation") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'minimum_separation' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
      return make_struct_cmp(&T::minimum_separation, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 19), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TimeBasedFilterQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"minimum_separation", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "minimum_separation") == 0) {
      return &static_cast<const T*>(stru)->minimum_separation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TimeBasedFilterQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "minimum_separation") == 0) {
      static_cast<T*>(lhs)->minimum_separation = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TimeBasedFilterQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TimeBasedFilterQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::TimeBasedFilterQosPolicy>()
{
  static MetaStructImpl< ::DDS::TimeBasedFilterQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::TimeBasedFilterQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::TimeBasedFilterQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataRepresentationId_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DataRepresentationId_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataRepresentationIdSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 31, 169, 229, 223, 19, 38, 65, 134, 73, 192, 156, 90, 188));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DataRepresentationIdSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DataRepresentationIdSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  primitive_serialized_size(encoding, size,  ::CORBA::Short(), seq.length());
}

bool operator<<(Serializer& strm, const  ::DDS::DataRepresentationIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_short_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm,  ::DDS::DataRepresentationIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  if (length == 0) {
    return true;
  }
  return strm.read_short_array(seq.get_buffer(), length);
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::DataRepresentationIdSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  return ser.skip(length, 2);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataRepresentationQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DataRepresentationQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DataRepresentationQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.value);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_int16(value.value[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DataRepresentationQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.begin_sequence();
  value_writer.write_int16_array (value.value.get_buffer(), value.value.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DataRepresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.value.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DataRepresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::DDS::DataRepresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::DDS::DataRepresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DataRepresentationQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DataRepresentationQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DataRepresentationQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DataRepresentationQosPolicy> : MetaStruct {
  typedef  ::DDS::DataRepresentationQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataRepresentationQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DataRepresentationQosPolicy& typed = *static_cast<const  ::DDS::DataRepresentationQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataRepresentationQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::DataRepresentationIdSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataRepresentationQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataRepresentationQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::DDS::DataRepresentationIdSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataRepresentationQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataRepresentationQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DataRepresentationQosPolicy>()
{
  static MetaStructImpl< ::DDS::DataRepresentationQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DataRepresentationQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DataRepresentationQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TypeConsistencyEnforcementQosPolicyKind_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_TypeConsistencyEnforcementQosPolicyKind_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TypeConsistencyEnforcementQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_TypeConsistencyEnforcementQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TypeConsistencyEnforcementQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{"ignore_sequence_bounds",1},{"ignore_string_bounds",2},{"ignore_member_names",3},{"prevent_type_widening",4},{"force_type_validation",5},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int16(value.kind)) return false;
      break;
    }
    case 1: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.ignore_sequence_bounds = bx;
      }
      break;
    }
    case 2: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.ignore_string_bounds = bx;
      }
      break;
    }
    case 3: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.ignore_member_names = bx;
      }
      break;
    }
    case 4: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.prevent_type_widening = bx;
      }
      break;
    }
    case 5: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.force_type_validation = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TypeConsistencyEnforcementQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  value_writer.write_int16(value.kind);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ignore_sequence_bounds");
  value_writer.write_boolean(value.ignore_sequence_bounds);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ignore_string_bounds");
  value_writer.write_boolean(value.ignore_string_bounds);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ignore_member_names");
  value_writer.write_boolean(value.ignore_member_names);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("prevent_type_widening");
  value_writer.write_boolean(value.prevent_type_widening);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("force_type_validation");
  value_writer.write_boolean(value.force_type_validation);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::TypeConsistencyEnforcementQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.kind = 0;
  stru.ignore_sequence_bounds = 0;
  stru.ignore_string_bounds = 0;
  stru.ignore_member_names = 0;
  stru.prevent_type_widening = 0;
  stru.force_type_validation = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::TypeConsistencyEnforcementQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.kind);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.ignore_sequence_bounds));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.ignore_string_bounds));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.ignore_member_names));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.prevent_type_widening));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.force_type_validation));
}

bool operator<<(Serializer& strm, const  ::DDS::TypeConsistencyEnforcementQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.kind)
    && (strm << ACE_OutputCDR::from_boolean(stru.ignore_sequence_bounds))
    && (strm << ACE_OutputCDR::from_boolean(stru.ignore_string_bounds))
    && (strm << ACE_OutputCDR::from_boolean(stru.ignore_member_names))
    && (strm << ACE_OutputCDR::from_boolean(stru.prevent_type_widening))
    && (strm << ACE_OutputCDR::from_boolean(stru.force_type_validation));
}

bool operator>>(Serializer& strm,  ::DDS::TypeConsistencyEnforcementQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.ignore_sequence_bounds))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.ignore_string_bounds))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.ignore_member_names))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.prevent_type_widening))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.force_type_validation))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::TypeConsistencyEnforcementQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.kind);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.ignore_sequence_bounds));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.ignore_string_bounds));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.ignore_member_names));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.prevent_type_widening));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.force_type_validation));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::TypeConsistencyEnforcementQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.kind)
    && (strm << ACE_OutputCDR::from_boolean(stru.value.ignore_sequence_bounds))
    && (strm << ACE_OutputCDR::from_boolean(stru.value.ignore_string_bounds))
    && (strm << ACE_OutputCDR::from_boolean(stru.value.ignore_member_names))
    && (strm << ACE_OutputCDR::from_boolean(stru.value.prevent_type_widening))
    && (strm << ACE_OutputCDR::from_boolean(stru.value.force_type_validation));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TypeConsistencyEnforcementQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.ignore_sequence_bounds))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.ignore_string_bounds))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.ignore_member_names))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.prevent_type_widening))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.force_type_validation))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::TypeConsistencyEnforcementQosPolicy> : MetaStruct {
  typedef  ::DDS::TypeConsistencyEnforcementQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
      std::make_pair("ignore_sequence_bounds", 1),
      std::make_pair("ignore_string_bounds", 2),
      std::make_pair("ignore_member_names", 3),
      std::make_pair("prevent_type_widening", 4),
      std::make_pair("force_type_validation", 5),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 6);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TypeConsistencyEnforcementQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::TypeConsistencyEnforcementQosPolicy& typed = *static_cast<const  ::DDS::TypeConsistencyEnforcementQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return typed.kind;
    }
    if (std::strcmp(field, "ignore_sequence_bounds") == 0) {
      return typed.ignore_sequence_bounds;
    }
    if (std::strcmp(field, "ignore_string_bounds") == 0) {
      return typed.ignore_string_bounds;
    }
    if (std::strcmp(field, "ignore_member_names") == 0) {
      return typed.ignore_member_names;
    }
    if (std::strcmp(field, "prevent_type_widening") == 0) {
      return typed.prevent_type_widening;
    }
    if (std::strcmp(field, "force_type_validation") == 0) {
      return typed.force_type_validation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TypeConsistencyEnforcementQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      ACE_CDR::Short val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (base_field == "ignore_sequence_bounds") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'ignore_sequence_bounds' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'ignore_sequence_bounds' could not be skipped");
      }
    }
    if (base_field == "ignore_string_bounds") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'ignore_string_bounds' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'ignore_string_bounds' could not be skipped");
      }
    }
    if (base_field == "ignore_member_names") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'ignore_member_names' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'ignore_member_names' could not be skipped");
      }
    }
    if (base_field == "prevent_type_widening") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'prevent_type_widening' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'prevent_type_widening' could not be skipped");
      }
    }
    if (base_field == "force_type_validation") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'force_type_validation' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'force_type_validation' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strcmp(field, "ignore_sequence_bounds") == 0) {
      return make_field_cmp(&T::ignore_sequence_bounds, next);
    }
    if (std::strcmp(field, "ignore_string_bounds") == 0) {
      return make_field_cmp(&T::ignore_string_bounds, next);
    }
    if (std::strcmp(field, "ignore_member_names") == 0) {
      return make_field_cmp(&T::ignore_member_names, next);
    }
    if (std::strcmp(field, "prevent_type_widening") == 0) {
      return make_field_cmp(&T::prevent_type_widening, next);
    }
    if (std::strcmp(field, "force_type_validation") == 0) {
      return make_field_cmp(&T::force_type_validation, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TypeConsistencyEnforcementQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "ignore_sequence_bounds", "ignore_string_bounds", "ignore_member_names", "prevent_type_widening", "force_type_validation", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "ignore_sequence_bounds") == 0) {
      return &static_cast<const T*>(stru)->ignore_sequence_bounds;
    }
    if (std::strcmp(field, "ignore_string_bounds") == 0) {
      return &static_cast<const T*>(stru)->ignore_string_bounds;
    }
    if (std::strcmp(field, "ignore_member_names") == 0) {
      return &static_cast<const T*>(stru)->ignore_member_names;
    }
    if (std::strcmp(field, "prevent_type_widening") == 0) {
      return &static_cast<const T*>(stru)->prevent_type_widening;
    }
    if (std::strcmp(field, "force_type_validation") == 0) {
      return &static_cast<const T*>(stru)->force_type_validation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TypeConsistencyEnforcementQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::DDS::TypeConsistencyEnforcementQosPolicyKind_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ignore_sequence_bounds") == 0) {
      static_cast<T*>(lhs)->ignore_sequence_bounds = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ignore_string_bounds") == 0) {
      static_cast<T*>(lhs)->ignore_string_bounds = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ignore_member_names") == 0) {
      static_cast<T*>(lhs)->ignore_member_names = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "prevent_type_widening") == 0) {
      static_cast<T*>(lhs)->prevent_type_widening = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "force_type_validation") == 0) {
      static_cast<T*>(lhs)->force_type_validation = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TypeConsistencyEnforcementQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    if (std::strcmp(field, "ignore_sequence_bounds") == 0) {
      return static_cast<const T*>(lhs)->ignore_sequence_bounds == static_cast<const T*>(rhs)->ignore_sequence_bounds;
    }
    if (std::strcmp(field, "ignore_string_bounds") == 0) {
      return static_cast<const T*>(lhs)->ignore_string_bounds == static_cast<const T*>(rhs)->ignore_string_bounds;
    }
    if (std::strcmp(field, "ignore_member_names") == 0) {
      return static_cast<const T*>(lhs)->ignore_member_names == static_cast<const T*>(rhs)->ignore_member_names;
    }
    if (std::strcmp(field, "prevent_type_widening") == 0) {
      return static_cast<const T*>(lhs)->prevent_type_widening == static_cast<const T*>(rhs)->prevent_type_widening;
    }
    if (std::strcmp(field, "force_type_validation") == 0) {
      return static_cast<const T*>(lhs)->force_type_validation == static_cast<const T*>(rhs)->force_type_validation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TypeConsistencyEnforcementQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::TypeConsistencyEnforcementQosPolicy>()
{
  static MetaStructImpl< ::DDS::TypeConsistencyEnforcementQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::TypeConsistencyEnforcementQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::TypeConsistencyEnforcementQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TopicQos_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(237, 11, 165, 89, 87, 253, 32, 30, 237, 205, 192, 158, 220, 92));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_TopicQos_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TopicQos& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"topic_data",0},{"durability",1},{"durability_service",2},{"deadline",3},{"latency_budget",4},{"liveliness",5},{"reliability",6},{"destination_order",7},{"history",8},{"resource_limits",9},{"transport_priority",10},{"lifespan",11},{"ownership",12},{"representation",13},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.topic_data)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.durability)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.durability_service)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.deadline)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.latency_budget)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.liveliness)) return false;
      break;
    }
    case 6: {
      if (!vread(value_reader, value.reliability)) return false;
      break;
    }
    case 7: {
      if (!vread(value_reader, value.destination_order)) return false;
      break;
    }
    case 8: {
      if (!vread(value_reader, value.history)) return false;
      break;
    }
    case 9: {
      if (!vread(value_reader, value.resource_limits)) return false;
      break;
    }
    case 10: {
      if (!vread(value_reader, value.transport_priority)) return false;
      break;
    }
    case 11: {
      if (!vread(value_reader, value.lifespan)) return false;
      break;
    }
    case 12: {
      if (!vread(value_reader, value.ownership)) return false;
      break;
    }
    case 13: {
      if (!vread(value_reader, value.representation)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TopicQos& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("topic_data");
  vwrite(value_writer, value.topic_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("durability");
  vwrite(value_writer, value.durability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("durability_service");
  vwrite(value_writer, value.durability_service);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("deadline");
  vwrite(value_writer, value.deadline);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("latency_budget");
  vwrite(value_writer, value.latency_budget);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("liveliness");
  vwrite(value_writer, value.liveliness);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("reliability");
  vwrite(value_writer, value.reliability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("destination_order");
  vwrite(value_writer, value.destination_order);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("history");
  vwrite(value_writer, value.history);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("resource_limits");
  vwrite(value_writer, value.resource_limits);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transport_priority");
  vwrite(value_writer, value.transport_priority);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("lifespan");
  vwrite(value_writer, value.lifespan);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ownership");
  vwrite(value_writer, value.ownership);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("representation");
  vwrite(value_writer, value.representation);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::TopicQos& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.topic_data);
  set_default(stru.durability);
  set_default(stru.durability_service);
  set_default(stru.deadline);
  set_default(stru.latency_budget);
  set_default(stru.liveliness);
  set_default(stru.reliability);
  set_default(stru.destination_order);
  set_default(stru.history);
  set_default(stru.resource_limits);
  set_default(stru.transport_priority);
  set_default(stru.lifespan);
  set_default(stru.ownership);
  set_default(stru.representation);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::TopicQos& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.topic_data);
  serialized_size(encoding, size, stru.durability);
  serialized_size(encoding, size, stru.durability_service);
  serialized_size(encoding, size, stru.deadline);
  serialized_size(encoding, size, stru.latency_budget);
  serialized_size(encoding, size, stru.liveliness);
  serialized_size(encoding, size, stru.reliability);
  serialized_size(encoding, size, stru.destination_order);
  serialized_size(encoding, size, stru.history);
  serialized_size(encoding, size, stru.resource_limits);
  serialized_size(encoding, size, stru.transport_priority);
  serialized_size(encoding, size, stru.lifespan);
  serialized_size(encoding, size, stru.ownership);
  serialized_size(encoding, size, stru.representation);
}

bool operator<<(Serializer& strm, const  ::DDS::TopicQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.topic_data)
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.ownership)
    && (strm << stru.representation);
}

bool operator>>(Serializer& strm,  ::DDS::TopicQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability_service)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.history)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.resource_limits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport_priority)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.lifespan)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::TopicQos>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.topic_data);
  serialized_size(encoding, size, stru.value.durability);
  serialized_size(encoding, size, stru.value.durability_service);
  serialized_size(encoding, size, stru.value.deadline);
  serialized_size(encoding, size, stru.value.latency_budget);
  serialized_size(encoding, size, stru.value.liveliness);
  serialized_size(encoding, size, stru.value.reliability);
  serialized_size(encoding, size, stru.value.destination_order);
  serialized_size(encoding, size, stru.value.history);
  serialized_size(encoding, size, stru.value.resource_limits);
  serialized_size(encoding, size, stru.value.transport_priority);
  serialized_size(encoding, size, stru.value.lifespan);
  serialized_size(encoding, size, stru.value.ownership);
  serialized_size(encoding, size, stru.value.representation);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::TopicQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.topic_data)
    && (strm << stru.value.durability)
    && (strm << stru.value.durability_service)
    && (strm << stru.value.deadline)
    && (strm << stru.value.latency_budget)
    && (strm << stru.value.liveliness)
    && (strm << stru.value.reliability)
    && (strm << stru.value.destination_order)
    && (strm << stru.value.history)
    && (strm << stru.value.resource_limits)
    && (strm << stru.value.transport_priority)
    && (strm << stru.value.lifespan)
    && (strm << stru.value.ownership)
    && (strm << stru.value.representation);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TopicQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.topic_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.durability_service)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.history)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.resource_limits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.transport_priority)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.lifespan)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::TopicQos> : MetaStruct {
  typedef  ::DDS::TopicQos T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("topic_data", 0),
      std::make_pair("durability", 1),
      std::make_pair("durability_service", 2),
      std::make_pair("deadline", 3),
      std::make_pair("latency_budget", 4),
      std::make_pair("liveliness", 5),
      std::make_pair("reliability", 6),
      std::make_pair("destination_order", 7),
      std::make_pair("history", 8),
      std::make_pair("resource_limits", 9),
      std::make_pair("transport_priority", 10),
      std::make_pair("lifespan", 11),
      std::make_pair("ownership", 12),
      std::make_pair("representation", 13),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 14);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicQos)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::TopicQos& typed = *static_cast<const  ::DDS::TopicQos*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct< ::DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct< ::DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct< ::DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct< ::DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(&typed.representation, field + 15);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicQos)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "topic_data") {
      return getMetaStruct< ::DDS::TopicDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TopicDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'topic_data' could not be skipped");
      }
    }
    if (base_field == "durability") {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability' could not be skipped");
      }
    }
    if (base_field == "durability_service") {
      return getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityServiceQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability_service' could not be skipped");
      }
    }
    if (base_field == "deadline") {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DeadlineQosPolicy*>(0))) {
        throw std::runtime_error("Field 'deadline' could not be skipped");
      }
    }
    if (base_field == "latency_budget") {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LatencyBudgetQosPolicy*>(0))) {
        throw std::runtime_error("Field 'latency_budget' could not be skipped");
      }
    }
    if (base_field == "liveliness") {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LivelinessQosPolicy*>(0))) {
        throw std::runtime_error("Field 'liveliness' could not be skipped");
      }
    }
    if (base_field == "reliability") {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ReliabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'reliability' could not be skipped");
      }
    }
    if (base_field == "destination_order") {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DestinationOrderQosPolicy*>(0))) {
        throw std::runtime_error("Field 'destination_order' could not be skipped");
      }
    }
    if (base_field == "history") {
      return getMetaStruct< ::DDS::HistoryQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::HistoryQosPolicy*>(0))) {
        throw std::runtime_error("Field 'history' could not be skipped");
      }
    }
    if (base_field == "resource_limits") {
      return getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ResourceLimitsQosPolicy*>(0))) {
        throw std::runtime_error("Field 'resource_limits' could not be skipped");
      }
    }
    if (base_field == "transport_priority") {
      return getMetaStruct< ::DDS::TransportPriorityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TransportPriorityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'transport_priority' could not be skipped");
      }
    }
    if (base_field == "lifespan") {
      return getMetaStruct< ::DDS::LifespanQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LifespanQosPolicy*>(0))) {
        throw std::runtime_error("Field 'lifespan' could not be skipped");
      }
    }
    if (base_field == "ownership") {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::OwnershipQosPolicy*>(0))) {
        throw std::runtime_error("Field 'ownership' could not be skipped");
      }
    }
    if (base_field == "representation") {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DataRepresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'representation' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct< ::DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct< ::DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct< ::DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct< ::DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct< ::DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct< ::DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct< ::DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct< ::DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct< ::DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct< ::DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return make_struct_cmp(&T::representation, getMetaStruct< ::DDS::DataRepresentationQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicQos)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"topic_data", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "transport_priority", "lifespan", "ownership", "representation", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "representation") == 0) {
      return &static_cast<const T*>(stru)->representation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const  ::DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const  ::DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const  ::DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const  ::DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const  ::DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const  ::DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const  ::DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const  ::DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const  ::DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const  ::DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const  ::DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const  ::DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const  ::DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "representation") == 0) {
      static_cast<T*>(lhs)->representation = *static_cast<const  ::DDS::DataRepresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicQos)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicQos)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::TopicQos>()
{
  static MetaStructImpl< ::DDS::TopicQos> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::TopicQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::TopicQos>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_WriterDataLifecycleQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(151, 133, 93, 97, 88, 230, 235, 85, 240, 208, 235, 75, 68, 253));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_WriterDataLifecycleQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::WriterDataLifecycleQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"autodispose_unregistered_instances",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.autodispose_unregistered_instances = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::WriterDataLifecycleQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("autodispose_unregistered_instances");
  value_writer.write_boolean(value.autodispose_unregistered_instances);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::WriterDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.autodispose_unregistered_instances = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::WriterDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.autodispose_unregistered_instances));
}

bool operator<<(Serializer& strm, const  ::DDS::WriterDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_boolean(stru.autodispose_unregistered_instances));
}

bool operator>>(Serializer& strm,  ::DDS::WriterDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.autodispose_unregistered_instances))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::WriterDataLifecycleQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.autodispose_unregistered_instances));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::WriterDataLifecycleQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_boolean(stru.value.autodispose_unregistered_instances));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::WriterDataLifecycleQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.autodispose_unregistered_instances))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::WriterDataLifecycleQosPolicy> : MetaStruct {
  typedef  ::DDS::WriterDataLifecycleQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("autodispose_unregistered_instances", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::WriterDataLifecycleQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::WriterDataLifecycleQosPolicy& typed = *static_cast<const  ::DDS::WriterDataLifecycleQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return typed.autodispose_unregistered_instances;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::WriterDataLifecycleQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "autodispose_unregistered_instances") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'autodispose_unregistered_instances' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'autodispose_unregistered_instances' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return make_field_cmp(&T::autodispose_unregistered_instances, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::WriterDataLifecycleQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"autodispose_unregistered_instances", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return &static_cast<const T*>(stru)->autodispose_unregistered_instances;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::WriterDataLifecycleQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      static_cast<T*>(lhs)->autodispose_unregistered_instances = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::WriterDataLifecycleQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return static_cast<const T*>(lhs)->autodispose_unregistered_instances == static_cast<const T*>(rhs)->autodispose_unregistered_instances;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::WriterDataLifecycleQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::WriterDataLifecycleQosPolicy>()
{
  static MetaStructImpl< ::DDS::WriterDataLifecycleQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::WriterDataLifecycleQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::WriterDataLifecycleQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataWriterQos_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(9, 122, 150, 104, 250, 78, 157, 83, 255, 157, 123, 250, 229, 93));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DataWriterQos_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DataWriterQos& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"durability",0},{"durability_service",1},{"deadline",2},{"latency_budget",3},{"liveliness",4},{"reliability",5},{"destination_order",6},{"history",7},{"resource_limits",8},{"transport_priority",9},{"lifespan",10},{"user_data",11},{"ownership",12},{"ownership_strength",13},{"writer_data_lifecycle",14},{"representation",15},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.durability)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.durability_service)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.deadline)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.latency_budget)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.liveliness)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.reliability)) return false;
      break;
    }
    case 6: {
      if (!vread(value_reader, value.destination_order)) return false;
      break;
    }
    case 7: {
      if (!vread(value_reader, value.history)) return false;
      break;
    }
    case 8: {
      if (!vread(value_reader, value.resource_limits)) return false;
      break;
    }
    case 9: {
      if (!vread(value_reader, value.transport_priority)) return false;
      break;
    }
    case 10: {
      if (!vread(value_reader, value.lifespan)) return false;
      break;
    }
    case 11: {
      if (!vread(value_reader, value.user_data)) return false;
      break;
    }
    case 12: {
      if (!vread(value_reader, value.ownership)) return false;
      break;
    }
    case 13: {
      if (!vread(value_reader, value.ownership_strength)) return false;
      break;
    }
    case 14: {
      if (!vread(value_reader, value.writer_data_lifecycle)) return false;
      break;
    }
    case 15: {
      if (!vread(value_reader, value.representation)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DataWriterQos& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("durability");
  vwrite(value_writer, value.durability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("durability_service");
  vwrite(value_writer, value.durability_service);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("deadline");
  vwrite(value_writer, value.deadline);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("latency_budget");
  vwrite(value_writer, value.latency_budget);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("liveliness");
  vwrite(value_writer, value.liveliness);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("reliability");
  vwrite(value_writer, value.reliability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("destination_order");
  vwrite(value_writer, value.destination_order);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("history");
  vwrite(value_writer, value.history);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("resource_limits");
  vwrite(value_writer, value.resource_limits);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transport_priority");
  vwrite(value_writer, value.transport_priority);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("lifespan");
  vwrite(value_writer, value.lifespan);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("user_data");
  vwrite(value_writer, value.user_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ownership");
  vwrite(value_writer, value.ownership);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ownership_strength");
  vwrite(value_writer, value.ownership_strength);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writer_data_lifecycle");
  vwrite(value_writer, value.writer_data_lifecycle);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("representation");
  vwrite(value_writer, value.representation);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DataWriterQos& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.durability);
  set_default(stru.durability_service);
  set_default(stru.deadline);
  set_default(stru.latency_budget);
  set_default(stru.liveliness);
  set_default(stru.reliability);
  set_default(stru.destination_order);
  set_default(stru.history);
  set_default(stru.resource_limits);
  set_default(stru.transport_priority);
  set_default(stru.lifespan);
  set_default(stru.user_data);
  set_default(stru.ownership);
  set_default(stru.ownership_strength);
  set_default(stru.writer_data_lifecycle);
  set_default(stru.representation);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DataWriterQos& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.durability);
  serialized_size(encoding, size, stru.durability_service);
  serialized_size(encoding, size, stru.deadline);
  serialized_size(encoding, size, stru.latency_budget);
  serialized_size(encoding, size, stru.liveliness);
  serialized_size(encoding, size, stru.reliability);
  serialized_size(encoding, size, stru.destination_order);
  serialized_size(encoding, size, stru.history);
  serialized_size(encoding, size, stru.resource_limits);
  serialized_size(encoding, size, stru.transport_priority);
  serialized_size(encoding, size, stru.lifespan);
  serialized_size(encoding, size, stru.user_data);
  serialized_size(encoding, size, stru.ownership);
  serialized_size(encoding, size, stru.ownership_strength);
  serialized_size(encoding, size, stru.writer_data_lifecycle);
  serialized_size(encoding, size, stru.representation);
}

bool operator<<(Serializer& strm, const  ::DDS::DataWriterQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.ownership_strength)
    && (strm << stru.writer_data_lifecycle)
    && (strm << stru.representation);
}

bool operator>>(Serializer& strm,  ::DDS::DataWriterQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability_service)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.history)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.resource_limits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport_priority)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.lifespan)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ownership_strength)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writer_data_lifecycle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DataWriterQos>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.durability);
  serialized_size(encoding, size, stru.value.durability_service);
  serialized_size(encoding, size, stru.value.deadline);
  serialized_size(encoding, size, stru.value.latency_budget);
  serialized_size(encoding, size, stru.value.liveliness);
  serialized_size(encoding, size, stru.value.reliability);
  serialized_size(encoding, size, stru.value.destination_order);
  serialized_size(encoding, size, stru.value.history);
  serialized_size(encoding, size, stru.value.resource_limits);
  serialized_size(encoding, size, stru.value.transport_priority);
  serialized_size(encoding, size, stru.value.lifespan);
  serialized_size(encoding, size, stru.value.user_data);
  serialized_size(encoding, size, stru.value.ownership);
  serialized_size(encoding, size, stru.value.ownership_strength);
  serialized_size(encoding, size, stru.value.writer_data_lifecycle);
  serialized_size(encoding, size, stru.value.representation);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DataWriterQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.durability)
    && (strm << stru.value.durability_service)
    && (strm << stru.value.deadline)
    && (strm << stru.value.latency_budget)
    && (strm << stru.value.liveliness)
    && (strm << stru.value.reliability)
    && (strm << stru.value.destination_order)
    && (strm << stru.value.history)
    && (strm << stru.value.resource_limits)
    && (strm << stru.value.transport_priority)
    && (strm << stru.value.lifespan)
    && (strm << stru.value.user_data)
    && (strm << stru.value.ownership)
    && (strm << stru.value.ownership_strength)
    && (strm << stru.value.writer_data_lifecycle)
    && (strm << stru.value.representation);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DataWriterQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.durability_service)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.history)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.resource_limits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.transport_priority)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.lifespan)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.ownership_strength)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.writer_data_lifecycle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DataWriterQos> : MetaStruct {
  typedef  ::DDS::DataWriterQos T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("durability", 0),
      std::make_pair("durability_service", 1),
      std::make_pair("deadline", 2),
      std::make_pair("latency_budget", 3),
      std::make_pair("liveliness", 4),
      std::make_pair("reliability", 5),
      std::make_pair("destination_order", 6),
      std::make_pair("history", 7),
      std::make_pair("resource_limits", 8),
      std::make_pair("transport_priority", 9),
      std::make_pair("lifespan", 10),
      std::make_pair("user_data", 11),
      std::make_pair("ownership", 12),
      std::make_pair("ownership_strength", 13),
      std::make_pair("writer_data_lifecycle", 14),
      std::make_pair("representation", 15),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 16);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataWriterQos)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DataWriterQos& typed = *static_cast<const  ::DDS::DataWriterQos*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct< ::DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct< ::DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct< ::DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct< ::DDS::OwnershipStrengthQosPolicy>().getValue(&typed.ownership_strength, field + 19);
    }
    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
      return getMetaStruct< ::DDS::WriterDataLifecycleQosPolicy>().getValue(&typed.writer_data_lifecycle, field + 22);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(&typed.representation, field + 15);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataWriterQos)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "durability") {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability' could not be skipped");
      }
    }
    if (base_field == "durability_service") {
      return getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityServiceQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability_service' could not be skipped");
      }
    }
    if (base_field == "deadline") {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DeadlineQosPolicy*>(0))) {
        throw std::runtime_error("Field 'deadline' could not be skipped");
      }
    }
    if (base_field == "latency_budget") {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LatencyBudgetQosPolicy*>(0))) {
        throw std::runtime_error("Field 'latency_budget' could not be skipped");
      }
    }
    if (base_field == "liveliness") {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LivelinessQosPolicy*>(0))) {
        throw std::runtime_error("Field 'liveliness' could not be skipped");
      }
    }
    if (base_field == "reliability") {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ReliabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'reliability' could not be skipped");
      }
    }
    if (base_field == "destination_order") {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DestinationOrderQosPolicy*>(0))) {
        throw std::runtime_error("Field 'destination_order' could not be skipped");
      }
    }
    if (base_field == "history") {
      return getMetaStruct< ::DDS::HistoryQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::HistoryQosPolicy*>(0))) {
        throw std::runtime_error("Field 'history' could not be skipped");
      }
    }
    if (base_field == "resource_limits") {
      return getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ResourceLimitsQosPolicy*>(0))) {
        throw std::runtime_error("Field 'resource_limits' could not be skipped");
      }
    }
    if (base_field == "transport_priority") {
      return getMetaStruct< ::DDS::TransportPriorityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TransportPriorityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'transport_priority' could not be skipped");
      }
    }
    if (base_field == "lifespan") {
      return getMetaStruct< ::DDS::LifespanQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LifespanQosPolicy*>(0))) {
        throw std::runtime_error("Field 'lifespan' could not be skipped");
      }
    }
    if (base_field == "user_data") {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::UserDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'user_data' could not be skipped");
      }
    }
    if (base_field == "ownership") {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::OwnershipQosPolicy*>(0))) {
        throw std::runtime_error("Field 'ownership' could not be skipped");
      }
    }
    if (base_field == "ownership_strength") {
      return getMetaStruct< ::DDS::OwnershipStrengthQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::OwnershipStrengthQosPolicy*>(0))) {
        throw std::runtime_error("Field 'ownership_strength' could not be skipped");
      }
    }
    if (base_field == "writer_data_lifecycle") {
      return getMetaStruct< ::DDS::WriterDataLifecycleQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::WriterDataLifecycleQosPolicy*>(0))) {
        throw std::runtime_error("Field 'writer_data_lifecycle' could not be skipped");
      }
    }
    if (base_field == "representation") {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DataRepresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'representation' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct< ::DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct< ::DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct< ::DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct< ::DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct< ::DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct< ::DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct< ::DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct< ::DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct< ::DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct< ::DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return make_struct_cmp(&T::ownership_strength, getMetaStruct< ::DDS::OwnershipStrengthQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
      return make_struct_cmp(&T::writer_data_lifecycle, getMetaStruct< ::DDS::WriterDataLifecycleQosPolicy>().create_qc_comparator(field + 22), next);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return make_struct_cmp(&T::representation, getMetaStruct< ::DDS::DataRepresentationQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataWriterQos)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "transport_priority", "lifespan", "user_data", "ownership", "ownership_strength", "writer_data_lifecycle", "representation", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      return &static_cast<const T*>(stru)->ownership_strength;
    }
    if (std::strcmp(field, "writer_data_lifecycle") == 0) {
      return &static_cast<const T*>(stru)->writer_data_lifecycle;
    }
    if (std::strcmp(field, "representation") == 0) {
      return &static_cast<const T*>(stru)->representation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataWriterQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const  ::DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const  ::DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const  ::DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const  ::DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const  ::DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const  ::DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const  ::DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const  ::DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const  ::DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const  ::DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const  ::DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const  ::DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const  ::DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      static_cast<T*>(lhs)->ownership_strength = *static_cast<const  ::DDS::OwnershipStrengthQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writer_data_lifecycle") == 0) {
      static_cast<T*>(lhs)->writer_data_lifecycle = *static_cast<const  ::DDS::WriterDataLifecycleQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "representation") == 0) {
      static_cast<T*>(lhs)->representation = *static_cast<const  ::DDS::DataRepresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataWriterQos)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataWriterQos)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DataWriterQos>()
{
  static MetaStructImpl< ::DDS::DataWriterQos> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DataWriterQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DataWriterQos>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_EntityFactoryQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(208, 131, 188, 155, 96, 118, 238, 78, 31, 220, 1, 243, 99, 160));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_EntityFactoryQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::EntityFactoryQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"autoenable_created_entities",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.autoenable_created_entities = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::EntityFactoryQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("autoenable_created_entities");
  value_writer.write_boolean(value.autoenable_created_entities);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::EntityFactoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.autoenable_created_entities = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::EntityFactoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.autoenable_created_entities));
}

bool operator<<(Serializer& strm, const  ::DDS::EntityFactoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_boolean(stru.autoenable_created_entities));
}

bool operator>>(Serializer& strm,  ::DDS::EntityFactoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.autoenable_created_entities))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::EntityFactoryQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.autoenable_created_entities));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::EntityFactoryQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << ACE_OutputCDR::from_boolean(stru.value.autoenable_created_entities));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::EntityFactoryQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.autoenable_created_entities))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::EntityFactoryQosPolicy> : MetaStruct {
  typedef  ::DDS::EntityFactoryQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("autoenable_created_entities", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::EntityFactoryQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::EntityFactoryQosPolicy& typed = *static_cast<const  ::DDS::EntityFactoryQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return typed.autoenable_created_entities;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::EntityFactoryQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "autoenable_created_entities") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'autoenable_created_entities' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'autoenable_created_entities' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return make_field_cmp(&T::autoenable_created_entities, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::EntityFactoryQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"autoenable_created_entities", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return &static_cast<const T*>(stru)->autoenable_created_entities;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::EntityFactoryQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      static_cast<T*>(lhs)->autoenable_created_entities = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::EntityFactoryQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return static_cast<const T*>(lhs)->autoenable_created_entities == static_cast<const T*>(rhs)->autoenable_created_entities;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::EntityFactoryQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::EntityFactoryQosPolicy>()
{
  static MetaStructImpl< ::DDS::EntityFactoryQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::EntityFactoryQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::EntityFactoryQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PublisherQos_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(126, 56, 73, 18, 9, 183, 3, 167, 93, 113, 230, 154, 87, 113));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_PublisherQos_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PublisherQos& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"presentation",0},{"partition",1},{"group_data",2},{"entity_factory",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.presentation)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.partition)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.group_data)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.entity_factory)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PublisherQos& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("presentation");
  vwrite(value_writer, value.presentation);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("partition");
  vwrite(value_writer, value.partition);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("group_data");
  vwrite(value_writer, value.group_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("entity_factory");
  vwrite(value_writer, value.entity_factory);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::PublisherQos& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.presentation);
  set_default(stru.partition);
  set_default(stru.group_data);
  set_default(stru.entity_factory);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PublisherQos& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.presentation);
  serialized_size(encoding, size, stru.partition);
  serialized_size(encoding, size, stru.group_data);
  serialized_size(encoding, size, stru.entity_factory);
}

bool operator<<(Serializer& strm, const  ::DDS::PublisherQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.group_data)
    && (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm,  ::DDS::PublisherQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.presentation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.partition)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.group_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.entity_factory)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::PublisherQos>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.presentation);
  serialized_size(encoding, size, stru.value.partition);
  serialized_size(encoding, size, stru.value.group_data);
  serialized_size(encoding, size, stru.value.entity_factory);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::PublisherQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.presentation)
    && (strm << stru.value.partition)
    && (strm << stru.value.group_data)
    && (strm << stru.value.entity_factory);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PublisherQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.presentation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.partition)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.group_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.entity_factory)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::PublisherQos> : MetaStruct {
  typedef  ::DDS::PublisherQos T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("presentation", 0),
      std::make_pair("partition", 1),
      std::make_pair("group_data", 2),
      std::make_pair("entity_factory", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublisherQos)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::PublisherQos& typed = *static_cast<const  ::DDS::PublisherQos*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct< ::DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct< ::DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct< ::DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct< ::DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublisherQos)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "presentation") {
      return getMetaStruct< ::DDS::PresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'presentation' could not be skipped");
      }
    }
    if (base_field == "partition") {
      return getMetaStruct< ::DDS::PartitionQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PartitionQosPolicy*>(0))) {
        throw std::runtime_error("Field 'partition' could not be skipped");
      }
    }
    if (base_field == "group_data") {
      return getMetaStruct< ::DDS::GroupDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::GroupDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'group_data' could not be skipped");
      }
    }
    if (base_field == "entity_factory") {
      return getMetaStruct< ::DDS::EntityFactoryQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::EntityFactoryQosPolicy*>(0))) {
        throw std::runtime_error("Field 'entity_factory' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct< ::DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct< ::DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct< ::DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct< ::DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublisherQos)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"presentation", "partition", "group_data", "entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublisherQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const  ::DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const  ::DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const  ::DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const  ::DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublisherQos)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublisherQos)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::PublisherQos>()
{
  static MetaStructImpl< ::DDS::PublisherQos> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::PublisherQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::PublisherQos>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ReaderDataLifecycleQosPolicy_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(128, 6, 106, 169, 239, 151, 91, 255, 81, 243, 37, 38, 187, 17));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_ReaderDataLifecycleQosPolicy_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ReaderDataLifecycleQosPolicy& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"autopurge_nowriter_samples_delay",0},{"autopurge_disposed_samples_delay",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.autopurge_nowriter_samples_delay)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.autopurge_disposed_samples_delay)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ReaderDataLifecycleQosPolicy& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("autopurge_nowriter_samples_delay");
  vwrite(value_writer, value.autopurge_nowriter_samples_delay);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("autopurge_disposed_samples_delay");
  vwrite(value_writer, value.autopurge_disposed_samples_delay);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::ReaderDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.autopurge_nowriter_samples_delay);
  set_default(stru.autopurge_disposed_samples_delay);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::ReaderDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.autopurge_nowriter_samples_delay);
  serialized_size(encoding, size, stru.autopurge_disposed_samples_delay);
}

bool operator<<(Serializer& strm, const  ::DDS::ReaderDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.autopurge_nowriter_samples_delay)
    && (strm << stru.autopurge_disposed_samples_delay);
}

bool operator>>(Serializer& strm,  ::DDS::ReaderDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.autopurge_nowriter_samples_delay)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.autopurge_disposed_samples_delay)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::ReaderDataLifecycleQosPolicy>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.autopurge_nowriter_samples_delay);
  serialized_size(encoding, size, stru.value.autopurge_disposed_samples_delay);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::ReaderDataLifecycleQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.autopurge_nowriter_samples_delay)
    && (strm << stru.value.autopurge_disposed_samples_delay);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::ReaderDataLifecycleQosPolicy>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.autopurge_nowriter_samples_delay)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.autopurge_disposed_samples_delay)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::ReaderDataLifecycleQosPolicy> : MetaStruct {
  typedef  ::DDS::ReaderDataLifecycleQosPolicy T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("autopurge_nowriter_samples_delay", 0),
      std::make_pair("autopurge_disposed_samples_delay", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReaderDataLifecycleQosPolicy)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::ReaderDataLifecycleQosPolicy& typed = *static_cast<const  ::DDS::ReaderDataLifecycleQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.autopurge_nowriter_samples_delay, field + 33);
    }
    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
      return getMetaStruct< ::DDS::Duration_t>().getValue(&typed.autopurge_disposed_samples_delay, field + 33);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReaderDataLifecycleQosPolicy)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "autopurge_nowriter_samples_delay") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'autopurge_nowriter_samples_delay' could not be skipped");
      }
    }
    if (base_field == "autopurge_disposed_samples_delay") {
      return getMetaStruct< ::DDS::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'autopurge_disposed_samples_delay' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
      return make_struct_cmp(&T::autopurge_nowriter_samples_delay, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 33), next);
    }
    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
      return make_struct_cmp(&T::autopurge_disposed_samples_delay, getMetaStruct< ::DDS::Duration_t>().create_qc_comparator(field + 33), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReaderDataLifecycleQosPolicy)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"autopurge_nowriter_samples_delay", "autopurge_disposed_samples_delay", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autopurge_nowriter_samples_delay") == 0) {
      return &static_cast<const T*>(stru)->autopurge_nowriter_samples_delay;
    }
    if (std::strcmp(field, "autopurge_disposed_samples_delay") == 0) {
      return &static_cast<const T*>(stru)->autopurge_disposed_samples_delay;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReaderDataLifecycleQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autopurge_nowriter_samples_delay") == 0) {
      static_cast<T*>(lhs)->autopurge_nowriter_samples_delay = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "autopurge_disposed_samples_delay") == 0) {
      static_cast<T*>(lhs)->autopurge_disposed_samples_delay = *static_cast<const  ::DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReaderDataLifecycleQosPolicy)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ReaderDataLifecycleQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::ReaderDataLifecycleQosPolicy>()
{
  static MetaStructImpl< ::DDS::ReaderDataLifecycleQosPolicy> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::ReaderDataLifecycleQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::ReaderDataLifecycleQosPolicy>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataReaderQos_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(55, 10, 190, 230, 50, 127, 48, 223, 212, 68, 18, 125, 171, 30));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DataReaderQos_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DataReaderQos& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"durability",0},{"deadline",1},{"latency_budget",2},{"liveliness",3},{"reliability",4},{"destination_order",5},{"history",6},{"resource_limits",7},{"user_data",8},{"ownership",9},{"time_based_filter",10},{"reader_data_lifecycle",11},{"representation",12},{"type_consistency",13},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.durability)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.deadline)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.latency_budget)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.liveliness)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.reliability)) return false;
      break;
    }
    case 5: {
      if (!vread(value_reader, value.destination_order)) return false;
      break;
    }
    case 6: {
      if (!vread(value_reader, value.history)) return false;
      break;
    }
    case 7: {
      if (!vread(value_reader, value.resource_limits)) return false;
      break;
    }
    case 8: {
      if (!vread(value_reader, value.user_data)) return false;
      break;
    }
    case 9: {
      if (!vread(value_reader, value.ownership)) return false;
      break;
    }
    case 10: {
      if (!vread(value_reader, value.time_based_filter)) return false;
      break;
    }
    case 11: {
      if (!vread(value_reader, value.reader_data_lifecycle)) return false;
      break;
    }
    case 12: {
      if (!vread(value_reader, value.representation)) return false;
      break;
    }
    case 13: {
      if (!vread(value_reader, value.type_consistency)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DataReaderQos& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("durability");
  vwrite(value_writer, value.durability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("deadline");
  vwrite(value_writer, value.deadline);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("latency_budget");
  vwrite(value_writer, value.latency_budget);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("liveliness");
  vwrite(value_writer, value.liveliness);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("reliability");
  vwrite(value_writer, value.reliability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("destination_order");
  vwrite(value_writer, value.destination_order);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("history");
  vwrite(value_writer, value.history);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("resource_limits");
  vwrite(value_writer, value.resource_limits);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("user_data");
  vwrite(value_writer, value.user_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ownership");
  vwrite(value_writer, value.ownership);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("time_based_filter");
  vwrite(value_writer, value.time_based_filter);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("reader_data_lifecycle");
  vwrite(value_writer, value.reader_data_lifecycle);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("representation");
  vwrite(value_writer, value.representation);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("type_consistency");
  vwrite(value_writer, value.type_consistency);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DataReaderQos& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.durability);
  set_default(stru.deadline);
  set_default(stru.latency_budget);
  set_default(stru.liveliness);
  set_default(stru.reliability);
  set_default(stru.destination_order);
  set_default(stru.history);
  set_default(stru.resource_limits);
  set_default(stru.user_data);
  set_default(stru.ownership);
  set_default(stru.time_based_filter);
  set_default(stru.reader_data_lifecycle);
  set_default(stru.representation);
  set_default(stru.type_consistency);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DataReaderQos& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.durability);
  serialized_size(encoding, size, stru.deadline);
  serialized_size(encoding, size, stru.latency_budget);
  serialized_size(encoding, size, stru.liveliness);
  serialized_size(encoding, size, stru.reliability);
  serialized_size(encoding, size, stru.destination_order);
  serialized_size(encoding, size, stru.history);
  serialized_size(encoding, size, stru.resource_limits);
  serialized_size(encoding, size, stru.user_data);
  serialized_size(encoding, size, stru.ownership);
  serialized_size(encoding, size, stru.time_based_filter);
  serialized_size(encoding, size, stru.reader_data_lifecycle);
  serialized_size(encoding, size, stru.representation);
  serialized_size(encoding, size, stru.type_consistency);
}

bool operator<<(Serializer& strm, const  ::DDS::DataReaderQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.durability)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.time_based_filter)
    && (strm << stru.reader_data_lifecycle)
    && (strm << stru.representation)
    && (strm << stru.type_consistency);
}

bool operator>>(Serializer& strm,  ::DDS::DataReaderQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.history)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.resource_limits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.time_based_filter)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.reader_data_lifecycle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.type_consistency)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DataReaderQos>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.durability);
  serialized_size(encoding, size, stru.value.deadline);
  serialized_size(encoding, size, stru.value.latency_budget);
  serialized_size(encoding, size, stru.value.liveliness);
  serialized_size(encoding, size, stru.value.reliability);
  serialized_size(encoding, size, stru.value.destination_order);
  serialized_size(encoding, size, stru.value.history);
  serialized_size(encoding, size, stru.value.resource_limits);
  serialized_size(encoding, size, stru.value.user_data);
  serialized_size(encoding, size, stru.value.ownership);
  serialized_size(encoding, size, stru.value.time_based_filter);
  serialized_size(encoding, size, stru.value.reader_data_lifecycle);
  serialized_size(encoding, size, stru.value.representation);
  serialized_size(encoding, size, stru.value.type_consistency);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DataReaderQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.durability)
    && (strm << stru.value.deadline)
    && (strm << stru.value.latency_budget)
    && (strm << stru.value.liveliness)
    && (strm << stru.value.reliability)
    && (strm << stru.value.destination_order)
    && (strm << stru.value.history)
    && (strm << stru.value.resource_limits)
    && (strm << stru.value.user_data)
    && (strm << stru.value.ownership)
    && (strm << stru.value.time_based_filter)
    && (strm << stru.value.reader_data_lifecycle)
    && (strm << stru.value.representation)
    && (strm << stru.value.type_consistency);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DataReaderQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.history)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.resource_limits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.time_based_filter)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.reader_data_lifecycle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.type_consistency)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DataReaderQos> : MetaStruct {
  typedef  ::DDS::DataReaderQos T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("durability", 0),
      std::make_pair("deadline", 1),
      std::make_pair("latency_budget", 2),
      std::make_pair("liveliness", 3),
      std::make_pair("reliability", 4),
      std::make_pair("destination_order", 5),
      std::make_pair("history", 6),
      std::make_pair("resource_limits", 7),
      std::make_pair("user_data", 8),
      std::make_pair("ownership", 9),
      std::make_pair("time_based_filter", 10),
      std::make_pair("reader_data_lifecycle", 11),
      std::make_pair("representation", 12),
      std::make_pair("type_consistency", 13),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 14);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataReaderQos)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DataReaderQos& typed = *static_cast<const  ::DDS::DataReaderQos*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct< ::DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct< ::DDS::TimeBasedFilterQosPolicy>().getValue(&typed.time_based_filter, field + 18);
    }
    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
      return getMetaStruct< ::DDS::ReaderDataLifecycleQosPolicy>().getValue(&typed.reader_data_lifecycle, field + 22);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(&typed.representation, field + 15);
    }
    if (std::strncmp(field, "type_consistency.", 17) == 0) {
      return getMetaStruct< ::DDS::TypeConsistencyEnforcementQosPolicy>().getValue(&typed.type_consistency, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataReaderQos)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "durability") {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability' could not be skipped");
      }
    }
    if (base_field == "deadline") {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DeadlineQosPolicy*>(0))) {
        throw std::runtime_error("Field 'deadline' could not be skipped");
      }
    }
    if (base_field == "latency_budget") {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LatencyBudgetQosPolicy*>(0))) {
        throw std::runtime_error("Field 'latency_budget' could not be skipped");
      }
    }
    if (base_field == "liveliness") {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LivelinessQosPolicy*>(0))) {
        throw std::runtime_error("Field 'liveliness' could not be skipped");
      }
    }
    if (base_field == "reliability") {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ReliabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'reliability' could not be skipped");
      }
    }
    if (base_field == "destination_order") {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DestinationOrderQosPolicy*>(0))) {
        throw std::runtime_error("Field 'destination_order' could not be skipped");
      }
    }
    if (base_field == "history") {
      return getMetaStruct< ::DDS::HistoryQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::HistoryQosPolicy*>(0))) {
        throw std::runtime_error("Field 'history' could not be skipped");
      }
    }
    if (base_field == "resource_limits") {
      return getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ResourceLimitsQosPolicy*>(0))) {
        throw std::runtime_error("Field 'resource_limits' could not be skipped");
      }
    }
    if (base_field == "user_data") {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::UserDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'user_data' could not be skipped");
      }
    }
    if (base_field == "ownership") {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::OwnershipQosPolicy*>(0))) {
        throw std::runtime_error("Field 'ownership' could not be skipped");
      }
    }
    if (base_field == "time_based_filter") {
      return getMetaStruct< ::DDS::TimeBasedFilterQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TimeBasedFilterQosPolicy*>(0))) {
        throw std::runtime_error("Field 'time_based_filter' could not be skipped");
      }
    }
    if (base_field == "reader_data_lifecycle") {
      return getMetaStruct< ::DDS::ReaderDataLifecycleQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ReaderDataLifecycleQosPolicy*>(0))) {
        throw std::runtime_error("Field 'reader_data_lifecycle' could not be skipped");
      }
    }
    if (base_field == "representation") {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DataRepresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'representation' could not be skipped");
      }
    }
    if (base_field == "type_consistency") {
      return getMetaStruct< ::DDS::TypeConsistencyEnforcementQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TypeConsistencyEnforcementQosPolicy*>(0))) {
        throw std::runtime_error("Field 'type_consistency' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct< ::DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct< ::DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct< ::DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct< ::DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct< ::DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct< ::DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct< ::DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct< ::DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return make_struct_cmp(&T::time_based_filter, getMetaStruct< ::DDS::TimeBasedFilterQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
      return make_struct_cmp(&T::reader_data_lifecycle, getMetaStruct< ::DDS::ReaderDataLifecycleQosPolicy>().create_qc_comparator(field + 22), next);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return make_struct_cmp(&T::representation, getMetaStruct< ::DDS::DataRepresentationQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "type_consistency.", 17) == 0) {
      return make_struct_cmp(&T::type_consistency, getMetaStruct< ::DDS::TypeConsistencyEnforcementQosPolicy>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataReaderQos)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"durability", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "user_data", "ownership", "time_based_filter", "reader_data_lifecycle", "representation", "type_consistency", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      return &static_cast<const T*>(stru)->time_based_filter;
    }
    if (std::strcmp(field, "reader_data_lifecycle") == 0) {
      return &static_cast<const T*>(stru)->reader_data_lifecycle;
    }
    if (std::strcmp(field, "representation") == 0) {
      return &static_cast<const T*>(stru)->representation;
    }
    if (std::strcmp(field, "type_consistency") == 0) {
      return &static_cast<const T*>(stru)->type_consistency;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataReaderQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const  ::DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const  ::DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const  ::DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const  ::DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const  ::DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const  ::DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const  ::DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const  ::DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const  ::DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const  ::DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      static_cast<T*>(lhs)->time_based_filter = *static_cast<const  ::DDS::TimeBasedFilterQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reader_data_lifecycle") == 0) {
      static_cast<T*>(lhs)->reader_data_lifecycle = *static_cast<const  ::DDS::ReaderDataLifecycleQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "representation") == 0) {
      static_cast<T*>(lhs)->representation = *static_cast<const  ::DDS::DataRepresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_consistency") == 0) {
      static_cast<T*>(lhs)->type_consistency = *static_cast<const  ::DDS::TypeConsistencyEnforcementQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataReaderQos)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DataReaderQos)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DataReaderQos>()
{
  static MetaStructImpl< ::DDS::DataReaderQos> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DataReaderQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DataReaderQos>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SubscriberQos_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(126, 56, 73, 18, 9, 183, 3, 167, 93, 113, 230, 154, 87, 113));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SubscriberQos_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SubscriberQos& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"presentation",0},{"partition",1},{"group_data",2},{"entity_factory",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.presentation)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.partition)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.group_data)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.entity_factory)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SubscriberQos& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("presentation");
  vwrite(value_writer, value.presentation);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("partition");
  vwrite(value_writer, value.partition);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("group_data");
  vwrite(value_writer, value.group_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("entity_factory");
  vwrite(value_writer, value.entity_factory);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::SubscriberQos& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.presentation);
  set_default(stru.partition);
  set_default(stru.group_data);
  set_default(stru.entity_factory);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::SubscriberQos& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.presentation);
  serialized_size(encoding, size, stru.partition);
  serialized_size(encoding, size, stru.group_data);
  serialized_size(encoding, size, stru.entity_factory);
}

bool operator<<(Serializer& strm, const  ::DDS::SubscriberQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.group_data)
    && (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm,  ::DDS::SubscriberQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.presentation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.partition)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.group_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.entity_factory)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::SubscriberQos>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.presentation);
  serialized_size(encoding, size, stru.value.partition);
  serialized_size(encoding, size, stru.value.group_data);
  serialized_size(encoding, size, stru.value.entity_factory);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::SubscriberQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.presentation)
    && (strm << stru.value.partition)
    && (strm << stru.value.group_data)
    && (strm << stru.value.entity_factory);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SubscriberQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.presentation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.partition)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.group_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.entity_factory)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::SubscriberQos> : MetaStruct {
  typedef  ::DDS::SubscriberQos T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("presentation", 0),
      std::make_pair("partition", 1),
      std::make_pair("group_data", 2),
      std::make_pair("entity_factory", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriberQos)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::SubscriberQos& typed = *static_cast<const  ::DDS::SubscriberQos*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct< ::DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct< ::DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct< ::DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct< ::DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriberQos)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "presentation") {
      return getMetaStruct< ::DDS::PresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'presentation' could not be skipped");
      }
    }
    if (base_field == "partition") {
      return getMetaStruct< ::DDS::PartitionQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PartitionQosPolicy*>(0))) {
        throw std::runtime_error("Field 'partition' could not be skipped");
      }
    }
    if (base_field == "group_data") {
      return getMetaStruct< ::DDS::GroupDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::GroupDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'group_data' could not be skipped");
      }
    }
    if (base_field == "entity_factory") {
      return getMetaStruct< ::DDS::EntityFactoryQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::EntityFactoryQosPolicy*>(0))) {
        throw std::runtime_error("Field 'entity_factory' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct< ::DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct< ::DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct< ::DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct< ::DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriberQos)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"presentation", "partition", "group_data", "entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriberQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const  ::DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const  ::DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const  ::DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const  ::DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriberQos)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriberQos)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::SubscriberQos>()
{
  static MetaStructImpl< ::DDS::SubscriberQos> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::SubscriberQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::SubscriberQos>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DomainParticipantFactoryQos_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(141, 89, 16, 100, 185, 98, 102, 89, 173, 226, 139, 71, 62, 251));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DomainParticipantFactoryQos_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DomainParticipantFactoryQos& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"entity_factory",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.entity_factory)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DomainParticipantFactoryQos& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("entity_factory");
  vwrite(value_writer, value.entity_factory);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DomainParticipantFactoryQos& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.entity_factory);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DomainParticipantFactoryQos& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.entity_factory);
}

bool operator<<(Serializer& strm, const  ::DDS::DomainParticipantFactoryQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm,  ::DDS::DomainParticipantFactoryQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.entity_factory)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DomainParticipantFactoryQos>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.entity_factory);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DomainParticipantFactoryQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.entity_factory);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DomainParticipantFactoryQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.entity_factory)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DomainParticipantFactoryQos> : MetaStruct {
  typedef  ::DDS::DomainParticipantFactoryQos T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("entity_factory", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantFactoryQos)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DomainParticipantFactoryQos& typed = *static_cast<const  ::DDS::DomainParticipantFactoryQos*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct< ::DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantFactoryQos)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "entity_factory") {
      return getMetaStruct< ::DDS::EntityFactoryQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::EntityFactoryQosPolicy*>(0))) {
        throw std::runtime_error("Field 'entity_factory' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct< ::DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantFactoryQos)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantFactoryQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const  ::DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantFactoryQos)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantFactoryQos)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DomainParticipantFactoryQos>()
{
  static MetaStructImpl< ::DDS::DomainParticipantFactoryQos> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DomainParticipantFactoryQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DomainParticipantFactoryQos>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DomainParticipantQos_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(71, 236, 37, 142, 102, 93, 176, 108, 48, 171, 95, 217, 45, 102));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_DomainParticipantQos_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DomainParticipantQos& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"user_data",0},{"entity_factory",1},{"property",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.user_data)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.entity_factory)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.property)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DomainParticipantQos& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("user_data");
  vwrite(value_writer, value.user_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("entity_factory");
  vwrite(value_writer, value.entity_factory);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("property");
  vwrite(value_writer, value.property);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::DomainParticipantQos& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.user_data);
  set_default(stru.entity_factory);
  set_default(stru.property);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DomainParticipantQos& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.user_data);
  serialized_size(encoding, size, stru.entity_factory);
  serialized_size(encoding, size, stru.property);
}

bool operator<<(Serializer& strm, const  ::DDS::DomainParticipantQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.user_data)
    && (strm << stru.entity_factory)
    && (strm << stru.property);
}

bool operator>>(Serializer& strm,  ::DDS::DomainParticipantQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.entity_factory)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.property)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::DomainParticipantQos>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.user_data);
  serialized_size(encoding, size, stru.value.entity_factory);
  serialized_size(encoding, size, stru.value.property);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::DomainParticipantQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.user_data)
    && (strm << stru.value.entity_factory)
    && (strm << stru.value.property);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DomainParticipantQos>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.entity_factory)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.property)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::DomainParticipantQos> : MetaStruct {
  typedef  ::DDS::DomainParticipantQos T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("user_data", 0),
      std::make_pair("entity_factory", 1),
      std::make_pair("property", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantQos)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::DomainParticipantQos& typed = *static_cast<const  ::DDS::DomainParticipantQos*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct< ::DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    if (std::strncmp(field, "property.", 9) == 0) {
      return getMetaStruct< ::DDS::PropertyQosPolicy>().getValue(&typed.property, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantQos)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "user_data") {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::UserDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'user_data' could not be skipped");
      }
    }
    if (base_field == "entity_factory") {
      return getMetaStruct< ::DDS::EntityFactoryQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::EntityFactoryQosPolicy*>(0))) {
        throw std::runtime_error("Field 'entity_factory' could not be skipped");
      }
    }
    if (base_field == "property") {
      return getMetaStruct< ::DDS::PropertyQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PropertyQosPolicy*>(0))) {
        throw std::runtime_error("Field 'property' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct< ::DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct< ::DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "property.", 9) == 0) {
      return make_struct_cmp(&T::property, getMetaStruct< ::DDS::PropertyQosPolicy>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantQos)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"user_data", "entity_factory", "property", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    if (std::strcmp(field, "property") == 0) {
      return &static_cast<const T*>(stru)->property;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const  ::DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const  ::DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "property") == 0) {
      static_cast<T*>(lhs)->property = *static_cast<const  ::DDS::PropertyQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantQos)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::DomainParticipantQos)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::DomainParticipantQos>()
{
  static MetaStructImpl< ::DDS::DomainParticipantQos> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::DomainParticipantQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::DomainParticipantQos>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OctetArray16_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_OctetArray16_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::OctetArray16_forany& arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
    arr[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::OctetArray16_forany& arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size_octet(encoding, size, 16);
}

bool operator<<(Serializer& strm, const  ::DDS::OctetArray16_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_octet_array(arr.in(), 16);
}

bool operator>>(Serializer& strm,  ::DDS::OctetArray16_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_octet_array(arr.out(), 16);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::OctetArray16_forany*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(16, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_BuiltinTopicKey_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_BuiltinTopicKey_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::BuiltinTopicKey_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"value",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.value, 16)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::BuiltinTopicKey_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("value");
  value_writer.begin_array();
  value_writer.write_byte_array (value.value, 16);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::BuiltinTopicKey_t& stru)
{
  ACE_UNUSED_ARG(stru);
   ::DDS::OctetArray16_forany stru_value_temp(const_cast< ::DDS::OctetArray16_slice*>(stru.value));
  set_default(stru_value_temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::BuiltinTopicKey_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value));
  serialized_size(encoding, size, stru_value_forany);
}

bool operator<<(Serializer& strm, const  ::DDS::BuiltinTopicKey_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value));
  return (strm << stru_value_forany);
}

bool operator>>(Serializer& strm,  ::DDS::BuiltinTopicKey_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::BuiltinTopicKey_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.value));
  serialized_size(encoding, size, stru_value_value_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::BuiltinTopicKey_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.value));
  return (strm << stru_value_value_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::BuiltinTopicKey_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_value_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.value));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_value_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::BuiltinTopicKey_t> : MetaStruct {
  typedef  ::DDS::BuiltinTopicKey_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("value", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BuiltinTopicKey_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::BuiltinTopicKey_t& typed = *static_cast<const  ::DDS::BuiltinTopicKey_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BuiltinTopicKey_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetArray16_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BuiltinTopicKey_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BuiltinTopicKey_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
       ::DDS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->value;
      const  ::DDS::OctetArray16* rhsArr = static_cast<const  ::DDS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BuiltinTopicKey_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::BuiltinTopicKey_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::BuiltinTopicKey_t>()
{
  static MetaStructImpl< ::DDS::BuiltinTopicKey_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::BuiltinTopicKey_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::BuiltinTopicKey_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ParticipantBuiltinTopicData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 87, 237, 35, 153, 167, 62, 144, 213, 193, 96, 70, 214, 135));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_ParticipantBuiltinTopicData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ParticipantBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"key",80},{"user_data",44},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 80: {
      if (!vread(value_reader, value.key)) return false;
      break;
    }
    case 44: {
      if (!vread(value_reader, value.user_data)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ParticipantBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("key");
  vwrite(value_writer, value.key);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("user_data");
  vwrite(value_writer, value.user_data);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::ParticipantBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.key);
  set_default(stru.user_data);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::ParticipantBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.key);
  serialized_size(encoding, size, stru.user_data);
}

bool operator<<(Serializer& strm, const  ::DDS::ParticipantBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.key)
    && (strm << stru.user_data);
}

bool operator>>(Serializer& strm,  ::DDS::ParticipantBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::ParticipantBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.key);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::ParticipantBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::ParticipantBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::DDS::ParticipantBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.key);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::DDS::ParticipantBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key);
}

bool operator>>(Serializer& strm, const KeyOnly< ::DDS::ParticipantBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
::DDS::DataWriter_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ParticipantBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ParticipantBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ParticipantBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ParticipantBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool ParticipantBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* ParticipantBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void ParticipantBuiltinTopicDataTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& ParticipantBuiltinTopicDataTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::DDS_ParticipantBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeMap& ParticipantBuiltinTopicDataTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::DDS_ParticipantBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& ParticipantBuiltinTopicDataTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& ParticipantBuiltinTopicDataTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility ParticipantBuiltinTopicDataTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

ParticipantBuiltinTopicDataTypeSupport::_ptr_type ParticipantBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::ParticipantBuiltinTopicData> : MetaStruct {
  typedef  ::DDS::ParticipantBuiltinTopicData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "key.value[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[12]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[13]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[14]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[15]")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("key", 80),
      std::make_pair("user_data", 44),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ParticipantBuiltinTopicData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::ParticipantBuiltinTopicData& typed = *static_cast<const  ::DDS::ParticipantBuiltinTopicData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ParticipantBuiltinTopicData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "key") {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::BuiltinTopicKey_t*>(0))) {
        throw std::runtime_error("Field 'key' could not be skipped");
      }
    }
    if (base_field == "user_data") {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::UserDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'user_data' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct< ::DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct< ::DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ParticipantBuiltinTopicData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "user_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ParticipantBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const  ::DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const  ::DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ParticipantBuiltinTopicData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::ParticipantBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::ParticipantBuiltinTopicData>()
{
  static MetaStructImpl< ::DDS::ParticipantBuiltinTopicData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::ParticipantBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::ParticipantBuiltinTopicData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PublicationBuiltinTopicData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(36, 50, 236, 40, 121, 209, 47, 107, 124, 179, 72, 134, 177, 69));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_PublicationBuiltinTopicData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PublicationBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"key",90},{"participant_key",80},{"topic_name",5},{"type_name",7},{"durability",29},{"durability_service",30},{"deadline",35},{"latency_budget",39},{"liveliness",27},{"reliability",26},{"lifespan",43},{"user_data",44},{"ownership",31},{"ownership_strength",6},{"destination_order",37},{"presentation",33},{"partition",41},{"topic_data",46},{"group_data",45},{"representation",115},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 90: {
      if (!vread(value_reader, value.key)) return false;
      break;
    }
    case 80: {
      if (!vread(value_reader, value.participant_key)) return false;
      break;
    }
    case 5: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.topic_name = x.c_str();
      }
      break;
    }
    case 7: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.type_name = x.c_str();
      }
      break;
    }
    case 29: {
      if (!vread(value_reader, value.durability)) return false;
      break;
    }
    case 30: {
      if (!vread(value_reader, value.durability_service)) return false;
      break;
    }
    case 35: {
      if (!vread(value_reader, value.deadline)) return false;
      break;
    }
    case 39: {
      if (!vread(value_reader, value.latency_budget)) return false;
      break;
    }
    case 27: {
      if (!vread(value_reader, value.liveliness)) return false;
      break;
    }
    case 26: {
      if (!vread(value_reader, value.reliability)) return false;
      break;
    }
    case 43: {
      if (!vread(value_reader, value.lifespan)) return false;
      break;
    }
    case 44: {
      if (!vread(value_reader, value.user_data)) return false;
      break;
    }
    case 31: {
      if (!vread(value_reader, value.ownership)) return false;
      break;
    }
    case 6: {
      if (!vread(value_reader, value.ownership_strength)) return false;
      break;
    }
    case 37: {
      if (!vread(value_reader, value.destination_order)) return false;
      break;
    }
    case 33: {
      if (!vread(value_reader, value.presentation)) return false;
      break;
    }
    case 41: {
      if (!vread(value_reader, value.partition)) return false;
      break;
    }
    case 46: {
      if (!vread(value_reader, value.topic_data)) return false;
      break;
    }
    case 45: {
      if (!vread(value_reader, value.group_data)) return false;
      break;
    }
    case 115: {
      if (!vread(value_reader, value.representation)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PublicationBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("key");
  vwrite(value_writer, value.key);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("participant_key");
  vwrite(value_writer, value.participant_key);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_name");
  value_writer.write_string(value.topic_name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("type_name");
  value_writer.write_string(value.type_name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("durability");
  vwrite(value_writer, value.durability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("durability_service");
  vwrite(value_writer, value.durability_service);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("deadline");
  vwrite(value_writer, value.deadline);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("latency_budget");
  vwrite(value_writer, value.latency_budget);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("liveliness");
  vwrite(value_writer, value.liveliness);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("reliability");
  vwrite(value_writer, value.reliability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("lifespan");
  vwrite(value_writer, value.lifespan);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("user_data");
  vwrite(value_writer, value.user_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ownership");
  vwrite(value_writer, value.ownership);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ownership_strength");
  vwrite(value_writer, value.ownership_strength);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("destination_order");
  vwrite(value_writer, value.destination_order);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("presentation");
  vwrite(value_writer, value.presentation);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("partition");
  vwrite(value_writer, value.partition);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_data");
  vwrite(value_writer, value.topic_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("group_data");
  vwrite(value_writer, value.group_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("representation");
  vwrite(value_writer, value.representation);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::PublicationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.key);
  set_default(stru.participant_key);
  stru.topic_name = "";
  stru.type_name = "";
  set_default(stru.durability);
  set_default(stru.durability_service);
  set_default(stru.deadline);
  set_default(stru.latency_budget);
  set_default(stru.liveliness);
  set_default(stru.reliability);
  set_default(stru.lifespan);
  set_default(stru.user_data);
  set_default(stru.ownership);
  set_default(stru.ownership_strength);
  set_default(stru.destination_order);
  set_default(stru.presentation);
  set_default(stru.partition);
  set_default(stru.topic_data);
  set_default(stru.group_data);
  set_default(stru.representation);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PublicationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.key);
  serialized_size(encoding, size, stru.participant_key);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.topic_name.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.type_name.in()) + 1;
  serialized_size(encoding, size, stru.durability);
  serialized_size(encoding, size, stru.durability_service);
  serialized_size(encoding, size, stru.deadline);
  serialized_size(encoding, size, stru.latency_budget);
  serialized_size(encoding, size, stru.liveliness);
  serialized_size(encoding, size, stru.reliability);
  serialized_size(encoding, size, stru.lifespan);
  serialized_size(encoding, size, stru.user_data);
  serialized_size(encoding, size, stru.ownership);
  serialized_size(encoding, size, stru.ownership_strength);
  serialized_size(encoding, size, stru.destination_order);
  serialized_size(encoding, size, stru.presentation);
  serialized_size(encoding, size, stru.partition);
  serialized_size(encoding, size, stru.topic_data);
  serialized_size(encoding, size, stru.group_data);
  serialized_size(encoding, size, stru.representation);
}

bool operator<<(Serializer& strm, const  ::DDS::PublicationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.key)
    && (strm << stru.participant_key)
    && (strm << stru.topic_name.in())
    && (strm << stru.type_name.in())
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.lifespan)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.ownership_strength)
    && (strm << stru.destination_order)
    && (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.topic_data)
    && (strm << stru.group_data)
    && (strm << stru.representation);
}

bool operator>>(Serializer& strm,  ::DDS::PublicationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.participant_key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.type_name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability_service)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.lifespan)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ownership_strength)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.presentation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.partition)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.group_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::PublicationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.key);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::PublicationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PublicationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::DDS::PublicationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.key);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::DDS::PublicationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key);
}

bool operator>>(Serializer& strm, const KeyOnly< ::DDS::PublicationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
::DDS::DataWriter_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<PublicationBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PublicationBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PublicationBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PublicationBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& PublicationBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PublicationBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool PublicationBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* PublicationBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void PublicationBuiltinTopicDataTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& PublicationBuiltinTopicDataTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::DDS_PublicationBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeMap& PublicationBuiltinTopicDataTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::DDS_PublicationBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& PublicationBuiltinTopicDataTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& PublicationBuiltinTopicDataTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility PublicationBuiltinTopicDataTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

PublicationBuiltinTopicDataTypeSupport::_ptr_type PublicationBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::PublicationBuiltinTopicData> : MetaStruct {
  typedef  ::DDS::PublicationBuiltinTopicData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "key.value[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[12]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[13]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[14]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[15]")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("key", 90),
      std::make_pair("participant_key", 80),
      std::make_pair("topic_name", 5),
      std::make_pair("type_name", 7),
      std::make_pair("durability", 29),
      std::make_pair("durability_service", 30),
      std::make_pair("deadline", 35),
      std::make_pair("latency_budget", 39),
      std::make_pair("liveliness", 27),
      std::make_pair("reliability", 26),
      std::make_pair("lifespan", 43),
      std::make_pair("user_data", 44),
      std::make_pair("ownership", 31),
      std::make_pair("ownership_strength", 6),
      std::make_pair("destination_order", 37),
      std::make_pair("presentation", 33),
      std::make_pair("partition", 41),
      std::make_pair("topic_data", 46),
      std::make_pair("group_data", 45),
      std::make_pair("representation", 115),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 20);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationBuiltinTopicData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::PublicationBuiltinTopicData& typed = *static_cast<const  ::DDS::PublicationBuiltinTopicData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(&typed.participant_key, field + 16);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct< ::DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct< ::DDS::OwnershipStrengthQosPolicy>().getValue(&typed.ownership_strength, field + 19);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct< ::DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct< ::DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct< ::DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct< ::DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(&typed.representation, field + 15);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationBuiltinTopicData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "key") {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::BuiltinTopicKey_t*>(0))) {
        throw std::runtime_error("Field 'key' could not be skipped");
      }
    }
    if (base_field == "participant_key") {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::BuiltinTopicKey_t*>(0))) {
        throw std::runtime_error("Field 'participant_key' could not be skipped");
      }
    }
    if (base_field == "topic_name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'topic_name' contents could not be skipped");
      }
    }
    if (base_field == "type_name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'type_name' contents could not be skipped");
      }
    }
    if (base_field == "durability") {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability' could not be skipped");
      }
    }
    if (base_field == "durability_service") {
      return getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityServiceQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability_service' could not be skipped");
      }
    }
    if (base_field == "deadline") {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DeadlineQosPolicy*>(0))) {
        throw std::runtime_error("Field 'deadline' could not be skipped");
      }
    }
    if (base_field == "latency_budget") {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LatencyBudgetQosPolicy*>(0))) {
        throw std::runtime_error("Field 'latency_budget' could not be skipped");
      }
    }
    if (base_field == "liveliness") {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LivelinessQosPolicy*>(0))) {
        throw std::runtime_error("Field 'liveliness' could not be skipped");
      }
    }
    if (base_field == "reliability") {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ReliabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'reliability' could not be skipped");
      }
    }
    if (base_field == "lifespan") {
      return getMetaStruct< ::DDS::LifespanQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LifespanQosPolicy*>(0))) {
        throw std::runtime_error("Field 'lifespan' could not be skipped");
      }
    }
    if (base_field == "user_data") {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::UserDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'user_data' could not be skipped");
      }
    }
    if (base_field == "ownership") {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::OwnershipQosPolicy*>(0))) {
        throw std::runtime_error("Field 'ownership' could not be skipped");
      }
    }
    if (base_field == "ownership_strength") {
      return getMetaStruct< ::DDS::OwnershipStrengthQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::OwnershipStrengthQosPolicy*>(0))) {
        throw std::runtime_error("Field 'ownership_strength' could not be skipped");
      }
    }
    if (base_field == "destination_order") {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DestinationOrderQosPolicy*>(0))) {
        throw std::runtime_error("Field 'destination_order' could not be skipped");
      }
    }
    if (base_field == "presentation") {
      return getMetaStruct< ::DDS::PresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'presentation' could not be skipped");
      }
    }
    if (base_field == "partition") {
      return getMetaStruct< ::DDS::PartitionQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PartitionQosPolicy*>(0))) {
        throw std::runtime_error("Field 'partition' could not be skipped");
      }
    }
    if (base_field == "topic_data") {
      return getMetaStruct< ::DDS::TopicDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TopicDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'topic_data' could not be skipped");
      }
    }
    if (base_field == "group_data") {
      return getMetaStruct< ::DDS::GroupDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::GroupDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'group_data' could not be skipped");
      }
    }
    if (base_field == "representation") {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DataRepresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'representation' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct< ::DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return make_struct_cmp(&T::participant_key, getMetaStruct< ::DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct< ::DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct< ::DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct< ::DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct< ::DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct< ::DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct< ::DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct< ::DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return make_struct_cmp(&T::ownership_strength, getMetaStruct< ::DDS::OwnershipStrengthQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct< ::DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct< ::DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct< ::DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct< ::DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct< ::DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return make_struct_cmp(&T::representation, getMetaStruct< ::DDS::DataRepresentationQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationBuiltinTopicData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "participant_key", "topic_name", "type_name", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "lifespan", "user_data", "ownership", "ownership_strength", "destination_order", "presentation", "partition", "topic_data", "group_data", "representation", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      return &static_cast<const T*>(stru)->participant_key;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      return &static_cast<const T*>(stru)->ownership_strength;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    if (std::strcmp(field, "representation") == 0) {
      return &static_cast<const T*>(stru)->representation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const  ::DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      static_cast<T*>(lhs)->participant_key = *static_cast<const  ::DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const  ::DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const  ::DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const  ::DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const  ::DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const  ::DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const  ::DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const  ::DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const  ::DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const  ::DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      static_cast<T*>(lhs)->ownership_strength = *static_cast<const  ::DDS::OwnershipStrengthQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const  ::DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const  ::DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const  ::DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const  ::DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const  ::DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "representation") == 0) {
      static_cast<T*>(lhs)->representation = *static_cast<const  ::DDS::DataRepresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationBuiltinTopicData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name.in(), static_cast<const T*>(rhs)->topic_name.in());
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::PublicationBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::PublicationBuiltinTopicData>()
{
  static MetaStructImpl< ::DDS::PublicationBuiltinTopicData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::PublicationBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::PublicationBuiltinTopicData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SubscriptionBuiltinTopicData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 2, 1, 165, 140, 132, 125, 160, 139, 76, 161, 70, 60, 186));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SubscriptionBuiltinTopicData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SubscriptionBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"key",90},{"participant_key",80},{"topic_name",5},{"type_name",7},{"durability",29},{"deadline",35},{"latency_budget",39},{"liveliness",27},{"reliability",26},{"ownership",31},{"destination_order",37},{"user_data",44},{"time_based_filter",4},{"presentation",33},{"partition",41},{"topic_data",46},{"group_data",45},{"representation",115},{"type_consistency",116},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 90: {
      if (!vread(value_reader, value.key)) return false;
      break;
    }
    case 80: {
      if (!vread(value_reader, value.participant_key)) return false;
      break;
    }
    case 5: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.topic_name = x.c_str();
      }
      break;
    }
    case 7: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.type_name = x.c_str();
      }
      break;
    }
    case 29: {
      if (!vread(value_reader, value.durability)) return false;
      break;
    }
    case 35: {
      if (!vread(value_reader, value.deadline)) return false;
      break;
    }
    case 39: {
      if (!vread(value_reader, value.latency_budget)) return false;
      break;
    }
    case 27: {
      if (!vread(value_reader, value.liveliness)) return false;
      break;
    }
    case 26: {
      if (!vread(value_reader, value.reliability)) return false;
      break;
    }
    case 31: {
      if (!vread(value_reader, value.ownership)) return false;
      break;
    }
    case 37: {
      if (!vread(value_reader, value.destination_order)) return false;
      break;
    }
    case 44: {
      if (!vread(value_reader, value.user_data)) return false;
      break;
    }
    case 4: {
      if (!vread(value_reader, value.time_based_filter)) return false;
      break;
    }
    case 33: {
      if (!vread(value_reader, value.presentation)) return false;
      break;
    }
    case 41: {
      if (!vread(value_reader, value.partition)) return false;
      break;
    }
    case 46: {
      if (!vread(value_reader, value.topic_data)) return false;
      break;
    }
    case 45: {
      if (!vread(value_reader, value.group_data)) return false;
      break;
    }
    case 115: {
      if (!vread(value_reader, value.representation)) return false;
      break;
    }
    case 116: {
      if (!vread(value_reader, value.type_consistency)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SubscriptionBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("key");
  vwrite(value_writer, value.key);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("participant_key");
  vwrite(value_writer, value.participant_key);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_name");
  value_writer.write_string(value.topic_name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("type_name");
  value_writer.write_string(value.type_name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("durability");
  vwrite(value_writer, value.durability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("deadline");
  vwrite(value_writer, value.deadline);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("latency_budget");
  vwrite(value_writer, value.latency_budget);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("liveliness");
  vwrite(value_writer, value.liveliness);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("reliability");
  vwrite(value_writer, value.reliability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ownership");
  vwrite(value_writer, value.ownership);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("destination_order");
  vwrite(value_writer, value.destination_order);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("user_data");
  vwrite(value_writer, value.user_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("time_based_filter");
  vwrite(value_writer, value.time_based_filter);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("presentation");
  vwrite(value_writer, value.presentation);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("partition");
  vwrite(value_writer, value.partition);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_data");
  vwrite(value_writer, value.topic_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("group_data");
  vwrite(value_writer, value.group_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("representation");
  vwrite(value_writer, value.representation);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("type_consistency");
  vwrite(value_writer, value.type_consistency);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::SubscriptionBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.key);
  set_default(stru.participant_key);
  stru.topic_name = "";
  stru.type_name = "";
  set_default(stru.durability);
  set_default(stru.deadline);
  set_default(stru.latency_budget);
  set_default(stru.liveliness);
  set_default(stru.reliability);
  set_default(stru.ownership);
  set_default(stru.destination_order);
  set_default(stru.user_data);
  set_default(stru.time_based_filter);
  set_default(stru.presentation);
  set_default(stru.partition);
  set_default(stru.topic_data);
  set_default(stru.group_data);
  set_default(stru.representation);
  set_default(stru.type_consistency);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::SubscriptionBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.key);
  serialized_size(encoding, size, stru.participant_key);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.topic_name.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.type_name.in()) + 1;
  serialized_size(encoding, size, stru.durability);
  serialized_size(encoding, size, stru.deadline);
  serialized_size(encoding, size, stru.latency_budget);
  serialized_size(encoding, size, stru.liveliness);
  serialized_size(encoding, size, stru.reliability);
  serialized_size(encoding, size, stru.ownership);
  serialized_size(encoding, size, stru.destination_order);
  serialized_size(encoding, size, stru.user_data);
  serialized_size(encoding, size, stru.time_based_filter);
  serialized_size(encoding, size, stru.presentation);
  serialized_size(encoding, size, stru.partition);
  serialized_size(encoding, size, stru.topic_data);
  serialized_size(encoding, size, stru.group_data);
  serialized_size(encoding, size, stru.representation);
  serialized_size(encoding, size, stru.type_consistency);
}

bool operator<<(Serializer& strm, const  ::DDS::SubscriptionBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.key)
    && (strm << stru.participant_key)
    && (strm << stru.topic_name.in())
    && (strm << stru.type_name.in())
    && (strm << stru.durability)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.ownership)
    && (strm << stru.destination_order)
    && (strm << stru.user_data)
    && (strm << stru.time_based_filter)
    && (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.topic_data)
    && (strm << stru.group_data)
    && (strm << stru.representation)
    && (strm << stru.type_consistency);
}

bool operator>>(Serializer& strm,  ::DDS::SubscriptionBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.participant_key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.type_name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.user_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.time_based_filter)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.presentation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.partition)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.group_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.type_consistency)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::SubscriptionBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.key);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::SubscriptionBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SubscriptionBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::DDS::SubscriptionBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.key);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::DDS::SubscriptionBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key);
}

bool operator>>(Serializer& strm, const KeyOnly< ::DDS::SubscriptionBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
::DDS::DataWriter_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SubscriptionBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriptionBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriptionBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SubscriptionBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SubscriptionBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SubscriptionBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SubscriptionBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* SubscriptionBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void SubscriptionBuiltinTopicDataTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& SubscriptionBuiltinTopicDataTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::DDS_SubscriptionBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeMap& SubscriptionBuiltinTopicDataTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::DDS_SubscriptionBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& SubscriptionBuiltinTopicDataTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& SubscriptionBuiltinTopicDataTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility SubscriptionBuiltinTopicDataTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

SubscriptionBuiltinTopicDataTypeSupport::_ptr_type SubscriptionBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::SubscriptionBuiltinTopicData> : MetaStruct {
  typedef  ::DDS::SubscriptionBuiltinTopicData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "key.value[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[12]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[13]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[14]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[15]")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("key", 90),
      std::make_pair("participant_key", 80),
      std::make_pair("topic_name", 5),
      std::make_pair("type_name", 7),
      std::make_pair("durability", 29),
      std::make_pair("deadline", 35),
      std::make_pair("latency_budget", 39),
      std::make_pair("liveliness", 27),
      std::make_pair("reliability", 26),
      std::make_pair("ownership", 31),
      std::make_pair("destination_order", 37),
      std::make_pair("user_data", 44),
      std::make_pair("time_based_filter", 4),
      std::make_pair("presentation", 33),
      std::make_pair("partition", 41),
      std::make_pair("topic_data", 46),
      std::make_pair("group_data", 45),
      std::make_pair("representation", 115),
      std::make_pair("type_consistency", 116),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 19);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionBuiltinTopicData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::SubscriptionBuiltinTopicData& typed = *static_cast<const  ::DDS::SubscriptionBuiltinTopicData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(&typed.participant_key, field + 16);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct< ::DDS::TimeBasedFilterQosPolicy>().getValue(&typed.time_based_filter, field + 18);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct< ::DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct< ::DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct< ::DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct< ::DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(&typed.representation, field + 15);
    }
    if (std::strncmp(field, "type_consistency.", 17) == 0) {
      return getMetaStruct< ::DDS::TypeConsistencyEnforcementQosPolicy>().getValue(&typed.type_consistency, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionBuiltinTopicData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "key") {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::BuiltinTopicKey_t*>(0))) {
        throw std::runtime_error("Field 'key' could not be skipped");
      }
    }
    if (base_field == "participant_key") {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::BuiltinTopicKey_t*>(0))) {
        throw std::runtime_error("Field 'participant_key' could not be skipped");
      }
    }
    if (base_field == "topic_name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'topic_name' contents could not be skipped");
      }
    }
    if (base_field == "type_name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'type_name' contents could not be skipped");
      }
    }
    if (base_field == "durability") {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability' could not be skipped");
      }
    }
    if (base_field == "deadline") {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DeadlineQosPolicy*>(0))) {
        throw std::runtime_error("Field 'deadline' could not be skipped");
      }
    }
    if (base_field == "latency_budget") {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LatencyBudgetQosPolicy*>(0))) {
        throw std::runtime_error("Field 'latency_budget' could not be skipped");
      }
    }
    if (base_field == "liveliness") {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LivelinessQosPolicy*>(0))) {
        throw std::runtime_error("Field 'liveliness' could not be skipped");
      }
    }
    if (base_field == "reliability") {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ReliabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'reliability' could not be skipped");
      }
    }
    if (base_field == "ownership") {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::OwnershipQosPolicy*>(0))) {
        throw std::runtime_error("Field 'ownership' could not be skipped");
      }
    }
    if (base_field == "destination_order") {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DestinationOrderQosPolicy*>(0))) {
        throw std::runtime_error("Field 'destination_order' could not be skipped");
      }
    }
    if (base_field == "user_data") {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::UserDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'user_data' could not be skipped");
      }
    }
    if (base_field == "time_based_filter") {
      return getMetaStruct< ::DDS::TimeBasedFilterQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TimeBasedFilterQosPolicy*>(0))) {
        throw std::runtime_error("Field 'time_based_filter' could not be skipped");
      }
    }
    if (base_field == "presentation") {
      return getMetaStruct< ::DDS::PresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'presentation' could not be skipped");
      }
    }
    if (base_field == "partition") {
      return getMetaStruct< ::DDS::PartitionQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::PartitionQosPolicy*>(0))) {
        throw std::runtime_error("Field 'partition' could not be skipped");
      }
    }
    if (base_field == "topic_data") {
      return getMetaStruct< ::DDS::TopicDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TopicDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'topic_data' could not be skipped");
      }
    }
    if (base_field == "group_data") {
      return getMetaStruct< ::DDS::GroupDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::GroupDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'group_data' could not be skipped");
      }
    }
    if (base_field == "representation") {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DataRepresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'representation' could not be skipped");
      }
    }
    if (base_field == "type_consistency") {
      return getMetaStruct< ::DDS::TypeConsistencyEnforcementQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TypeConsistencyEnforcementQosPolicy*>(0))) {
        throw std::runtime_error("Field 'type_consistency' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct< ::DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return make_struct_cmp(&T::participant_key, getMetaStruct< ::DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct< ::DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct< ::DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct< ::DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct< ::DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct< ::DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct< ::DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct< ::DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return make_struct_cmp(&T::time_based_filter, getMetaStruct< ::DDS::TimeBasedFilterQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct< ::DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct< ::DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct< ::DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct< ::DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return make_struct_cmp(&T::representation, getMetaStruct< ::DDS::DataRepresentationQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "type_consistency.", 17) == 0) {
      return make_struct_cmp(&T::type_consistency, getMetaStruct< ::DDS::TypeConsistencyEnforcementQosPolicy>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionBuiltinTopicData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "participant_key", "topic_name", "type_name", "durability", "deadline", "latency_budget", "liveliness", "reliability", "ownership", "destination_order", "user_data", "time_based_filter", "presentation", "partition", "topic_data", "group_data", "representation", "type_consistency", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      return &static_cast<const T*>(stru)->participant_key;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      return &static_cast<const T*>(stru)->time_based_filter;
    }
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    if (std::strcmp(field, "representation") == 0) {
      return &static_cast<const T*>(stru)->representation;
    }
    if (std::strcmp(field, "type_consistency") == 0) {
      return &static_cast<const T*>(stru)->type_consistency;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const  ::DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      static_cast<T*>(lhs)->participant_key = *static_cast<const  ::DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const  ::DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const  ::DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const  ::DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const  ::DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const  ::DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const  ::DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const  ::DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const  ::DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      static_cast<T*>(lhs)->time_based_filter = *static_cast<const  ::DDS::TimeBasedFilterQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const  ::DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const  ::DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const  ::DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const  ::DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "representation") == 0) {
      static_cast<T*>(lhs)->representation = *static_cast<const  ::DDS::DataRepresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_consistency") == 0) {
      static_cast<T*>(lhs)->type_consistency = *static_cast<const  ::DDS::TypeConsistencyEnforcementQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionBuiltinTopicData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name.in(), static_cast<const T*>(rhs)->topic_name.in());
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SubscriptionBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::SubscriptionBuiltinTopicData>()
{
  static MetaStructImpl< ::DDS::SubscriptionBuiltinTopicData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::SubscriptionBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::SubscriptionBuiltinTopicData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TopicBuiltinTopicData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(173, 51, 47, 234, 23, 87, 166, 82, 211, 40, 79, 240, 240, 111));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_TopicBuiltinTopicData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TopicBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"key",90},{"name",5},{"type_name",7},{"durability",29},{"durability_service",30},{"deadline",35},{"latency_budget",39},{"liveliness",27},{"reliability",26},{"transport_priority",73},{"lifespan",43},{"destination_order",37},{"history",64},{"resource_limits",65},{"ownership",31},{"topic_data",46},{"representation",115},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 90: {
      if (!vread(value_reader, value.key)) return false;
      break;
    }
    case 5: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.name = x.c_str();
      }
      break;
    }
    case 7: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.type_name = x.c_str();
      }
      break;
    }
    case 29: {
      if (!vread(value_reader, value.durability)) return false;
      break;
    }
    case 30: {
      if (!vread(value_reader, value.durability_service)) return false;
      break;
    }
    case 35: {
      if (!vread(value_reader, value.deadline)) return false;
      break;
    }
    case 39: {
      if (!vread(value_reader, value.latency_budget)) return false;
      break;
    }
    case 27: {
      if (!vread(value_reader, value.liveliness)) return false;
      break;
    }
    case 26: {
      if (!vread(value_reader, value.reliability)) return false;
      break;
    }
    case 73: {
      if (!vread(value_reader, value.transport_priority)) return false;
      break;
    }
    case 43: {
      if (!vread(value_reader, value.lifespan)) return false;
      break;
    }
    case 37: {
      if (!vread(value_reader, value.destination_order)) return false;
      break;
    }
    case 64: {
      if (!vread(value_reader, value.history)) return false;
      break;
    }
    case 65: {
      if (!vread(value_reader, value.resource_limits)) return false;
      break;
    }
    case 31: {
      if (!vread(value_reader, value.ownership)) return false;
      break;
    }
    case 46: {
      if (!vread(value_reader, value.topic_data)) return false;
      break;
    }
    case 115: {
      if (!vread(value_reader, value.representation)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TopicBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("key");
  vwrite(value_writer, value.key);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("name");
  value_writer.write_string(value.name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("type_name");
  value_writer.write_string(value.type_name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("durability");
  vwrite(value_writer, value.durability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("durability_service");
  vwrite(value_writer, value.durability_service);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("deadline");
  vwrite(value_writer, value.deadline);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("latency_budget");
  vwrite(value_writer, value.latency_budget);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("liveliness");
  vwrite(value_writer, value.liveliness);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("reliability");
  vwrite(value_writer, value.reliability);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transport_priority");
  vwrite(value_writer, value.transport_priority);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("lifespan");
  vwrite(value_writer, value.lifespan);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("destination_order");
  vwrite(value_writer, value.destination_order);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("history");
  vwrite(value_writer, value.history);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("resource_limits");
  vwrite(value_writer, value.resource_limits);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ownership");
  vwrite(value_writer, value.ownership);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_data");
  vwrite(value_writer, value.topic_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("representation");
  vwrite(value_writer, value.representation);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::TopicBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.key);
  stru.name = "";
  stru.type_name = "";
  set_default(stru.durability);
  set_default(stru.durability_service);
  set_default(stru.deadline);
  set_default(stru.latency_budget);
  set_default(stru.liveliness);
  set_default(stru.reliability);
  set_default(stru.transport_priority);
  set_default(stru.lifespan);
  set_default(stru.destination_order);
  set_default(stru.history);
  set_default(stru.resource_limits);
  set_default(stru.ownership);
  set_default(stru.topic_data);
  set_default(stru.representation);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::TopicBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.key);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.name.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.type_name.in()) + 1;
  serialized_size(encoding, size, stru.durability);
  serialized_size(encoding, size, stru.durability_service);
  serialized_size(encoding, size, stru.deadline);
  serialized_size(encoding, size, stru.latency_budget);
  serialized_size(encoding, size, stru.liveliness);
  serialized_size(encoding, size, stru.reliability);
  serialized_size(encoding, size, stru.transport_priority);
  serialized_size(encoding, size, stru.lifespan);
  serialized_size(encoding, size, stru.destination_order);
  serialized_size(encoding, size, stru.history);
  serialized_size(encoding, size, stru.resource_limits);
  serialized_size(encoding, size, stru.ownership);
  serialized_size(encoding, size, stru.topic_data);
  serialized_size(encoding, size, stru.representation);
}

bool operator<<(Serializer& strm, const  ::DDS::TopicBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.key)
    && (strm << stru.name.in())
    && (strm << stru.type_name.in())
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.ownership)
    && (strm << stru.topic_data)
    && (strm << stru.representation);
}

bool operator>>(Serializer& strm,  ::DDS::TopicBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.type_name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.durability_service)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.deadline)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.latency_budget)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.liveliness)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.reliability)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport_priority)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.lifespan)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.destination_order)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.history)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.resource_limits)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ownership)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_data)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.representation)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::TopicBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.key);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::TopicBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TopicBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::DDS::TopicBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.key);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::DDS::TopicBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.key);
}

bool operator>>(Serializer& strm, const KeyOnly< ::DDS::TopicBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.key)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
::DDS::DataWriter_ptr TopicBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<TopicBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr TopicBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr TopicBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<TopicBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& TopicBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TopicBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool TopicBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* TopicBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void TopicBuiltinTopicDataTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& TopicBuiltinTopicDataTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::DDS_TopicBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeMap& TopicBuiltinTopicDataTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::DDS_TopicBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& TopicBuiltinTopicDataTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& TopicBuiltinTopicDataTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility TopicBuiltinTopicDataTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

TopicBuiltinTopicDataTypeSupport::_ptr_type TopicBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::TopicBuiltinTopicData> : MetaStruct {
  typedef  ::DDS::TopicBuiltinTopicData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "key.value[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[12]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[13]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[14]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "key.value[15]")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("key", 90),
      std::make_pair("name", 5),
      std::make_pair("type_name", 7),
      std::make_pair("durability", 29),
      std::make_pair("durability_service", 30),
      std::make_pair("deadline", 35),
      std::make_pair("latency_budget", 39),
      std::make_pair("liveliness", 27),
      std::make_pair("reliability", 26),
      std::make_pair("transport_priority", 73),
      std::make_pair("lifespan", 43),
      std::make_pair("destination_order", 37),
      std::make_pair("history", 64),
      std::make_pair("resource_limits", 65),
      std::make_pair("ownership", 31),
      std::make_pair("topic_data", 46),
      std::make_pair("representation", 115),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 17);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicBuiltinTopicData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::TopicBuiltinTopicData& typed = *static_cast<const  ::DDS::TopicBuiltinTopicData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct< ::DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct< ::DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct< ::DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct< ::DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(&typed.representation, field + 15);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicBuiltinTopicData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "key") {
      return getMetaStruct< ::DDS::BuiltinTopicKey_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::BuiltinTopicKey_t*>(0))) {
        throw std::runtime_error("Field 'key' could not be skipped");
      }
    }
    if (base_field == "name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (base_field == "type_name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'type_name' contents could not be skipped");
      }
    }
    if (base_field == "durability") {
      return getMetaStruct< ::DDS::DurabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability' could not be skipped");
      }
    }
    if (base_field == "durability_service") {
      return getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DurabilityServiceQosPolicy*>(0))) {
        throw std::runtime_error("Field 'durability_service' could not be skipped");
      }
    }
    if (base_field == "deadline") {
      return getMetaStruct< ::DDS::DeadlineQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DeadlineQosPolicy*>(0))) {
        throw std::runtime_error("Field 'deadline' could not be skipped");
      }
    }
    if (base_field == "latency_budget") {
      return getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LatencyBudgetQosPolicy*>(0))) {
        throw std::runtime_error("Field 'latency_budget' could not be skipped");
      }
    }
    if (base_field == "liveliness") {
      return getMetaStruct< ::DDS::LivelinessQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LivelinessQosPolicy*>(0))) {
        throw std::runtime_error("Field 'liveliness' could not be skipped");
      }
    }
    if (base_field == "reliability") {
      return getMetaStruct< ::DDS::ReliabilityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ReliabilityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'reliability' could not be skipped");
      }
    }
    if (base_field == "transport_priority") {
      return getMetaStruct< ::DDS::TransportPriorityQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TransportPriorityQosPolicy*>(0))) {
        throw std::runtime_error("Field 'transport_priority' could not be skipped");
      }
    }
    if (base_field == "lifespan") {
      return getMetaStruct< ::DDS::LifespanQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::LifespanQosPolicy*>(0))) {
        throw std::runtime_error("Field 'lifespan' could not be skipped");
      }
    }
    if (base_field == "destination_order") {
      return getMetaStruct< ::DDS::DestinationOrderQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DestinationOrderQosPolicy*>(0))) {
        throw std::runtime_error("Field 'destination_order' could not be skipped");
      }
    }
    if (base_field == "history") {
      return getMetaStruct< ::DDS::HistoryQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::HistoryQosPolicy*>(0))) {
        throw std::runtime_error("Field 'history' could not be skipped");
      }
    }
    if (base_field == "resource_limits") {
      return getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::ResourceLimitsQosPolicy*>(0))) {
        throw std::runtime_error("Field 'resource_limits' could not be skipped");
      }
    }
    if (base_field == "ownership") {
      return getMetaStruct< ::DDS::OwnershipQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::OwnershipQosPolicy*>(0))) {
        throw std::runtime_error("Field 'ownership' could not be skipped");
      }
    }
    if (base_field == "topic_data") {
      return getMetaStruct< ::DDS::TopicDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::TopicDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'topic_data' could not be skipped");
      }
    }
    if (base_field == "representation") {
      return getMetaStruct< ::DDS::DataRepresentationQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::DataRepresentationQosPolicy*>(0))) {
        throw std::runtime_error("Field 'representation' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct< ::DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
    }
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct< ::DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct< ::DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct< ::DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct< ::DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct< ::DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct< ::DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct< ::DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct< ::DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct< ::DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct< ::DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct< ::DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct< ::DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct< ::DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "representation.", 15) == 0) {
      return make_struct_cmp(&T::representation, getMetaStruct< ::DDS::DataRepresentationQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicBuiltinTopicData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "name", "type_name", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "transport_priority", "lifespan", "destination_order", "history", "resource_limits", "ownership", "topic_data", "representation", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "representation") == 0) {
      return &static_cast<const T*>(stru)->representation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const  ::DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const  ::DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const  ::DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const  ::DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const  ::DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const  ::DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const  ::DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const  ::DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const  ::DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const  ::DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const  ::DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const  ::DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const  ::DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const  ::DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "representation") == 0) {
      static_cast<T*>(lhs)->representation = *static_cast<const  ::DDS::DataRepresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicBuiltinTopicData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::TopicBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::TopicBuiltinTopicData>()
{
  static MetaStructImpl< ::DDS::TopicBuiltinTopicData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::TopicBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::TopicBuiltinTopicData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleStateKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleStateKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleStateMask_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleStateMask_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ViewStateKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_ViewStateKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ViewStateMask_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_ViewStateMask_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InstanceStateKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_InstanceStateKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InstanceStateMask_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_InstanceStateMask_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_Time_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_Time_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::Time_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"sec",0},{"nanosec",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.sec)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.nanosec)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::Time_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("sec");
  value_writer.write_int32(value.sec);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("nanosec");
  value_writer.write_uint32(value.nanosec);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::Time_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.sec = 0;
  stru.nanosec = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::Time_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.sec);
  primitive_serialized_size(encoding, size, stru.nanosec);
}

bool operator<<(Serializer& strm, const  ::DDS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.sec)
    && (strm << stru.nanosec);
}

bool operator>>(Serializer& strm,  ::DDS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.sec)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.nanosec)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::Time_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.sec);
  primitive_serialized_size(encoding, size, stru.value.nanosec);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::Time_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.sec)
    && (strm << stru.value.nanosec);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::Time_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.sec)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.nanosec)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::Time_t> : MetaStruct {
  typedef  ::DDS::Time_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("sec", 0),
      std::make_pair("nanosec", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Time_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::Time_t& typed = *static_cast<const  ::DDS::Time_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "sec") == 0) {
      return typed.sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return typed.nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Time_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "sec") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sec' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sec' could not be skipped");
      }
    }
    if (base_field == "nanosec") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'nanosec' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'nanosec' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sec") == 0) {
      return make_field_cmp(&T::sec, next);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return make_field_cmp(&T::nanosec, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Time_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"sec", "nanosec", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      return &static_cast<const T*>(stru)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return &static_cast<const T*>(stru)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Time_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sec") == 0) {
      static_cast<T*>(lhs)->sec = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      static_cast<T*>(lhs)->nanosec = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Time_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sec") == 0) {
      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::Time_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::Time_t>()
{
  static MetaStructImpl< ::DDS::Time_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::Time_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::Time_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleInfo_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(39, 212, 102, 245, 20, 74, 129, 107, 105, 171, 140, 166, 227, 29));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleInfo_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SampleInfo& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"sample_state",0},{"view_state",1},{"instance_state",2},{"source_timestamp",3},{"instance_handle",4},{"publication_handle",5},{"disposed_generation_count",6},{"no_writers_generation_count",7},{"sample_rank",8},{"generation_rank",9},{"absolute_generation_rank",10},{"valid_data",11},{"opendds_reserved_publication_seq",12},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_uint32(value.sample_state)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.view_state)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint32(value.instance_state)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.source_timestamp)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_int32(value.instance_handle)) return false;
      break;
    }
    case 5: {
      if (!value_reader.read_int32(value.publication_handle)) return false;
      break;
    }
    case 6: {
      if (!value_reader.read_int32(value.disposed_generation_count)) return false;
      break;
    }
    case 7: {
      if (!value_reader.read_int32(value.no_writers_generation_count)) return false;
      break;
    }
    case 8: {
      if (!value_reader.read_int32(value.sample_rank)) return false;
      break;
    }
    case 9: {
      if (!value_reader.read_int32(value.generation_rank)) return false;
      break;
    }
    case 10: {
      if (!value_reader.read_int32(value.absolute_generation_rank)) return false;
      break;
    }
    case 11: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.valid_data = bx;
      }
      break;
    }
    case 12: {
      if (!value_reader.read_int64(value.opendds_reserved_publication_seq)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SampleInfo& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("sample_state");
  value_writer.write_uint32(value.sample_state);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("view_state");
  value_writer.write_uint32(value.view_state);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("instance_state");
  value_writer.write_uint32(value.instance_state);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("source_timestamp");
  vwrite(value_writer, value.source_timestamp);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("instance_handle");
  value_writer.write_int32(value.instance_handle);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("publication_handle");
  value_writer.write_int32(value.publication_handle);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("disposed_generation_count");
  value_writer.write_int32(value.disposed_generation_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("no_writers_generation_count");
  value_writer.write_int32(value.no_writers_generation_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("sample_rank");
  value_writer.write_int32(value.sample_rank);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("generation_rank");
  value_writer.write_int32(value.generation_rank);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("absolute_generation_rank");
  value_writer.write_int32(value.absolute_generation_rank);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("valid_data");
  value_writer.write_boolean(value.valid_data);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("opendds_reserved_publication_seq");
  value_writer.write_int64(value.opendds_reserved_publication_seq);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::DDS::SampleInfo& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.sample_state = 0;
  stru.view_state = 0;
  stru.instance_state = 0;
  set_default(stru.source_timestamp);
  stru.instance_handle = 0;
  stru.publication_handle = 0;
  stru.disposed_generation_count = 0;
  stru.no_writers_generation_count = 0;
  stru.sample_rank = 0;
  stru.generation_rank = 0;
  stru.absolute_generation_rank = 0;
  stru.valid_data = 0;
  stru.opendds_reserved_publication_seq = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::SampleInfo& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.sample_state);
  primitive_serialized_size(encoding, size, stru.view_state);
  primitive_serialized_size(encoding, size, stru.instance_state);
  serialized_size(encoding, size, stru.source_timestamp);
  primitive_serialized_size(encoding, size, stru.instance_handle);
  primitive_serialized_size(encoding, size, stru.publication_handle);
  primitive_serialized_size(encoding, size, stru.disposed_generation_count);
  primitive_serialized_size(encoding, size, stru.no_writers_generation_count);
  primitive_serialized_size(encoding, size, stru.sample_rank);
  primitive_serialized_size(encoding, size, stru.generation_rank);
  primitive_serialized_size(encoding, size, stru.absolute_generation_rank);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.valid_data));
  primitive_serialized_size(encoding, size, stru.opendds_reserved_publication_seq);
}

bool operator<<(Serializer& strm, const  ::DDS::SampleInfo& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.sample_state)
    && (strm << stru.view_state)
    && (strm << stru.instance_state)
    && (strm << stru.source_timestamp)
    && (strm << stru.instance_handle)
    && (strm << stru.publication_handle)
    && (strm << stru.disposed_generation_count)
    && (strm << stru.no_writers_generation_count)
    && (strm << stru.sample_rank)
    && (strm << stru.generation_rank)
    && (strm << stru.absolute_generation_rank)
    && (strm << ACE_OutputCDR::from_boolean(stru.valid_data))
    && (strm << stru.opendds_reserved_publication_seq);
}

bool operator>>(Serializer& strm,  ::DDS::SampleInfo& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.sample_state)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.view_state)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.instance_state)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.source_timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.instance_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.publication_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.disposed_generation_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.no_writers_generation_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.sample_rank)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.generation_rank)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.absolute_generation_rank)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.valid_data))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.opendds_reserved_publication_seq)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::DDS::SampleInfo>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.sample_state);
  primitive_serialized_size(encoding, size, stru.value.view_state);
  primitive_serialized_size(encoding, size, stru.value.instance_state);
  serialized_size(encoding, size, stru.value.source_timestamp);
  primitive_serialized_size(encoding, size, stru.value.instance_handle);
  primitive_serialized_size(encoding, size, stru.value.publication_handle);
  primitive_serialized_size(encoding, size, stru.value.disposed_generation_count);
  primitive_serialized_size(encoding, size, stru.value.no_writers_generation_count);
  primitive_serialized_size(encoding, size, stru.value.sample_rank);
  primitive_serialized_size(encoding, size, stru.value.generation_rank);
  primitive_serialized_size(encoding, size, stru.value.absolute_generation_rank);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.value.valid_data));
  primitive_serialized_size(encoding, size, stru.value.opendds_reserved_publication_seq);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::DDS::SampleInfo>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.sample_state)
    && (strm << stru.value.view_state)
    && (strm << stru.value.instance_state)
    && (strm << stru.value.source_timestamp)
    && (strm << stru.value.instance_handle)
    && (strm << stru.value.publication_handle)
    && (strm << stru.value.disposed_generation_count)
    && (strm << stru.value.no_writers_generation_count)
    && (strm << stru.value.sample_rank)
    && (strm << stru.value.generation_rank)
    && (strm << stru.value.absolute_generation_rank)
    && (strm << ACE_OutputCDR::from_boolean(stru.value.valid_data))
    && (strm << stru.value.opendds_reserved_publication_seq);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SampleInfo>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.sample_state)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.view_state)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.instance_state)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.source_timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.instance_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.publication_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.disposed_generation_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.no_writers_generation_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.sample_rank)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.generation_rank)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.absolute_generation_rank)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.value.valid_data))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.opendds_reserved_publication_seq)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::DDS::SampleInfo> : MetaStruct {
  typedef  ::DDS::SampleInfo T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("sample_state", 0),
      std::make_pair("view_state", 1),
      std::make_pair("instance_state", 2),
      std::make_pair("source_timestamp", 3),
      std::make_pair("instance_handle", 4),
      std::make_pair("publication_handle", 5),
      std::make_pair("disposed_generation_count", 6),
      std::make_pair("no_writers_generation_count", 7),
      std::make_pair("sample_rank", 8),
      std::make_pair("generation_rank", 9),
      std::make_pair("absolute_generation_rank", 10),
      std::make_pair("valid_data", 11),
      std::make_pair("opendds_reserved_publication_seq", 12),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 13);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleInfo)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::DDS::SampleInfo& typed = *static_cast<const  ::DDS::SampleInfo*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "sample_state") == 0) {
      return typed.sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return typed.view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return typed.instance_state;
    }
    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
      return getMetaStruct< ::DDS::Time_t>().getValue(&typed.source_timestamp, field + 17);
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return typed.instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return typed.publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return typed.disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return typed.no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return typed.sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return typed.generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return typed.absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return typed.valid_data;
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      return typed.opendds_reserved_publication_seq;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleInfo)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "sample_state") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sample_state' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sample_state' could not be skipped");
      }
    }
    if (base_field == "view_state") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'view_state' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'view_state' could not be skipped");
      }
    }
    if (base_field == "instance_state") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'instance_state' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'instance_state' could not be skipped");
      }
    }
    if (base_field == "source_timestamp") {
      return getMetaStruct< ::DDS::Time_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Time_t*>(0))) {
        throw std::runtime_error("Field 'source_timestamp' could not be skipped");
      }
    }
    if (base_field == "instance_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'instance_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'instance_handle' could not be skipped");
      }
    }
    if (base_field == "publication_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'publication_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'publication_handle' could not be skipped");
      }
    }
    if (base_field == "disposed_generation_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'disposed_generation_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'disposed_generation_count' could not be skipped");
      }
    }
    if (base_field == "no_writers_generation_count") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'no_writers_generation_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'no_writers_generation_count' could not be skipped");
      }
    }
    if (base_field == "sample_rank") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sample_rank' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sample_rank' could not be skipped");
      }
    }
    if (base_field == "generation_rank") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'generation_rank' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'generation_rank' could not be skipped");
      }
    }
    if (base_field == "absolute_generation_rank") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'absolute_generation_rank' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'absolute_generation_rank' could not be skipped");
      }
    }
    if (base_field == "valid_data") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'valid_data' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'valid_data' could not be skipped");
      }
    }
    if (base_field == "opendds_reserved_publication_seq") {
      ACE_CDR::LongLong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'opendds_reserved_publication_seq' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'opendds_reserved_publication_seq' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sample_state") == 0) {
      return make_field_cmp(&T::sample_state, next);
    }
    if (std::strcmp(field, "view_state") == 0) {
      return make_field_cmp(&T::view_state, next);
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return make_field_cmp(&T::instance_state, next);
    }
    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
      return make_struct_cmp(&T::source_timestamp, getMetaStruct< ::DDS::Time_t>().create_qc_comparator(field + 17), next);
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return make_field_cmp(&T::instance_handle, next);
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return make_field_cmp(&T::publication_handle, next);
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return make_field_cmp(&T::disposed_generation_count, next);
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return make_field_cmp(&T::no_writers_generation_count, next);
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return make_field_cmp(&T::sample_rank, next);
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return make_field_cmp(&T::generation_rank, next);
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return make_field_cmp(&T::absolute_generation_rank, next);
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return make_field_cmp(&T::valid_data, next);
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      return make_field_cmp(&T::opendds_reserved_publication_seq, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleInfo)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"sample_state", "view_state", "instance_state", "source_timestamp", "instance_handle", "publication_handle", "disposed_generation_count", "no_writers_generation_count", "sample_rank", "generation_rank", "absolute_generation_rank", "valid_data", "opendds_reserved_publication_seq", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sample_state") == 0) {
      return &static_cast<const T*>(stru)->sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return &static_cast<const T*>(stru)->view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return &static_cast<const T*>(stru)->instance_state;
    }
    if (std::strcmp(field, "source_timestamp") == 0) {
      return &static_cast<const T*>(stru)->source_timestamp;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return &static_cast<const T*>(stru)->instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return &static_cast<const T*>(stru)->publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return &static_cast<const T*>(stru)->disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return &static_cast<const T*>(stru)->no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return &static_cast<const T*>(stru)->sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return &static_cast<const T*>(stru)->generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return &static_cast<const T*>(stru)->absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return &static_cast<const T*>(stru)->valid_data;
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      return &static_cast<const T*>(stru)->opendds_reserved_publication_seq;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleInfo)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sample_state") == 0) {
      static_cast<T*>(lhs)->sample_state = *static_cast<const  ::DDS::SampleStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "view_state") == 0) {
      static_cast<T*>(lhs)->view_state = *static_cast<const  ::DDS::ViewStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      static_cast<T*>(lhs)->instance_state = *static_cast<const  ::DDS::InstanceStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "source_timestamp") == 0) {
      static_cast<T*>(lhs)->source_timestamp = *static_cast<const  ::DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      static_cast<T*>(lhs)->instance_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      static_cast<T*>(lhs)->publication_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      static_cast<T*>(lhs)->disposed_generation_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      static_cast<T*>(lhs)->no_writers_generation_count = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      static_cast<T*>(lhs)->sample_rank = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      static_cast<T*>(lhs)->generation_rank = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      static_cast<T*>(lhs)->absolute_generation_rank = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      static_cast<T*>(lhs)->valid_data = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      static_cast<T*>(lhs)->opendds_reserved_publication_seq = *static_cast<const  ::CORBA::LongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleInfo)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sample_state") == 0) {
      return static_cast<const T*>(lhs)->sample_state == static_cast<const T*>(rhs)->sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return static_cast<const T*>(lhs)->view_state == static_cast<const T*>(rhs)->view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return static_cast<const T*>(lhs)->instance_state == static_cast<const T*>(rhs)->instance_state;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return static_cast<const T*>(lhs)->instance_handle == static_cast<const T*>(rhs)->instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return static_cast<const T*>(lhs)->publication_handle == static_cast<const T*>(rhs)->publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return static_cast<const T*>(lhs)->disposed_generation_count == static_cast<const T*>(rhs)->disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return static_cast<const T*>(lhs)->no_writers_generation_count == static_cast<const T*>(rhs)->no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return static_cast<const T*>(lhs)->sample_rank == static_cast<const T*>(rhs)->sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return static_cast<const T*>(lhs)->generation_rank == static_cast<const T*>(rhs)->generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return static_cast<const T*>(lhs)->absolute_generation_rank == static_cast<const T*>(rhs)->absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return static_cast<const T*>(lhs)->valid_data == static_cast<const T*>(rhs)->valid_data;
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      return static_cast<const T*>(lhs)->opendds_reserved_publication_seq == static_cast<const T*>(rhs)->opendds_reserved_publication_seq;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::DDS::SampleInfo)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::DDS::SampleInfo>()
{
  static MetaStructImpl< ::DDS::SampleInfo> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::DDS::SampleInfo*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::DDS::SampleInfo>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleInfoSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(252, 160, 46, 120, 240, 108, 5, 183, 248, 205, 5, 172, 103, 237));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleInfoSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::SampleInfoSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::DDS::SampleInfoSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::DDS::SampleInfoSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::DDS::SampleInfoSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::DDS::SampleInfoSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::DDS::SampleInfoSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::DDS::SampleInfo*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

namespace {
XTypes::TypeObject minimal_to0()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(146, 200, 199, 70))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(27, 204, 23, 153))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(107, 155, 68, 175))))));
}

XTypes::TypeObject minimal_to1()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))), XTypes::MinimalMemberDetail(43, 95, 162, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))), XTypes::MinimalMemberDetail(60, 209, 95, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))), XTypes::MinimalMemberDetail(15, 202, 164, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(27, 42, 197, 216))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(13, 138, 191, 79))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(170, 93, 128, 221))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(14, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(151, 133, 93, 97, 88, 230, 235, 85, 240, 208, 235, 75, 68, 253))), XTypes::MinimalMemberDetail(161, 47, 124, 21))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(15, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))))));
}

XTypes::TypeObject minimal_to2()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to3()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(124, 184, 31, 69))))));
}

XTypes::TypeObject minimal_to4()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(235, 102, 36, 53))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(170, 93, 128, 221))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(34, 23, 141, 102))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(26, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(27, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(29, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(30, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))), XTypes::MinimalMemberDetail(43, 95, 162, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(31, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(33, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))), XTypes::MinimalMemberDetail(36, 134, 146, 58))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(35, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(37, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(39, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(41, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))), XTypes::MinimalMemberDetail(112, 19, 186, 155))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(43, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(13, 138, 191, 79))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(44, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(45, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(249, 86, 165, 139))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(46, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(141, 115, 88, 91))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(129, 113, 223, 135))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(90, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(60, 110, 11, 138))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(115, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))))));
}

XTypes::TypeObject minimal_to5()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(138, 32, 181, 100))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(137, 114, 217, 68))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(52, 161, 97, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(36, 52, 76, 9))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(68, 158, 174, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(199, 246, 250, 141))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(244, 196, 152, 47))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(191, 91, 95, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(42, 252, 121, 215))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(198, 227, 151, 196))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(78, 71, 187, 204))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(25, 133, 74, 216))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT64)), XTypes::MinimalMemberDetail(212, 174, 198, 112))))));
}

XTypes::TypeObject minimal_to6()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(32, 99, 193, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(143, 108, 196, 87))))));
}

XTypes::TypeObject minimal_to7()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211)))))))));
}

XTypes::TypeObject minimal_to8()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))), XTypes::MinimalMemberDetail(60, 209, 95, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))), XTypes::MinimalMemberDetail(15, 202, 164, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37))), XTypes::MinimalMemberDetail(248, 53, 38, 241))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(128, 6, 106, 169, 239, 151, 91, 255, 81, 243, 37, 38, 187, 17))), XTypes::MinimalMemberDetail(201, 231, 175, 233))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225))), XTypes::MinimalMemberDetail(184, 135, 19, 246))))));
}

XTypes::TypeObject minimal_to9()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to10()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 124, 74, 82, 33, 209, 171, 154, 100, 92, 69, 182, 34, 215))), XTypes::MinimalMemberDetail(144, 105, 124, 76))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(28, 106, 127, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(25, 186, 87, 68))))));
}

XTypes::TypeObject minimal_to11()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(184, 94, 195, 20))))));
}

XTypes::TypeObject minimal_to12()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(233, 42, 172, 155))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(208, 123, 134, 189))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(11, 60, 225, 99))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(3, 0), XTypes::MinimalMemberDetail(47, 181, 127, 223))))));
}

XTypes::TypeObject minimal_to13()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(212, 19, 36, 204, 216, 207, 229, 8, 101, 152, 15, 215, 71, 23))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to14()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(16), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to15()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148)))))))));
}

XTypes::TypeObject minimal_to16()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(116, 69, 156, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 4, 100, 213))))));
}

XTypes::TypeObject minimal_to17()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(208, 131, 188, 155, 96, 118, 238, 78, 31, 220, 1, 243, 99, 160))), XTypes::MinimalMemberDetail(196, 4, 33, 100))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(74, 39, 56, 203, 127, 182, 9, 1, 220, 224, 1, 152, 231, 249))), XTypes::MinimalMemberDetail(26, 141, 180, 201))))));
}

XTypes::TypeObject minimal_to18()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(106, 77, 176, 72, 18, 12, 173, 22, 88, 169, 114, 73, 204, 116))), XTypes::MinimalMemberDetail(32, 99, 193, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(125, 68, 172, 132, 224, 239, 218, 60, 192, 71, 15, 147, 30, 246))), XTypes::MinimalMemberDetail(153, 141, 15, 107))))));
}

XTypes::TypeObject minimal_to19()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(18, 160, 85, 191))))));
}

XTypes::TypeObject minimal_to20()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(62, 114, 125, 184, 14, 246, 184, 86, 96, 15, 47, 72, 182, 26))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to21()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(47, 136, 233, 191, 112, 193, 42, 150, 67, 246, 172, 37, 197, 132)))))))));
}

XTypes::TypeObject minimal_to22()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_UINT32))))));
}

XTypes::TypeObject minimal_to23()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(104, 240, 63, 69))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(106, 40, 90, 134))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(230, 32, 45, 146))))));
}

XTypes::TypeObject minimal_to24()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to25()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(12, 87, 212, 43))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))), XTypes::MinimalMemberDetail(35, 210, 249, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(82, 73, 45, 112))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(167, 83, 247, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(65, 192, 149, 169))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(1, 216, 160, 135))))));
}

XTypes::TypeObject minimal_to26()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(1, 78, 93, 82, 90, 169, 236, 225, 40, 97, 126, 118, 81, 144))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(223, 134, 34, 208))))));
}

XTypes::TypeObject minimal_to27()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(251, 95, 64, 60, 163, 23, 170, 158, 193, 148, 167, 7, 12, 36)))))))));
}

XTypes::TypeObject minimal_to28()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))), XTypes::MinimalMemberDetail(36, 134, 146, 58))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))), XTypes::MinimalMemberDetail(112, 19, 186, 155))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(249, 86, 165, 139))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(208, 131, 188, 155, 96, 118, 238, 78, 31, 220, 1, 243, 99, 160))), XTypes::MinimalMemberDetail(196, 4, 33, 100))))));
}

XTypes::TypeObject minimal_to29()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(217, 161, 56, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(157, 130, 84, 170))))));
}

XTypes::TypeObject minimal_to30()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(167, 83, 247, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(65, 192, 149, 169))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(1, 216, 160, 135))))));
}

XTypes::TypeObject minimal_to31()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(208, 131, 188, 155, 96, 118, 238, 78, 31, 220, 1, 243, 99, 160))), XTypes::MinimalMemberDetail(196, 4, 33, 100))))));
}

XTypes::TypeObject minimal_to32()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT32))))));
}

XTypes::TypeObject minimal_to33()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(174, 221, 205, 216))))));
}

XTypes::TypeObject minimal_to34()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(64, 188, 63, 150))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(5, 165, 180, 122))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(107, 61, 225, 31))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(70, 41, 47, 174))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(245, 160, 163, 241))))));
}

XTypes::TypeObject minimal_to35()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0)))))))));
}

XTypes::TypeObject minimal_to36()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(122, 244, 39, 138))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(142, 251, 174, 249))))));
}

XTypes::TypeObject minimal_to37()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(34, 23, 141, 102))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(26, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(27, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(29, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(30, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))), XTypes::MinimalMemberDetail(43, 95, 162, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(31, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(35, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(37, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(39, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(43, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(13, 138, 191, 79))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(46, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(141, 115, 88, 91))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(64, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))), XTypes::MinimalMemberDetail(60, 209, 95, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(65, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))), XTypes::MinimalMemberDetail(15, 202, 164, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(73, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(27, 42, 197, 216))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(90, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(60, 110, 11, 138))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(115, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))))));
}

XTypes::TypeObject minimal_to38()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(187, 206, 175, 130, 167, 249, 57, 105, 219, 219, 138, 84, 110, 94)))))))));
}

XTypes::TypeObject minimal_to39()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37))), XTypes::MinimalMemberDetail(248, 53, 38, 241))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(235, 102, 36, 53))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(34, 23, 141, 102))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(26, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(27, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(29, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(31, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(33, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))), XTypes::MinimalMemberDetail(36, 134, 146, 58))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(35, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(37, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(39, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(41, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))), XTypes::MinimalMemberDetail(112, 19, 186, 155))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(44, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(45, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(249, 86, 165, 139))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(46, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(141, 115, 88, 91))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(129, 113, 223, 135))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(90, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(60, 110, 11, 138))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(115, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(116, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225))), XTypes::MinimalMemberDetail(184, 135, 19, 246))))));
}

XTypes::TypeObject minimal_to40()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT16))))));
}

XTypes::TypeObject minimal_to41()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(202, 176, 202, 19))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(226, 148, 42, 4))))));
}

XTypes::TypeObject minimal_to42()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(176, 104, 147, 28))))));
}

XTypes::TypeObject minimal_to43()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(16, 167, 14, 140))))));
}

XTypes::TypeObject minimal_to44()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to45()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(253, 72, 63, 147, 206, 16, 241, 72, 186, 231, 206, 213, 79, 158))), XTypes::MinimalMemberDetail(217, 57, 170, 247))))));
}

XTypes::TypeObject minimal_to46()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(43, 67, 125, 32))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(249, 191, 143, 65))))));
}

XTypes::TypeObject minimal_to47()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 31, 169, 229, 223, 19, 38, 65, 134, 73, 192, 156, 90, 188))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to48()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(141, 115, 88, 91))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))), XTypes::MinimalMemberDetail(253, 205, 10, 37))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))), XTypes::MinimalMemberDetail(43, 95, 162, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))), XTypes::MinimalMemberDetail(48, 228, 130, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(229, 133, 229, 140))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))), XTypes::MinimalMemberDetail(80, 95, 23, 227))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))), XTypes::MinimalMemberDetail(70, 79, 228, 234))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))), XTypes::MinimalMemberDetail(242, 66, 248, 89))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))), XTypes::MinimalMemberDetail(60, 209, 95, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))), XTypes::MinimalMemberDetail(15, 202, 164, 60))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))), XTypes::MinimalMemberDetail(27, 42, 197, 216))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))), XTypes::MinimalMemberDetail(13, 138, 191, 79))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))), XTypes::MinimalMemberDetail(180, 107, 81, 123))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))), XTypes::MinimalMemberDetail(238, 22, 117, 90))))));
}

XTypes::TypeObject minimal_to49()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 115, 43, 233, 139, 29, 28, 130, 117, 249, 188, 147, 54, 250))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(2, 5, 193, 190))))));
}

XTypes::TypeObject minimal_to50()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(68, 71, 41, 218))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(139, 230, 147, 131))))));
}

XTypes::TypeObject minimal_to51()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(44, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))), XTypes::MinimalMemberDetail(60, 110, 11, 138))))));
}

XTypes::TypeObject minimal_to52()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))), XTypes::MinimalMemberDetail(160, 172, 250, 70))))));
}

XTypes::TypeObject minimal_to53()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(32, 99, 193, 96))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(143, 108, 196, 87))))));
}

XTypes::TypeObject minimal_to54()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(39, 212, 102, 245, 20, 74, 129, 107, 105, 171, 140, 166, 227, 29)))))))));
}

XTypes::TypeObject minimal_to55()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(107, 157, 171, 99))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(175, 93, 205, 154))))));
}

XTypes::TypeObject minimal_to56()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(116, 69, 156, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 4, 100, 213))))));
}

XTypes::TypeMap get_minimal_type_map_private()
{
  XTypes::TypeMap tm;
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(1, 78, 93, 82, 90, 169, 236, 225, 40, 97, 126, 118, 81, 144))] = minimal_to0();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(9, 122, 150, 104, 250, 78, 157, 83, 255, 157, 123, 250, 229, 93))] = minimal_to1();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(25, 67, 250, 122, 13, 90, 110, 57, 209, 137, 148, 16, 109, 181))] = minimal_to2();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(31, 6, 116, 55, 219, 248, 173, 205, 16, 32, 79, 197, 188, 37))] = minimal_to3();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(36, 50, 236, 40, 121, 209, 47, 107, 124, 179, 72, 134, 177, 69))] = minimal_to4();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(39, 212, 102, 245, 20, 74, 129, 107, 105, 171, 140, 166, 227, 29))] = minimal_to5();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(47, 136, 233, 191, 112, 193, 42, 150, 67, 246, 172, 37, 197, 132))] = minimal_to6();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(54, 134, 32, 238, 30, 39, 9, 207, 228, 231, 150, 1, 254, 148))] = minimal_to7();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(55, 10, 190, 230, 50, 127, 48, 223, 212, 68, 18, 125, 171, 30))] = minimal_to8();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 105, 130, 244, 157, 180, 157, 207, 230, 211, 204, 157, 170, 152))] = minimal_to9();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(59, 149, 192, 63, 50, 11, 43, 195, 162, 242, 193, 5, 215, 102))] = minimal_to10();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(60, 117, 248, 112, 147, 91, 68, 168, 11, 3, 20, 69, 18, 103))] = minimal_to11();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(62, 114, 125, 184, 14, 246, 184, 86, 96, 15, 47, 72, 182, 26))] = minimal_to12();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(64, 153, 42, 211, 60, 176, 197, 202, 87, 208, 76, 33, 217, 95))] = minimal_to13();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))] = minimal_to14();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 31, 169, 229, 223, 19, 38, 65, 134, 73, 192, 156, 90, 188))] = minimal_to15();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))] = minimal_to16();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(71, 236, 37, 142, 102, 93, 176, 108, 48, 171, 95, 217, 45, 102))] = minimal_to17();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(74, 39, 56, 203, 127, 182, 9, 1, 220, 224, 1, 152, 231, 249))] = minimal_to18();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(92, 134, 207, 218, 252, 230, 84, 67, 234, 253, 117, 33, 200, 190))] = minimal_to19();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(100, 238, 166, 39, 32, 19, 40, 15, 122, 38, 196, 108, 92, 235))] = minimal_to20();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(106, 77, 176, 72, 18, 12, 173, 22, 88, 169, 114, 73, 204, 116))] = minimal_to21();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))] = minimal_to22();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 124, 74, 82, 33, 209, 171, 154, 100, 92, 69, 182, 34, 215))] = minimal_to23();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))] = minimal_to24();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 181, 151, 115, 213, 177, 180, 9, 132, 39, 177, 177, 17, 73))] = minimal_to25();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(124, 142, 29, 210, 235, 194, 71, 74, 224, 238, 85, 212, 254, 14))] = minimal_to26();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(125, 68, 172, 132, 224, 239, 218, 60, 192, 71, 15, 147, 30, 246))] = minimal_to27();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(126, 56, 73, 18, 9, 183, 3, 167, 93, 113, 230, 154, 87, 113))] = minimal_to28();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(128, 6, 106, 169, 239, 151, 91, 255, 81, 243, 37, 38, 187, 17))] = minimal_to29();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 232, 76, 116, 89, 157, 186, 5, 187, 186, 116, 229, 106, 25))] = minimal_to30();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(141, 89, 16, 100, 185, 98, 102, 89, 173, 226, 139, 71, 62, 251))] = minimal_to31();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))] = minimal_to32();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(151, 133, 93, 97, 88, 230, 235, 85, 240, 208, 235, 75, 68, 253))] = minimal_to33();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(152, 77, 214, 192, 169, 112, 53, 41, 126, 186, 125, 231, 193, 225))] = minimal_to34();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))] = minimal_to35();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(171, 115, 43, 233, 139, 29, 28, 130, 117, 249, 188, 147, 54, 250))] = minimal_to36();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(173, 51, 47, 234, 23, 87, 166, 82, 211, 40, 79, 240, 240, 111))] = minimal_to37();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(180, 45, 19, 101, 194, 86, 184, 210, 220, 168, 163, 127, 201, 93))] = minimal_to38();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 2, 1, 165, 140, 132, 125, 160, 139, 76, 161, 70, 60, 186))] = minimal_to39();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(181, 89, 73, 243, 195, 120, 183, 199, 143, 190, 155, 193, 233, 148))] = minimal_to40();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(187, 206, 175, 130, 167, 249, 57, 105, 219, 219, 138, 84, 110, 94))] = minimal_to41();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 99, 9, 235, 218, 120, 77, 82, 48, 128, 213, 135, 32, 100))] = minimal_to42();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(208, 131, 188, 155, 96, 118, 238, 78, 31, 220, 1, 243, 99, 160))] = minimal_to43();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))] = minimal_to44();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(210, 79, 164, 66, 51, 227, 220, 142, 250, 164, 226, 216, 141, 105))] = minimal_to45();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(212, 19, 36, 204, 216, 207, 229, 8, 101, 152, 15, 215, 71, 23))] = minimal_to46();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(235, 175, 160, 15, 211, 82, 49, 64, 142, 195, 195, 17, 53, 6))] = minimal_to47();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(237, 11, 165, 89, 87, 253, 32, 30, 237, 205, 192, 158, 220, 92))] = minimal_to48();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(242, 50, 226, 240, 16, 38, 237, 211, 144, 26, 4, 228, 64, 49))] = minimal_to49();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(245, 123, 132, 90, 230, 57, 154, 195, 107, 24, 104, 193, 118, 23))] = minimal_to50();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 87, 237, 35, 153, 167, 62, 144, 213, 193, 96, 70, 214, 135))] = minimal_to51();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(249, 220, 91, 156, 138, 84, 101, 172, 94, 24, 208, 47, 246, 97))] = minimal_to52();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(251, 95, 64, 60, 163, 23, 170, 158, 193, 148, 167, 7, 12, 36))] = minimal_to53();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(252, 160, 46, 120, 240, 108, 5, 183, 248, 205, 5, 172, 103, 237))] = minimal_to54();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(253, 72, 63, 147, 206, 16, 241, 72, 186, 231, 206, 213, 79, 158))] = minimal_to55();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(254, 60, 101, 64, 125, 160, 94, 0, 200, 47, 8, 233, 234, 252))] = minimal_to56();
  return tm;
}

}

const XTypes::TypeMap& get_minimal_type_map()
{
  static XTypes::TypeMap tm;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), tm);
  if (tm.empty()) {
    tm = get_minimal_type_map_private();
  }
  return tm;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

