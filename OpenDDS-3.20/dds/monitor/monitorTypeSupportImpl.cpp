/* Generated by ..\..\bin\opendds_idl version 3.20.0 (ACE version 6.2a_p23) running on input file monitor.idl */
#include "monitorTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/XTypes/TypeObject.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "dds/CorbaSeq/ULongSeqTypeSupportImpl.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: DDS */



/* Begin INTERFACE-FWD: Condition */


/* End INTERFACE-FWD: Condition */


/* Begin TYPEDEF: ConditionSeq */


/* End TYPEDEF: ConditionSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: ReturnCode_t */


/* End TYPEDEF: ReturnCode_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */


/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */


/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */


/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */


/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */


/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */


/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */


/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */


/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: OfferedIncompatibleQosStatus */


/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */


/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */


/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */


/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin CONST: DOMAIN_UNKNOWN */


/* End CONST: DOMAIN_UNKNOWN */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ULongSeq */


/* End TYPEDEF: ULongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: MONITOR_DOMAIN_ID */


/* End CONST: MONITOR_DOMAIN_ID */


/* Begin CONST: MONITOR_TRANSPORT_ID */


/* End CONST: MONITOR_TRANSPORT_ID */


/* Begin CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: TOPIC_MONITOR_TOPIC */


/* End CONST: TOPIC_MONITOR_TOPIC */


/* Begin CONST: PUBLISHER_MONITOR_TOPIC */


/* End CONST: PUBLISHER_MONITOR_TOPIC */


/* Begin CONST: SUBSCRIBER_MONITOR_TOPIC */


/* End CONST: SUBSCRIBER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_MONITOR_TOPIC */


/* End CONST: DATA_READER_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: TRANSPORT_MONITOR_TOPIC */


/* End CONST: TRANSPORT_MONITOR_TOPIC */


/* Begin STRUCT: Statistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_Statistics_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 128, 174, 247, 156, 172, 129, 120, 54, 68, 110, 95, 248, 45));
  }
  return ti;
}

static const XTypes::TypeMap& get_minimal_type_map();
template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_Statistics_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::Statistics& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"n",0},{"maximum",1},{"minimum",2},{"mean",3},{"variance",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_uint32(value.n)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_float64(value.maximum)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_float64(value.minimum)) return false;
      break;
    }
    case 3: {
      if (!value_reader.read_float64(value.mean)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_float64(value.variance)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::Statistics& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("n");
  value_writer.write_uint32(value.n);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("maximum");
  value_writer.write_float64(value.maximum);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("minimum");
  value_writer.write_float64(value.minimum);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("mean");
  value_writer.write_float64(value.mean);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("variance");
  value_writer.write_float64(value.variance);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::Statistics& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.n = 0;
  stru.maximum = 0;
  stru.minimum = 0;
  stru.mean = 0;
  stru.variance = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::Statistics& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.n);
  primitive_serialized_size(encoding, size, stru.maximum);
  primitive_serialized_size(encoding, size, stru.minimum);
  primitive_serialized_size(encoding, size, stru.mean);
  primitive_serialized_size(encoding, size, stru.variance);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::Statistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.n)
    && (strm << stru.maximum)
    && (strm << stru.minimum)
    && (strm << stru.mean)
    && (strm << stru.variance);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::Statistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.n)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.maximum)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.minimum)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.mean)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.variance)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::Statistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.n);
  primitive_serialized_size(encoding, size, stru.value.maximum);
  primitive_serialized_size(encoding, size, stru.value.minimum);
  primitive_serialized_size(encoding, size, stru.value.mean);
  primitive_serialized_size(encoding, size, stru.value.variance);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::Statistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.n)
    && (strm << stru.value.maximum)
    && (strm << stru.value.minimum)
    && (strm << stru.value.mean)
    && (strm << stru.value.variance);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::Statistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.n)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.maximum)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.minimum)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.mean)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.variance)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::Statistics> : MetaStruct {
  typedef  ::OpenDDS::DCPS::Statistics T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("n", 0),
      std::make_pair("maximum", 1),
      std::make_pair("minimum", 2),
      std::make_pair("mean", 3),
      std::make_pair("variance", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Statistics)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::Statistics& typed = *static_cast<const  ::OpenDDS::DCPS::Statistics*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "n") == 0) {
      return typed.n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return typed.maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return typed.minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return typed.mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return typed.variance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Statistics)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "n") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'n' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'n' could not be skipped");
      }
    }
    if (base_field == "maximum") {
      ACE_CDR::Double val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'maximum' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'maximum' could not be skipped");
      }
    }
    if (base_field == "minimum") {
      ACE_CDR::Double val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'minimum' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'minimum' could not be skipped");
      }
    }
    if (base_field == "mean") {
      ACE_CDR::Double val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'mean' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'mean' could not be skipped");
      }
    }
    if (base_field == "variance") {
      ACE_CDR::Double val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'variance' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'variance' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "n") == 0) {
      return make_field_cmp(&T::n, next);
    }
    if (std::strcmp(field, "maximum") == 0) {
      return make_field_cmp(&T::maximum, next);
    }
    if (std::strcmp(field, "minimum") == 0) {
      return make_field_cmp(&T::minimum, next);
    }
    if (std::strcmp(field, "mean") == 0) {
      return make_field_cmp(&T::mean, next);
    }
    if (std::strcmp(field, "variance") == 0) {
      return make_field_cmp(&T::variance, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Statistics)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"n", "maximum", "minimum", "mean", "variance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "n") == 0) {
      return &static_cast<const T*>(stru)->n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return &static_cast<const T*>(stru)->maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return &static_cast<const T*>(stru)->minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return &static_cast<const T*>(stru)->mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return &static_cast<const T*>(stru)->variance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Statistics)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "n") == 0) {
      static_cast<T*>(lhs)->n = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "maximum") == 0) {
      static_cast<T*>(lhs)->maximum = *static_cast<const  ::CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "minimum") == 0) {
      static_cast<T*>(lhs)->minimum = *static_cast<const  ::CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "mean") == 0) {
      static_cast<T*>(lhs)->mean = *static_cast<const  ::CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "variance") == 0) {
      static_cast<T*>(lhs)->variance = *static_cast<const  ::CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Statistics)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "n") == 0) {
      return static_cast<const T*>(lhs)->n == static_cast<const T*>(rhs)->n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return static_cast<const T*>(lhs)->maximum == static_cast<const T*>(rhs)->maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return static_cast<const T*>(lhs)->minimum == static_cast<const T*>(rhs)->minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return static_cast<const T*>(lhs)->mean == static_cast<const T*>(rhs)->mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return static_cast<const T*>(lhs)->variance == static_cast<const T*>(rhs)->variance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Statistics)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::Statistics>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::Statistics> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::Statistics*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::Statistics>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Statistics */


/* Begin ENUM: ValueEnumType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ValueEnumType_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(18, 64, 210, 182, 85, 60, 89, 52, 235, 185, 39, 84, 171, 58));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ValueEnumType_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ValueEnumType& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"INTEGER_TYPE",0},{"DOUBLE_TYPE",1},{"STRING_TYPE",2},{"STATISTICS_TYPE",3},{"STRING_LIST_TYPE",4},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ValueEnumType& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    value_writer.write_enum("INTEGER_TYPE", OpenDDS::DCPS::INTEGER_TYPE);
    break;
  case OpenDDS::DCPS::DOUBLE_TYPE:
    value_writer.write_enum("DOUBLE_TYPE", OpenDDS::DCPS::DOUBLE_TYPE);
    break;
  case OpenDDS::DCPS::STRING_TYPE:
    value_writer.write_enum("STRING_TYPE", OpenDDS::DCPS::STRING_TYPE);
    break;
  case OpenDDS::DCPS::STATISTICS_TYPE:
    value_writer.write_enum("STATISTICS_TYPE", OpenDDS::DCPS::STATISTICS_TYPE);
    break;
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    value_writer.write_enum("STRING_LIST_TYPE", OpenDDS::DCPS::STRING_LIST_TYPE);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ValueEnumType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 5) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::OpenDDS::DCPS::ValueEnumType (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ValueEnumType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 5) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::OpenDDS::DCPS::ValueEnumType>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_ValueEnumType_names[] = {
  "INTEGER_TYPE",
  "DOUBLE_TYPE",
  "STRING_TYPE",
  "STATISTICS_TYPE",
  "STRING_LIST_TYPE"
};
const size_t gen_OpenDDS_DCPS_ValueEnumType_names_size = 5;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: ValueEnumType */


/* Begin UNION: ValueUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ValueUnion_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(12, 82, 28, 208, 107, 19, 44, 103, 146, 93, 239, 13, 190, 124));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ValueUnion_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ValueUnion& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  if (!value_reader.begin_union()) return false;
  if (!value_reader.begin_discriminator()) return false;
  {
     ::OpenDDS::DCPS::ValueEnumType d;
    if (!vread(value_reader, d)) return false;
    value._d(d);
  }
  if (!value_reader.end_discriminator()) return false;
  switch (value._d()) {
  case  ::OpenDDS::DCPS::INTEGER_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::CORBA::Long bv;
    if (!value_reader.read_int32(bv)) return false;
    value.integer_value(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::DOUBLE_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::CORBA::Double bv;
    if (!value_reader.read_float64(bv)) return false;
    value.double_value(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::STRING_TYPE: {
    if (!value_reader.begin_union_member()) return false;
    std::string bv;
    {
      String x;
      if (!value_reader.read_string(x)) return false;
      bv = x.c_str();
    }
    value.string_value(bv.c_str());
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::STATISTICS_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::Statistics bv;
    if (!vread(value_reader, bv)) return false;
    value.stat_value(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::STRING_LIST_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::DDS::StringSeq bv;
    if (!value_reader.begin_sequence()) return false;
    for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
      OpenDDS::DCPS::grow(bv);
      if (!value_reader.begin_element()) return false;
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        bv[i] = x.c_str();
      }
      if (!value_reader.end_element()) return false;
    }
    if (!value_reader.end_sequence()) return false;
    value.string_seq_value(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  default:
    break;
  }
  if (!value_reader.end_union()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ValueUnion& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_union();
  value_writer.begin_discriminator();
  vwrite(value_writer, value._d());
  value_writer.end_discriminator();
  switch (value._d()) {
  case  ::OpenDDS::DCPS::INTEGER_TYPE: {
    value_writer.begin_union_member("integer_value");
    value_writer.write_int32(value.integer_value());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::DOUBLE_TYPE: {
    value_writer.begin_union_member("double_value");
    value_writer.write_float64(value.double_value());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::STRING_TYPE: {
    value_writer.begin_union_member("string_value");
    value_writer.write_string(value.string_value());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::STATISTICS_TYPE: {
    value_writer.begin_union_member("stat_value");
    vwrite(value_writer, value.stat_value());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::STRING_LIST_TYPE: {
    value_writer.begin_union_member("string_seq_value");
    value_writer.begin_sequence();
    for (::CORBA::ULong i = 0; i != value.string_seq_value().length(); ++i) {
      value_writer.begin_element(i);
      value_writer.write_string(value.string_seq_value()[i]);
      value_writer.end_element();
    }
    value_writer.end_sequence();
    value_writer.end_union_member();
    break;
  }
  default:
    break;
  }
  value_writer.end_union();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::ValueUnion& uni)
{
  ACE_UNUSED_ARG(uni);
   ::OpenDDS::DCPS::ValueEnumType temp;
    temp =  ::OpenDDS::DCPS::INTEGER_TYPE;
  uni._d(temp);
  uni.integer_value(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ValueUnion& uni)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(uni);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  switch (uni._d()) {
  case  ::OpenDDS::DCPS::INTEGER_TYPE: {
    primitive_serialized_size(encoding, size, uni.integer_value());
    break;
  }
  case  ::OpenDDS::DCPS::DOUBLE_TYPE: {
    primitive_serialized_size(encoding, size, uni.double_value());
    break;
  }
  case  ::OpenDDS::DCPS::STRING_TYPE: {
    primitive_serialized_size_ulong(encoding, size);
    size += ACE_OS::strlen(uni.string_value()) + 1;
    break;
  }
  case  ::OpenDDS::DCPS::STATISTICS_TYPE: {
    serialized_size(encoding, size, uni.stat_value());
    break;
  }
  case  ::OpenDDS::DCPS::STRING_LIST_TYPE: {
    serialized_size(encoding, size, uni.string_seq_value());
    break;
  }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ValueUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, uni);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case  ::OpenDDS::DCPS::INTEGER_TYPE: {
    return (strm << uni.integer_value());
  }
  case  ::OpenDDS::DCPS::DOUBLE_TYPE: {
    return (strm << uni.double_value());
  }
  case  ::OpenDDS::DCPS::STRING_TYPE: {
    return (strm << uni.string_value());
  }
  case  ::OpenDDS::DCPS::STATISTICS_TYPE: {
    return (strm << uni.stat_value());
  }
  case  ::OpenDDS::DCPS::STRING_LIST_TYPE: {
    return (strm << uni.string_seq_value());
  }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ValueUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::ValueEnumType disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case  ::OpenDDS::DCPS::INTEGER_TYPE: {
     ::CORBA::Long tmp;
    if (strm >> tmp) {
      uni.integer_value(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::DOUBLE_TYPE: {
     ::CORBA::Double tmp;
    if (strm >> tmp) {
      uni.double_value(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::STRING_TYPE: {
    CORBA::String_var tmp;
    if (strm >> tmp.out()) {
      uni.string_value(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::STATISTICS_TYPE: {
     ::OpenDDS::DCPS::Statistics tmp;
    if (strm >> tmp) {
      uni.stat_value(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::STRING_LIST_TYPE: {
     ::DDS::StringSeq tmp;
    if (strm >> tmp) {
      uni.string_seq_value(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ValueUnion> uni)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(uni);
}

bool operator<<(Serializer& strm, NestedKeyOnly<const  ::OpenDDS::DCPS::ValueUnion> uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::ValueUnion> uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::ValueUnion> uni)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(uni);
}

bool operator<<(Serializer& strm, KeyOnly<const  ::OpenDDS::DCPS::ValueUnion> uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly< ::OpenDDS::DCPS::ValueUnion> uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::ValueUnion> : MetaStruct {
  typedef  ::OpenDDS::DCPS::ValueUnion T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::ValueUnion& typed = *static_cast<const  ::OpenDDS::DCPS::ValueUnion*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ValueUnion)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    ACE_UNUSED_ARG(ser);
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::OpenDDS::DCPS::ValueUnion");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ValueUnion)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    ACE_UNUSED_ARG(stru);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ValueUnion)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ValueUnion)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ValueUnion)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ValueUnion>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::ValueUnion> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ValueUnion*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  const bool is_mutable = 0;
  unsigned member_id;
  size_t field_size;
  bool must_understand = false;
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::ValueEnumType disc;
  if (!(ser >> disc)) {
    return false;
  }
  switch (disc) {
  case  ::OpenDDS::DCPS::INTEGER_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::DOUBLE_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!ser.skip(1, 8)) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::STRING_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    ACE_CDR::ULong len;
    if (!(ser >> len)) return false;
    if (!ser.skip(len)) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::STATISTICS_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::Statistics*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::STRING_LIST_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::DDS::StringSeq*>(0))) return false;
    return true;
  }
  default:
    break;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: ValueUnion */


/* Begin STRUCT: NameValuePair */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_NameValuePair_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(246, 47, 199, 145, 7, 79, 14, 149, 15, 98, 147, 98, 215, 244));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_NameValuePair_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::NameValuePair& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"name",0},{"value",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.name = x.c_str();
      }
      break;
    }
    case 1: {
      if (!vread(value_reader, value.value)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::NameValuePair& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("name");
  value_writer.write_string(value.name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("value");
  vwrite(value_writer, value.value);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::NameValuePair& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.name = "";
  set_default(stru.value);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::NameValuePair& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.name.in()) + 1;
  serialized_size(encoding, size, stru.value);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::NameValuePair& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.name.in())
    && (strm << stru.value);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::NameValuePair& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::NameValuePair>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.name.in()) + 1;
  serialized_size(encoding, size, stru.value.value);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::NameValuePair>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.name.in())
    && (strm << stru.value.value);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::NameValuePair>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.value)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::NameValuePair> : MetaStruct {
  typedef  ::OpenDDS::DCPS::NameValuePair T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("name", 0),
      std::make_pair("value", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::NameValuePair)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::NameValuePair& typed = *static_cast<const  ::OpenDDS::DCPS::NameValuePair*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::NameValuePair)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::ValueUnion*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::NameValuePair)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"name", "value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::NameValuePair)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const  ::OpenDDS::DCPS::ValueUnion*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::NameValuePair)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::NameValuePair)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::NameValuePair>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::NameValuePair> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::NameValuePair*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::NameValuePair>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: NameValuePair */


/* Begin TYPEDEF: NVPSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_NVPSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_NVPSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::NVPSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::NVPSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::NVPSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::NVPSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::NVPSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::NVPSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::NameValuePair*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: NVPSeq */


/* Begin STRUCT: ServiceParticipantReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ServiceParticipantReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(46, 12, 12, 124, 135, 91, 231, 193, 96, 122, 19, 90, 238, 121));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ServiceParticipantReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ServiceParticipantReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"host",0},{"pid",1},{"domain_participants",2},{"transports",3},{"values",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.host = x.c_str();
      }
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.pid)) return false;
      break;
    }
    case 2: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.domain_participants);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.domain_participants[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.transports);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_uint32(value.transports[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ServiceParticipantReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("host");
  value_writer.write_string(value.host);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("pid");
  value_writer.write_int32(value.pid);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("domain_participants");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.domain_participants.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.domain_participants[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transports");
  value_writer.begin_sequence();
  value_writer.write_uint32_array (value.transports.get_buffer(), value.transports.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::ServiceParticipantReport& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.host = "";
  stru.pid = 0;
  stru.domain_participants.length(0);
  stru.transports.length(0);
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ServiceParticipantReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.host.in()) + 1;
  primitive_serialized_size(encoding, size, stru.pid);
  serialized_size(encoding, size, stru.domain_participants);
  serialized_size(encoding, size, stru.transports);
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ServiceParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.host.in())
    && (strm << stru.pid)
    && (strm << stru.domain_participants)
    && (strm << stru.transports)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ServiceParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.host.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.pid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.domain_participants)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transports)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ServiceParticipantReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.host.in()) + 1;
  primitive_serialized_size(encoding, size, stru.value.pid);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::ServiceParticipantReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.host.in())
    && (strm << stru.value.pid);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ServiceParticipantReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.host.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.pid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::ServiceParticipantReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.host.in()) + 1;
  primitive_serialized_size(encoding, size, stru.value.pid);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::ServiceParticipantReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.host.in())
    && (strm << stru.value.pid);
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::ServiceParticipantReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.host.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.pid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr ServiceParticipantReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ServiceParticipantReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr ServiceParticipantReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ServiceParticipantReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ServiceParticipantReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ServiceParticipantReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ServiceParticipantReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ServiceParticipantReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ServiceParticipantReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool ServiceParticipantReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* ServiceParticipantReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void ServiceParticipantReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& ServiceParticipantReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_ServiceParticipantReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& ServiceParticipantReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_ServiceParticipantReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& ServiceParticipantReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& ServiceParticipantReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility ServiceParticipantReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

ServiceParticipantReportTypeSupport::_ptr_type ServiceParticipantReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::ServiceParticipantReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::ServiceParticipantReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 2; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "host")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "pid")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("host", 0),
      std::make_pair("pid", 1),
      std::make_pair("domain_participants", 2),
      std::make_pair("transports", 3),
      std::make_pair("values", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ServiceParticipantReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::ServiceParticipantReport& typed = *static_cast<const  ::OpenDDS::DCPS::ServiceParticipantReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ServiceParticipantReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "host") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'host' contents could not be skipped");
      }
    }
    if (base_field == "pid") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'pid' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUIDSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::CORBA::ULongSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ServiceParticipantReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "domain_participants", "transports", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "domain_participants") == 0) {
      return &static_cast<const T*>(stru)->domain_participants;
    }
    if (std::strcmp(field, "transports") == 0) {
      return &static_cast<const T*>(stru)->transports;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ServiceParticipantReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "domain_participants") == 0) {
      static_cast<T*>(lhs)->domain_participants = *static_cast<const  ::OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transports") == 0) {
      static_cast<T*>(lhs)->transports = *static_cast<const  ::CORBA::ULongSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ServiceParticipantReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host.in(), static_cast<const T*>(rhs)->host.in());
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ServiceParticipantReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ServiceParticipantReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::ServiceParticipantReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ServiceParticipantReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::ServiceParticipantReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ServiceParticipantReport */


/* Begin STRUCT: DomainParticipantReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DomainParticipantReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 39, 201, 99, 6, 22, 39, 179, 24, 201, 41, 224, 214, 90));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DomainParticipantReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DomainParticipantReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"host",0},{"pid",1},{"dp_id",2},{"domain_id",3},{"topics",4},{"values",5},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.host = x.c_str();
      }
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.pid)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.dp_id)) return false;
      break;
    }
    case 3: {
      if (!value_reader.read_int32(value.domain_id)) return false;
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.topics);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.topics[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 5: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DomainParticipantReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("host");
  value_writer.write_string(value.host);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("pid");
  value_writer.write_int32(value.pid);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("dp_id");
  vwrite(value_writer, value.dp_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("domain_id");
  value_writer.write_int32(value.domain_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topics");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.topics.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.topics[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DomainParticipantReport& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.host = "";
  stru.pid = 0;
  set_default(stru.dp_id);
  stru.domain_id = 0;
  stru.topics.length(0);
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DomainParticipantReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.host.in()) + 1;
  primitive_serialized_size(encoding, size, stru.pid);
  serialized_size(encoding, size, stru.dp_id);
  primitive_serialized_size(encoding, size, stru.domain_id);
  serialized_size(encoding, size, stru.topics);
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DomainParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.host.in())
    && (strm << stru.pid)
    && (strm << stru.dp_id)
    && (strm << stru.domain_id)
    && (strm << stru.topics)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DomainParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.host.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.pid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dp_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.domain_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topics)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DomainParticipantReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DomainParticipantReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DomainParticipantReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dp_9id_nested_key_only(stru.value.dp_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dp_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::DomainParticipantReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::DomainParticipantReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DomainParticipantReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dp_9id_nested_key_only(stru.value.dp_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dp_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DomainParticipantReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DomainParticipantReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr DomainParticipantReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DomainParticipantReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DomainParticipantReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DomainParticipantReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DomainParticipantReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DomainParticipantReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DomainParticipantReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool DomainParticipantReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* DomainParticipantReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void DomainParticipantReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& DomainParticipantReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_DomainParticipantReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& DomainParticipantReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_DomainParticipantReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& DomainParticipantReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& DomainParticipantReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility DomainParticipantReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

DomainParticipantReportTypeSupport::_ptr_type DomainParticipantReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DomainParticipantReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DomainParticipantReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("host", 0),
      std::make_pair("pid", 1),
      std::make_pair("dp_id", 2),
      std::make_pair("domain_id", 3),
      std::make_pair("topics", 4),
      std::make_pair("values", 5),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 6);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DomainParticipantReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DomainParticipantReport& typed = *static_cast<const  ::OpenDDS::DCPS::DomainParticipantReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return typed.domain_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DomainParticipantReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "host") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'host' contents could not be skipped");
      }
    }
    if (base_field == "pid") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'pid' could not be skipped");
      }
    }
    if (base_field == "dp_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dp_id' could not be skipped");
      }
    }
    if (base_field == "domain_id") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'domain_id' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'domain_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUIDSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return make_field_cmp(&T::domain_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DomainParticipantReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "dp_id", "domain_id", "topics", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return &static_cast<const T*>(stru)->domain_id;
    }
    if (std::strcmp(field, "topics") == 0) {
      return &static_cast<const T*>(stru)->topics;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DomainParticipantReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      static_cast<T*>(lhs)->domain_id = *static_cast<const  ::DDS::DomainId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topics") == 0) {
      static_cast<T*>(lhs)->topics = *static_cast<const  ::OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DomainParticipantReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host.in(), static_cast<const T*>(rhs)->host.in());
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return static_cast<const T*>(lhs)->domain_id == static_cast<const T*>(rhs)->domain_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DomainParticipantReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DomainParticipantReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DomainParticipantReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DomainParticipantReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DomainParticipantReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantReport */


/* Begin STRUCT: TopicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TopicReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(190, 62, 247, 176, 192, 0, 248, 21, 21, 79, 115, 156, 216, 238));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TopicReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::TopicReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dp_id",0},{"topic_id",1},{"topic_name",2},{"type_name",3},{"values",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dp_id)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.topic_id)) return false;
      break;
    }
    case 2: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.topic_name = x.c_str();
      }
      break;
    }
    case 3: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.type_name = x.c_str();
      }
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::TopicReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dp_id");
  vwrite(value_writer, value.dp_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_id");
  vwrite(value_writer, value.topic_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_name");
  value_writer.write_string(value.topic_name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("type_name");
  value_writer.write_string(value.type_name);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::TopicReport& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dp_id);
  set_default(stru.topic_id);
  stru.topic_name = "";
  stru.type_name = "";
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::TopicReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dp_id);
  serialized_size(encoding, size, stru.topic_id);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.topic_name.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.type_name.in()) + 1;
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::TopicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dp_id)
    && (strm << stru.topic_id)
    && (strm << stru.topic_name.in())
    && (strm << stru.type_name.in())
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TopicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dp_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.type_name.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::TopicReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.topic_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::TopicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.topic_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::TopicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_topic_9id_nested_key_only(stru.value.topic_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_topic_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::TopicReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.topic_id));
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::TopicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.topic_id));
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::TopicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_topic_9id_nested_key_only(stru.value.topic_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_topic_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr TopicReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<TopicReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr TopicReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr TopicReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<TopicReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& TopicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TopicReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool TopicReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* TopicReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void TopicReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& TopicReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_TopicReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& TopicReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_TopicReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& TopicReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& TopicReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility TopicReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

TopicReportTypeSupport::_ptr_type TopicReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::TopicReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::TopicReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "topic_id.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dp_id", 0),
      std::make_pair("topic_id", 1),
      std::make_pair("topic_name", 2),
      std::make_pair("type_name", 3),
      std::make_pair("values", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TopicReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::TopicReport& typed = *static_cast<const  ::OpenDDS::DCPS::TopicReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TopicReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dp_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dp_id' could not be skipped");
      }
    }
    if (base_field == "topic_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'topic_id' could not be skipped");
      }
    }
    if (base_field == "topic_name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'topic_name' contents could not be skipped");
      }
    }
    if (base_field == "type_name") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'type_name' contents could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TopicReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "topic_id", "topic_name", "type_name", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TopicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TopicReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name.in(), static_cast<const T*>(rhs)->topic_name.in());
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TopicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::TopicReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::TopicReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TopicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::TopicReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicReport */


/* Begin STRUCT: PublisherReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_PublisherReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(226, 87, 217, 30, 153, 223, 93, 179, 38, 202, 87, 127, 233, 175));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_PublisherReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::PublisherReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"handle",0},{"dp_id",1},{"transport_id",2},{"writers",3},{"values",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.handle)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.dp_id)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint32(value.transport_id)) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.writers);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.writers[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::PublisherReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("handle");
  value_writer.write_int32(value.handle);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("dp_id");
  vwrite(value_writer, value.dp_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transport_id");
  value_writer.write_uint32(value.transport_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writers");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.writers.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.writers[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::PublisherReport& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.handle = 0;
  set_default(stru.dp_id);
  stru.transport_id = 0;
  stru.writers.length(0);
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::PublisherReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.handle);
  serialized_size(encoding, size, stru.dp_id);
  primitive_serialized_size(encoding, size, stru.transport_id);
  serialized_size(encoding, size, stru.writers);
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::PublisherReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.handle)
    && (strm << stru.dp_id)
    && (strm << stru.transport_id)
    && (strm << stru.writers)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::PublisherReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dp_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writers)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::PublisherReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.handle);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::PublisherReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.handle)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::PublisherReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dp_9id_nested_key_only(stru.value.dp_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dp_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::PublisherReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.handle);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::PublisherReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.handle)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::PublisherReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dp_9id_nested_key_only(stru.value.dp_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dp_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr PublisherReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<PublisherReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr PublisherReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PublisherReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr PublisherReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PublisherReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PublisherReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& PublisherReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PublisherReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool PublisherReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* PublisherReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void PublisherReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& PublisherReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_PublisherReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& PublisherReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_PublisherReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& PublisherReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& PublisherReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility PublisherReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

PublisherReportTypeSupport::_ptr_type PublisherReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::PublisherReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::PublisherReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 17; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "handle")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("handle", 0),
      std::make_pair("dp_id", 1),
      std::make_pair("transport_id", 2),
      std::make_pair("writers", 3),
      std::make_pair("values", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::PublisherReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::PublisherReport& typed = *static_cast<const  ::OpenDDS::DCPS::PublisherReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "handle") == 0) {
      return typed.handle;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::PublisherReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'handle' could not be skipped");
      }
    }
    if (base_field == "dp_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dp_id' could not be skipped");
      }
    }
    if (base_field == "transport_id") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'transport_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUIDSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "handle") == 0) {
      return make_field_cmp(&T::handle, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::PublisherReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"handle", "dp_id", "transport_id", "writers", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      return &static_cast<const T*>(stru)->handle;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "writers") == 0) {
      return &static_cast<const T*>(stru)->writers;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::PublisherReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "handle") == 0) {
      static_cast<T*>(lhs)->handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writers") == 0) {
      static_cast<T*>(lhs)->writers = *static_cast<const  ::OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::PublisherReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "handle") == 0) {
      return static_cast<const T*>(lhs)->handle == static_cast<const T*>(rhs)->handle;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::PublisherReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::PublisherReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::PublisherReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::PublisherReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::PublisherReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublisherReport */


/* Begin STRUCT: SubscriberReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_SubscriberReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 80, 30, 145, 7, 41, 214, 11, 173, 240, 217, 37, 27, 129));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_SubscriberReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::SubscriberReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"handle",0},{"dp_id",1},{"transport_id",2},{"readers",3},{"values",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.handle)) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.dp_id)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint32(value.transport_id)) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.readers);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.readers[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::SubscriberReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("handle");
  value_writer.write_int32(value.handle);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("dp_id");
  vwrite(value_writer, value.dp_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transport_id");
  value_writer.write_uint32(value.transport_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("readers");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.readers.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.readers[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::SubscriberReport& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.handle = 0;
  set_default(stru.dp_id);
  stru.transport_id = 0;
  stru.readers.length(0);
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::SubscriberReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.handle);
  serialized_size(encoding, size, stru.dp_id);
  primitive_serialized_size(encoding, size, stru.transport_id);
  serialized_size(encoding, size, stru.readers);
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::SubscriberReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.handle)
    && (strm << stru.dp_id)
    && (strm << stru.transport_id)
    && (strm << stru.readers)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::SubscriberReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dp_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.readers)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::SubscriberReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.handle);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::SubscriberReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.handle)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::SubscriberReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dp_9id_nested_key_only(stru.value.dp_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dp_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::SubscriberReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.handle);
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::SubscriberReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.handle)
    && (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dp_id));
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::SubscriberReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dp_9id_nested_key_only(stru.value.dp_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dp_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr SubscriberReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SubscriberReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SubscriberReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriberReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SubscriberReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriberReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SubscriberReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SubscriberReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SubscriberReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SubscriberReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* SubscriberReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void SubscriberReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& SubscriberReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_SubscriberReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& SubscriberReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_SubscriberReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& SubscriberReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& SubscriberReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility SubscriberReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

SubscriberReportTypeSupport::_ptr_type SubscriberReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::SubscriberReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::SubscriberReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 17; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "handle")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dp_id.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("handle", 0),
      std::make_pair("dp_id", 1),
      std::make_pair("transport_id", 2),
      std::make_pair("readers", 3),
      std::make_pair("values", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::SubscriberReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::SubscriberReport& typed = *static_cast<const  ::OpenDDS::DCPS::SubscriberReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "handle") == 0) {
      return typed.handle;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::SubscriberReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'handle' could not be skipped");
      }
    }
    if (base_field == "dp_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dp_id' could not be skipped");
      }
    }
    if (base_field == "transport_id") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'transport_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUIDSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "handle") == 0) {
      return make_field_cmp(&T::handle, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::SubscriberReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"handle", "dp_id", "transport_id", "readers", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      return &static_cast<const T*>(stru)->handle;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "readers") == 0) {
      return &static_cast<const T*>(stru)->readers;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::SubscriberReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "handle") == 0) {
      static_cast<T*>(lhs)->handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readers") == 0) {
      static_cast<T*>(lhs)->readers = *static_cast<const  ::OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::SubscriberReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "handle") == 0) {
      return static_cast<const T*>(lhs)->handle == static_cast<const T*>(rhs)->handle;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::SubscriberReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::SubscriberReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::SubscriberReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::SubscriberReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::SubscriberReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriberReport */


/* Begin STRUCT: DataWriterAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataWriterAssociation_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(230, 121, 140, 67, 255, 212, 66, 102, 19, 63, 62, 243, 198, 215));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataWriterAssociation_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataWriterAssociation& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dr_id",0},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dr_id)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataWriterAssociation& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dr_id");
  vwrite(value_writer, value.dr_id);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DataWriterAssociation& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dr_id);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DataWriterAssociation& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dr_id);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DataWriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dr_id);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataWriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dr_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterAssociation>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterAssociation>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataWriterAssociation>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dr_9id_nested_key_only(stru.value.dr_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dr_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DataWriterAssociation> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DataWriterAssociation T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dr_id", 0),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 1);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociation)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DataWriterAssociation& typed = *static_cast<const  ::OpenDDS::DCPS::DataWriterAssociation*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociation)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dr_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dr_id' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociation)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociation)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataWriterAssociation>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DataWriterAssociation> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataWriterAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DataWriterAssociation>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterAssociation */


/* Begin TYPEDEF: DWAssociations */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DWAssociations_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(172, 30, 138, 111, 124, 204, 7, 228, 71, 236, 229, 225, 30, 151));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DWAssociations_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DWAssociations& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DWAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DWAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::DWAssociations tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::DWAssociations tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DWAssociations>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterAssociation>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DWAssociations>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterAssociation>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::DWAssociations>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::DataWriterAssociation> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::DWAssociations tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::DWAssociations tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DWAssociations*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DataWriterAssociation*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DWAssociations */


/* Begin STRUCT: DataWriterReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataWriterReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(215, 179, 248, 95, 106, 44, 70, 151, 10, 153, 90, 1, 103, 201));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataWriterReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataWriterReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dp_id",0},{"pub_handle",1},{"dw_id",2},{"topic_id",3},{"instances",4},{"associations",5},{"values",6},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dp_id)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.pub_handle)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.dw_id)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.topic_id)) return false;
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.instances);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_int32(value.instances[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 5: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.associations);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.associations[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 6: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataWriterReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dp_id");
  vwrite(value_writer, value.dp_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("pub_handle");
  value_writer.write_int32(value.pub_handle);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("dw_id");
  vwrite(value_writer, value.dw_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_id");
  vwrite(value_writer, value.topic_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("instances");
  value_writer.begin_sequence();
  value_writer.write_int32_array (value.instances.get_buffer(), value.instances.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("associations");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.associations.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.associations[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DataWriterReport& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dp_id);
  stru.pub_handle = 0;
  set_default(stru.dw_id);
  set_default(stru.topic_id);
  stru.instances.length(0);
  stru.associations.length(0);
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DataWriterReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dp_id);
  primitive_serialized_size(encoding, size, stru.pub_handle);
  serialized_size(encoding, size, stru.dw_id);
  serialized_size(encoding, size, stru.topic_id);
  serialized_size(encoding, size, stru.instances);
  serialized_size(encoding, size, stru.associations);
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DataWriterReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dp_id)
    && (strm << stru.pub_handle)
    && (strm << stru.dw_id)
    && (strm << stru.topic_id)
    && (strm << stru.instances)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataWriterReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dp_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.pub_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dw_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.instances)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.associations)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataWriterReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dw_9id_nested_key_only(stru.value.dw_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dw_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::DataWriterReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::DataWriterReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DataWriterReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dw_9id_nested_key_only(stru.value.dw_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dw_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DataWriterReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DataWriterReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr DataWriterReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataWriterReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DataWriterReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataWriterReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DataWriterReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DataWriterReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataWriterReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool DataWriterReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* DataWriterReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void DataWriterReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& DataWriterReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_DataWriterReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& DataWriterReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_DataWriterReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& DataWriterReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& DataWriterReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility DataWriterReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

DataWriterReportTypeSupport::_ptr_type DataWriterReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DataWriterReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DataWriterReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dp_id", 0),
      std::make_pair("pub_handle", 1),
      std::make_pair("dw_id", 2),
      std::make_pair("topic_id", 3),
      std::make_pair("instances", 4),
      std::make_pair("associations", 5),
      std::make_pair("values", 6),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 7);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DataWriterReport& typed = *static_cast<const  ::OpenDDS::DCPS::DataWriterReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return typed.pub_handle;
    }
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dp_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dp_id' could not be skipped");
      }
    }
    if (base_field == "pub_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'pub_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'pub_handle' could not be skipped");
      }
    }
    if (base_field == "dw_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dw_id' could not be skipped");
      }
    }
    if (base_field == "topic_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'topic_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::InstanceHandleSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::DWAssociations*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return make_field_cmp(&T::pub_handle, next);
    }
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "pub_handle", "dw_id", "topic_id", "instances", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return &static_cast<const T*>(stru)->pub_handle;
    }
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "instances") == 0) {
      return &static_cast<const T*>(stru)->instances;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      static_cast<T*>(lhs)->pub_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instances") == 0) {
      static_cast<T*>(lhs)->instances = *static_cast<const  ::DDS::InstanceHandleSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const  ::OpenDDS::DCPS::DWAssociations*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "pub_handle") == 0) {
      return static_cast<const T*>(lhs)->pub_handle == static_cast<const T*>(rhs)->pub_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataWriterReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DataWriterReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataWriterReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DataWriterReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterReport */


/* Begin STRUCT: DataWriterAssociationPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataWriterAssociationPeriodic_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(239, 141, 154, 37, 164, 156, 92, 159, 62, 117, 207, 69, 96, 177));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataWriterAssociationPeriodic_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dr_id",0},{"sequence_number",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dr_id)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.sequence_number)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dr_id");
  vwrite(value_writer, value.dr_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("sequence_number");
  value_writer.write_uint32(value.sequence_number);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DataWriterAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dr_id);
  stru.sequence_number = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dr_id);
  primitive_serialized_size(encoding, size, stru.sequence_number);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dr_id)
    && (strm << stru.sequence_number);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dr_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.sequence_number)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
  primitive_serialized_size(encoding, size, stru.value.sequence_number);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id))
    && (strm << stru.value.sequence_number);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataWriterAssociationPeriodic>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dr_9id_nested_key_only(stru.value.dr_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dr_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.sequence_number)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DataWriterAssociationPeriodic> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DataWriterAssociationPeriodic T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dr_id", 0),
      std::make_pair("sequence_number", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociationPeriodic)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& typed = *static_cast<const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return typed.sequence_number;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dr_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dr_id' could not be skipped");
      }
    }
    if (base_field == "sequence_number") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sequence_number' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sequence_number' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return make_field_cmp(&T::sequence_number, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", "sequence_number", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return &static_cast<const T*>(stru)->sequence_number;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      static_cast<T*>(lhs)->sequence_number = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sequence_number") == 0) {
      return static_cast<const T*>(lhs)->sequence_number == static_cast<const T*>(rhs)->sequence_number;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataWriterAssociationPeriodic>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DataWriterAssociationPeriodic> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataWriterAssociationPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DataWriterAssociationPeriodic>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterAssociationPeriodic */


/* Begin TYPEDEF: DWAssociationsPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DWAssociationsPeriodic_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(9, 55, 16, 127, 233, 130, 146, 93, 171, 107, 196, 111, 236, 147));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DWAssociationsPeriodic_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DWAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DWAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DWAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::DWAssociationsPeriodic tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::DWAssociationsPeriodic tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DWAssociationsPeriodic>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DWAssociationsPeriodic>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::DWAssociationsPeriodic>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::DataWriterAssociationPeriodic> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::DWAssociationsPeriodic tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::DWAssociationsPeriodic tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DWAssociationsPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DataWriterAssociationPeriodic*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DWAssociationsPeriodic */


/* Begin STRUCT: DataWriterPeriodicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataWriterPeriodicReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(225, 26, 197, 244, 21, 120, 136, 183, 86, 147, 255, 129, 116, 122));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataWriterPeriodicReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataWriterPeriodicReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dw_id",0},{"data_dropped_count",1},{"data_delivered_count",2},{"control_dropped_count",3},{"control_delivered_count",4},{"associations",5},{"values",6},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dw_id)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.data_dropped_count)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint32(value.data_delivered_count)) return false;
      break;
    }
    case 3: {
      if (!value_reader.read_uint32(value.control_dropped_count)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_uint32(value.control_delivered_count)) return false;
      break;
    }
    case 5: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.associations);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.associations[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 6: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataWriterPeriodicReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dw_id");
  vwrite(value_writer, value.dw_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("data_dropped_count");
  value_writer.write_uint32(value.data_dropped_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("data_delivered_count");
  value_writer.write_uint32(value.data_delivered_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("control_dropped_count");
  value_writer.write_uint32(value.control_dropped_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("control_delivered_count");
  value_writer.write_uint32(value.control_delivered_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("associations");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.associations.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.associations[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DataWriterPeriodicReport& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dw_id);
  stru.data_dropped_count = 0;
  stru.data_delivered_count = 0;
  stru.control_dropped_count = 0;
  stru.control_delivered_count = 0;
  stru.associations.length(0);
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DataWriterPeriodicReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dw_id);
  primitive_serialized_size(encoding, size, stru.data_dropped_count);
  primitive_serialized_size(encoding, size, stru.data_delivered_count);
  primitive_serialized_size(encoding, size, stru.control_dropped_count);
  primitive_serialized_size(encoding, size, stru.control_delivered_count);
  serialized_size(encoding, size, stru.associations);
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DataWriterPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dw_id)
    && (strm << stru.data_dropped_count)
    && (strm << stru.data_delivered_count)
    && (strm << stru.control_dropped_count)
    && (strm << stru.control_delivered_count)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataWriterPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dw_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.data_dropped_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.data_delivered_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.control_dropped_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.control_delivered_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.associations)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dw_9id_nested_key_only(stru.value.dw_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dw_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dw_9id_nested_key_only(stru.value.dw_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dw_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DataWriterPeriodicReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DataWriterPeriodicReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr DataWriterPeriodicReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataWriterPeriodicReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DataWriterPeriodicReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataWriterPeriodicReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DataWriterPeriodicReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DataWriterPeriodicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataWriterPeriodicReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool DataWriterPeriodicReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* DataWriterPeriodicReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void DataWriterPeriodicReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& DataWriterPeriodicReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_DataWriterPeriodicReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& DataWriterPeriodicReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_DataWriterPeriodicReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& DataWriterPeriodicReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& DataWriterPeriodicReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility DataWriterPeriodicReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

DataWriterPeriodicReportTypeSupport::_ptr_type DataWriterPeriodicReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DataWriterPeriodicReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DataWriterPeriodicReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dw_id.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dw_id", 0),
      std::make_pair("data_dropped_count", 1),
      std::make_pair("data_delivered_count", 2),
      std::make_pair("control_dropped_count", 3),
      std::make_pair("control_delivered_count", 4),
      std::make_pair("associations", 5),
      std::make_pair("values", 6),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 7);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterPeriodicReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DataWriterPeriodicReport& typed = *static_cast<const  ::OpenDDS::DCPS::DataWriterPeriodicReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return typed.data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return typed.data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return typed.control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return typed.control_delivered_count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dw_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dw_id' could not be skipped");
      }
    }
    if (base_field == "data_dropped_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'data_dropped_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'data_dropped_count' could not be skipped");
      }
    }
    if (base_field == "data_delivered_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'data_delivered_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'data_delivered_count' could not be skipped");
      }
    }
    if (base_field == "control_dropped_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'control_dropped_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'control_dropped_count' could not be skipped");
      }
    }
    if (base_field == "control_delivered_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'control_delivered_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'control_delivered_count' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::DWAssociationsPeriodic*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return make_field_cmp(&T::data_dropped_count, next);
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return make_field_cmp(&T::data_delivered_count, next);
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return make_field_cmp(&T::control_dropped_count, next);
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return make_field_cmp(&T::control_delivered_count, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "data_dropped_count", "data_delivered_count", "control_dropped_count", "control_delivered_count", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return &static_cast<const T*>(stru)->data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return &static_cast<const T*>(stru)->data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return &static_cast<const T*>(stru)->control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return &static_cast<const T*>(stru)->control_delivered_count;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      static_cast<T*>(lhs)->data_dropped_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      static_cast<T*>(lhs)->data_delivered_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      static_cast<T*>(lhs)->control_dropped_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      static_cast<T*>(lhs)->control_delivered_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const  ::OpenDDS::DCPS::DWAssociationsPeriodic*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterPeriodicReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return static_cast<const T*>(lhs)->data_dropped_count == static_cast<const T*>(rhs)->data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return static_cast<const T*>(lhs)->data_delivered_count == static_cast<const T*>(rhs)->data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return static_cast<const T*>(lhs)->control_dropped_count == static_cast<const T*>(rhs)->control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return static_cast<const T*>(lhs)->control_delivered_count == static_cast<const T*>(rhs)->control_delivered_count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataWriterPeriodicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataWriterPeriodicReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DataWriterPeriodicReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataWriterPeriodicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DataWriterPeriodicReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterPeriodicReport */


/* Begin STRUCT: DataReaderAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataReaderAssociation_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(108, 231, 244, 43, 199, 141, 236, 60, 154, 100, 236, 123, 249, 129));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataReaderAssociation_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataReaderAssociation& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dw_id",0},{"state",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dw_id)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int16(value.state)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataReaderAssociation& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dw_id");
  vwrite(value_writer, value.dw_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("state");
  value_writer.write_int16(value.state);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DataReaderAssociation& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dw_id);
  stru.state = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DataReaderAssociation& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dw_id);
  primitive_serialized_size(encoding, size, stru.state);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DataReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dw_id)
    && (strm << stru.state);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dw_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.state)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderAssociation>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
  primitive_serialized_size(encoding, size, stru.value.state);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderAssociation>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id))
    && (strm << stru.value.state);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataReaderAssociation>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dw_9id_nested_key_only(stru.value.dw_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dw_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.state)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DataReaderAssociation> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DataReaderAssociation T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dw_id", 0),
      std::make_pair("state", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociation)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DataReaderAssociation& typed = *static_cast<const  ::OpenDDS::DCPS::DataReaderAssociation*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "state") == 0) {
      return typed.state;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociation)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dw_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dw_id' could not be skipped");
      }
    }
    if (base_field == "state") {
      ACE_CDR::Short val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'state' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  2 )) {
        throw std::runtime_error("Field 'state' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "state") == 0) {
      return make_field_cmp(&T::state, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociation)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "state", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "state") == 0) {
      return &static_cast<const T*>(stru)->state;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "state") == 0) {
      static_cast<T*>(lhs)->state = *static_cast<const  ::CORBA::Short*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociation)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "state") == 0) {
      return static_cast<const T*>(lhs)->state == static_cast<const T*>(rhs)->state;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataReaderAssociation>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DataReaderAssociation> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataReaderAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DataReaderAssociation>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderAssociation */


/* Begin TYPEDEF: DRAssociations */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DRAssociations_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(81, 162, 161, 191, 55, 203, 74, 217, 27, 202, 197, 229, 223, 120));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DRAssociations_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DRAssociations& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DRAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DRAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::DRAssociations tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::DRAssociations tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DRAssociations>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderAssociation>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DRAssociations>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderAssociation>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::DRAssociations>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::DataReaderAssociation> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::DRAssociations tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::DRAssociations tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DRAssociations*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DataReaderAssociation*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DRAssociations */


/* Begin STRUCT: DataReaderReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataReaderReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(119, 36, 91, 200, 250, 82, 229, 142, 97, 244, 125, 240, 105, 188));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataReaderReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataReaderReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dp_id",0},{"sub_handle",1},{"dr_id",2},{"topic_id",3},{"instances",4},{"associations",5},{"values",6},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dp_id)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.sub_handle)) return false;
      break;
    }
    case 2: {
      if (!vread(value_reader, value.dr_id)) return false;
      break;
    }
    case 3: {
      if (!vread(value_reader, value.topic_id)) return false;
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.instances);
        if (!value_reader.begin_element()) return false;
        if (!value_reader.read_int32(value.instances[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 5: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.associations);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.associations[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 6: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataReaderReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dp_id");
  vwrite(value_writer, value.dp_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("sub_handle");
  value_writer.write_int32(value.sub_handle);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("dr_id");
  vwrite(value_writer, value.dr_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("topic_id");
  vwrite(value_writer, value.topic_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("instances");
  value_writer.begin_sequence();
  value_writer.write_int32_array (value.instances.get_buffer(), value.instances.length());
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("associations");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.associations.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.associations[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DataReaderReport& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dp_id);
  stru.sub_handle = 0;
  set_default(stru.dr_id);
  set_default(stru.topic_id);
  stru.instances.length(0);
  stru.associations.length(0);
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DataReaderReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dp_id);
  primitive_serialized_size(encoding, size, stru.sub_handle);
  serialized_size(encoding, size, stru.dr_id);
  serialized_size(encoding, size, stru.topic_id);
  serialized_size(encoding, size, stru.instances);
  serialized_size(encoding, size, stru.associations);
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DataReaderReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dp_id)
    && (strm << stru.sub_handle)
    && (strm << stru.dr_id)
    && (strm << stru.topic_id)
    && (strm << stru.instances)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataReaderReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dp_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.sub_handle)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dr_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.topic_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.instances)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.associations)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataReaderReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dr_9id_nested_key_only(stru.value.dr_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dr_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::DataReaderReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::DataReaderReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DataReaderReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dr_9id_nested_key_only(stru.value.dr_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dr_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DataReaderReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DataReaderReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr DataReaderReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataReaderReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DataReaderReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataReaderReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DataReaderReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DataReaderReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataReaderReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool DataReaderReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* DataReaderReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void DataReaderReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& DataReaderReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_DataReaderReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& DataReaderReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_DataReaderReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& DataReaderReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& DataReaderReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility DataReaderReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

DataReaderReportTypeSupport::_ptr_type DataReaderReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DataReaderReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DataReaderReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dp_id", 0),
      std::make_pair("sub_handle", 1),
      std::make_pair("dr_id", 2),
      std::make_pair("topic_id", 3),
      std::make_pair("instances", 4),
      std::make_pair("associations", 5),
      std::make_pair("values", 6),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 7);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DataReaderReport& typed = *static_cast<const  ::OpenDDS::DCPS::DataReaderReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return typed.sub_handle;
    }
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dp_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dp_id' could not be skipped");
      }
    }
    if (base_field == "sub_handle") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sub_handle' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sub_handle' could not be skipped");
      }
    }
    if (base_field == "dr_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dr_id' could not be skipped");
      }
    }
    if (base_field == "topic_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'topic_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::InstanceHandleSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::DRAssociations*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return make_field_cmp(&T::sub_handle, next);
    }
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "sub_handle", "dr_id", "topic_id", "instances", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return &static_cast<const T*>(stru)->sub_handle;
    }
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "instances") == 0) {
      return &static_cast<const T*>(stru)->instances;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      static_cast<T*>(lhs)->sub_handle = *static_cast<const  ::DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instances") == 0) {
      static_cast<T*>(lhs)->instances = *static_cast<const  ::DDS::InstanceHandleSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const  ::OpenDDS::DCPS::DRAssociations*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sub_handle") == 0) {
      return static_cast<const T*>(lhs)->sub_handle == static_cast<const T*>(rhs)->sub_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataReaderReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DataReaderReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataReaderReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DataReaderReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderReport */


/* Begin STRUCT: DataReaderAssociationPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataReaderAssociationPeriodic_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(89, 81, 27, 10, 154, 138, 143, 75, 220, 91, 103, 105, 233, 4));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataReaderAssociationPeriodic_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dw_id",0},{"samples_available",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dw_id)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.samples_available)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dw_id");
  vwrite(value_writer, value.dw_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("samples_available");
  value_writer.write_uint32(value.samples_available);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DataReaderAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dw_id);
  stru.samples_available = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dw_id);
  primitive_serialized_size(encoding, size, stru.samples_available);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dw_id)
    && (strm << stru.samples_available);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dw_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.samples_available)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id));
  primitive_serialized_size(encoding, size, stru.value.samples_available);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dw_id))
    && (strm << stru.value.samples_available);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataReaderAssociationPeriodic>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dw_9id_nested_key_only(stru.value.dw_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dw_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.samples_available)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DataReaderAssociationPeriodic> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DataReaderAssociationPeriodic T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dw_id", 0),
      std::make_pair("samples_available", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociationPeriodic)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& typed = *static_cast<const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return typed.samples_available;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dw_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dw_id' could not be skipped");
      }
    }
    if (base_field == "samples_available") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'samples_available' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'samples_available' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return make_field_cmp(&T::samples_available, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "samples_available", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return &static_cast<const T*>(stru)->samples_available;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "samples_available") == 0) {
      static_cast<T*>(lhs)->samples_available = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "samples_available") == 0) {
      return static_cast<const T*>(lhs)->samples_available == static_cast<const T*>(rhs)->samples_available;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataReaderAssociationPeriodic>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DataReaderAssociationPeriodic> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataReaderAssociationPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DataReaderAssociationPeriodic>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderAssociationPeriodic */


/* Begin TYPEDEF: DRAssociationsPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DRAssociationsPeriodic_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(134, 67, 194, 0, 112, 121, 90, 8, 149, 201, 37, 72, 141, 12));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DRAssociationsPeriodic_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DRAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DRAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DRAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::DRAssociationsPeriodic tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::DRAssociationsPeriodic tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DRAssociationsPeriodic>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DRAssociationsPeriodic>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::DRAssociationsPeriodic>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::DataReaderAssociationPeriodic> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::DRAssociationsPeriodic tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::DRAssociationsPeriodic tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DRAssociationsPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DataReaderAssociationPeriodic*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DRAssociationsPeriodic */


/* Begin STRUCT: DataReaderPeriodicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataReaderPeriodicReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(221, 7, 43, 106, 19, 140, 119, 80, 244, 201, 222, 158, 62, 105));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataReaderPeriodicReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataReaderPeriodicReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"dr_id",0},{"associations",1},{"values",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.dr_id)) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.associations);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.associations[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 2: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataReaderPeriodicReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("dr_id");
  vwrite(value_writer, value.dr_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("associations");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.associations.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.associations[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::DataReaderPeriodicReport& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.dr_id);
  stru.associations.length(0);
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DataReaderPeriodicReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.dr_id);
  serialized_size(encoding, size, stru.associations);
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DataReaderPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.dr_id)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataReaderPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.dr_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.associations)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dr_9id_nested_key_only(stru.value.dr_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dr_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.dr_id));
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_dr_9id_nested_key_only(stru.value.dr_id);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_dr_9id_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DataReaderPeriodicReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DataReaderPeriodicReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr DataReaderPeriodicReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataReaderPeriodicReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DataReaderPeriodicReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataReaderPeriodicReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DataReaderPeriodicReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DataReaderPeriodicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataReaderPeriodicReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool DataReaderPeriodicReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* DataReaderPeriodicReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void DataReaderPeriodicReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& DataReaderPeriodicReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_DataReaderPeriodicReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& DataReaderPeriodicReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_DataReaderPeriodicReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& DataReaderPeriodicReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& DataReaderPeriodicReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility DataReaderPeriodicReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

DataReaderPeriodicReportTypeSupport::_ptr_type DataReaderPeriodicReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::DataReaderPeriodicReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::DataReaderPeriodicReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "dr_id.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("dr_id", 0),
      std::make_pair("associations", 1),
      std::make_pair("values", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderPeriodicReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::DataReaderPeriodicReport& typed = *static_cast<const  ::OpenDDS::DCPS::DataReaderPeriodicReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "dr_id") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'dr_id' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::DRAssociationsPeriodic*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const  ::OpenDDS::DCPS::DRAssociationsPeriodic*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderPeriodicReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::DataReaderPeriodicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataReaderPeriodicReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::DataReaderPeriodicReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataReaderPeriodicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::DataReaderPeriodicReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderPeriodicReport */


/* Begin STRUCT: TransportReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(196, 145, 160, 248, 26, 81, 139, 121, 16, 103, 247, 162, 44, 169));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::TransportReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"host",0},{"pid",1},{"transport_id",2},{"transport_type",3},{"values",4},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.host = x.c_str();
      }
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.pid)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint32(value.transport_id)) return false;
      break;
    }
    case 3: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.transport_type = x.c_str();
      }
      break;
    }
    case 4: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.values);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.values[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::TransportReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("host");
  value_writer.write_string(value.host);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("pid");
  value_writer.write_int32(value.pid);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transport_id");
  value_writer.write_uint32(value.transport_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("transport_type");
  value_writer.write_string(value.transport_type);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("values");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.values.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.values[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::TransportReport& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.host = "";
  stru.pid = 0;
  stru.transport_id = 0;
  stru.transport_type = "";
  stru.values.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::TransportReport& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.host.in()) + 1;
  primitive_serialized_size(encoding, size, stru.pid);
  primitive_serialized_size(encoding, size, stru.transport_id);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.transport_type.in()) + 1;
  serialized_size(encoding, size, stru.values);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::TransportReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.host.in())
    && (strm << stru.pid)
    && (strm << stru.transport_id)
    && (strm << stru.transport_type.in())
    && (strm << stru.values);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TransportReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.host.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.pid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport_type.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.values)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.host.in()) + 1;
  primitive_serialized_size(encoding, size, stru.value.pid);
  primitive_serialized_size(encoding, size, stru.value.transport_id);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.host.in())
    && (strm << stru.value.pid)
    && (strm << stru.value.transport_id);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::TransportReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.host.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.pid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.transport_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::TransportReport>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.host.in()) + 1;
  primitive_serialized_size(encoding, size, stru.value.pid);
  primitive_serialized_size(encoding, size, stru.value.transport_id);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::TransportReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.host.in())
    && (strm << stru.value.pid)
    && (strm << stru.value.transport_id);
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::TransportReport>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.host.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.pid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.transport_id)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr TransportReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<TransportReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr TransportReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TransportReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr TransportReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TransportReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<TransportReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& TransportReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TransportReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool TransportReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* TransportReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void TransportReportTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& TransportReportTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_TransportReport_xtag>();
}

const OpenDDS::XTypes::TypeMap& TransportReportTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_TransportReport_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& TransportReportTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& TransportReportTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility TransportReportTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

TransportReportTypeSupport::_ptr_type TransportReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::TransportReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::TransportReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "host")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "pid")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "transport_id")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("host", 0),
      std::make_pair("pid", 1),
      std::make_pair("transport_id", 2),
      std::make_pair("transport_type", 3),
      std::make_pair("values", 4),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportReport)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::TransportReport& typed = *static_cast<const  ::OpenDDS::DCPS::TransportReport*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return typed.transport_type.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportReport)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "host") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'host' contents could not be skipped");
      }
    }
    if (base_field == "pid") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'pid' could not be skipped");
      }
    }
    if (base_field == "transport_id") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'transport_id' could not be skipped");
      }
    }
    if (base_field == "transport_type") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'transport_type' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'transport_type' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'transport_type' contents could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::NVPSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return make_field_cmp(&T::transport_type, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "transport_id", "transport_type", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return &static_cast<const T*>(stru)->transport_type;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      static_cast<T*>(lhs)->transport_type = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const  ::OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host.in(), static_cast<const T*>(rhs)->host.in());
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->transport_type.in(), static_cast<const T*>(rhs)->transport_type.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::TransportReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::TransportReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TransportReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::TransportReport>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportReport */


/* Begin ENUM: ReportType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ReportType_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(182, 129, 179, 8, 126, 53, 81, 10, 11, 104, 40, 141, 245, 3));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ReportType_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ReportType& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListEnumHelper::Pair pairs[] = {{"SERVICE_PARTICIPANT_REPORT_TYPE",0},{"DOMAIN_PARTICIPANT_REPORT_TYPE",1},{"TOPIC_REPORT_TYPE",2},{"PUBLISHER_REPORT_TYPE",3},{"SUBSCRIBER_REPORT_TYPE",4},{"DATA_WRITER_REPORT_TYPE",5},{"DATA_WRITER_PERIODIC_REPORT_TYPE",6},{"DATA_READER_REPORT_TYPE",7},{"DATA_READER_PERIODIC_REPORT_TYPE",8},{"TRANSPORT_REPORT_TYPE",9},{0,0}};
  ListEnumHelper helper(pairs);
  return value_reader.read_enum(value, helper);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ReportType& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  switch (value) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    value_writer.write_enum("SERVICE_PARTICIPANT_REPORT_TYPE", OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    value_writer.write_enum("DOMAIN_PARTICIPANT_REPORT_TYPE", OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    value_writer.write_enum("TOPIC_REPORT_TYPE", OpenDDS::DCPS::TOPIC_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    value_writer.write_enum("PUBLISHER_REPORT_TYPE", OpenDDS::DCPS::PUBLISHER_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    value_writer.write_enum("SUBSCRIBER_REPORT_TYPE", OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    value_writer.write_enum("DATA_WRITER_REPORT_TYPE", OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    value_writer.write_enum("DATA_WRITER_PERIODIC_REPORT_TYPE", OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    value_writer.write_enum("DATA_READER_REPORT_TYPE", OpenDDS::DCPS::DATA_READER_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    value_writer.write_enum("DATA_READER_PERIODIC_REPORT_TYPE", OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE);
    break;
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    value_writer.write_enum("TRANSPORT_REPORT_TYPE", OpenDDS::DCPS::TRANSPORT_REPORT_TYPE);
    break;
  }
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ReportType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
    if (CORBA::ULong(enumval) >= 10) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid enumerated value for  ::OpenDDS::DCPS::ReportType (%u)\n"), enumval));
      return false;
    }
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ReportType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    if (temp >= 10) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      return false;
    }
    enumval = static_cast< ::OpenDDS::DCPS::ReportType>(temp);
    return true;
  }
  return false;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_ReportType_names[] = {
  "SERVICE_PARTICIPANT_REPORT_TYPE",
  "DOMAIN_PARTICIPANT_REPORT_TYPE",
  "TOPIC_REPORT_TYPE",
  "PUBLISHER_REPORT_TYPE",
  "SUBSCRIBER_REPORT_TYPE",
  "DATA_WRITER_REPORT_TYPE",
  "DATA_WRITER_PERIODIC_REPORT_TYPE",
  "DATA_READER_REPORT_TYPE",
  "DATA_READER_PERIODIC_REPORT_TYPE",
  "TRANSPORT_REPORT_TYPE"
};
const size_t gen_OpenDDS_DCPS_ReportType_names_size = 10;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: ReportType */


/* Begin UNION: GenericReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GenericReport_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(199, 197, 33, 51, 165, 2, 74, 12, 33, 68, 177, 178, 40, 185));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GenericReport_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::GenericReport& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  if (!value_reader.begin_union()) return false;
  if (!value_reader.begin_discriminator()) return false;
  {
     ::OpenDDS::DCPS::ReportType d;
    if (!vread(value_reader, d)) return false;
    value._d(d);
  }
  if (!value_reader.end_discriminator()) return false;
  switch (value._d()) {
  case  ::OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::ServiceParticipantReport bv;
    if (!vread(value_reader, bv)) return false;
    value.sp_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::DomainParticipantReport bv;
    if (!vread(value_reader, bv)) return false;
    value.dp_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::TOPIC_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::TopicReport bv;
    if (!vread(value_reader, bv)) return false;
    value.topic_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::PUBLISHER_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::PublisherReport bv;
    if (!vread(value_reader, bv)) return false;
    value.publisher_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::SubscriberReport bv;
    if (!vread(value_reader, bv)) return false;
    value.subscriber_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::DataWriterReport bv;
    if (!vread(value_reader, bv)) return false;
    value.dw_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::DataWriterPeriodicReport bv;
    if (!vread(value_reader, bv)) return false;
    value.dw_per_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::DATA_READER_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::DataReaderReport bv;
    if (!vread(value_reader, bv)) return false;
    value.dr_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::DataReaderPeriodicReport bv;
    if (!vread(value_reader, bv)) return false;
    value.dr_per_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  case  ::OpenDDS::DCPS::TRANSPORT_REPORT_TYPE: {
    if (!value_reader.begin_union_member()) return false;
     ::OpenDDS::DCPS::TransportReport bv;
    if (!vread(value_reader, bv)) return false;
    value.transport_report(bv);
    if (!value_reader.end_union_member()) return false;
    break;
  }
  default:
    break;
  }
  if (!value_reader.end_union()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::GenericReport& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_union();
  value_writer.begin_discriminator();
  vwrite(value_writer, value._d());
  value_writer.end_discriminator();
  switch (value._d()) {
  case  ::OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE: {
    value_writer.begin_union_member("sp_report");
    vwrite(value_writer, value.sp_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE: {
    value_writer.begin_union_member("dp_report");
    vwrite(value_writer, value.dp_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::TOPIC_REPORT_TYPE: {
    value_writer.begin_union_member("topic_report");
    vwrite(value_writer, value.topic_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::PUBLISHER_REPORT_TYPE: {
    value_writer.begin_union_member("publisher_report");
    vwrite(value_writer, value.publisher_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE: {
    value_writer.begin_union_member("subscriber_report");
    vwrite(value_writer, value.subscriber_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE: {
    value_writer.begin_union_member("dw_report");
    vwrite(value_writer, value.dw_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE: {
    value_writer.begin_union_member("dw_per_report");
    vwrite(value_writer, value.dw_per_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::DATA_READER_REPORT_TYPE: {
    value_writer.begin_union_member("dr_report");
    vwrite(value_writer, value.dr_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE: {
    value_writer.begin_union_member("dr_per_report");
    vwrite(value_writer, value.dr_per_report());
    value_writer.end_union_member();
    break;
  }
  case  ::OpenDDS::DCPS::TRANSPORT_REPORT_TYPE: {
    value_writer.begin_union_member("transport_report");
    vwrite(value_writer, value.transport_report());
    value_writer.end_union_member();
    break;
  }
  default:
    break;
  }
  value_writer.end_union();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::GenericReport& uni)
{
  ACE_UNUSED_ARG(uni);
   ::OpenDDS::DCPS::ReportType temp;
    temp =  ::OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE;
  uni._d(temp);
  set_default(uni.sp_report());
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GenericReport& uni)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(uni);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  switch (uni._d()) {
  case  ::OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE: {
    serialized_size(encoding, size, uni.sp_report());
    break;
  }
  case  ::OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE: {
    serialized_size(encoding, size, uni.dp_report());
    break;
  }
  case  ::OpenDDS::DCPS::TOPIC_REPORT_TYPE: {
    serialized_size(encoding, size, uni.topic_report());
    break;
  }
  case  ::OpenDDS::DCPS::PUBLISHER_REPORT_TYPE: {
    serialized_size(encoding, size, uni.publisher_report());
    break;
  }
  case  ::OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE: {
    serialized_size(encoding, size, uni.subscriber_report());
    break;
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE: {
    serialized_size(encoding, size, uni.dw_report());
    break;
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE: {
    serialized_size(encoding, size, uni.dw_per_report());
    break;
  }
  case  ::OpenDDS::DCPS::DATA_READER_REPORT_TYPE: {
    serialized_size(encoding, size, uni.dr_report());
    break;
  }
  case  ::OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE: {
    serialized_size(encoding, size, uni.dr_per_report());
    break;
  }
  case  ::OpenDDS::DCPS::TRANSPORT_REPORT_TYPE: {
    serialized_size(encoding, size, uni.transport_report());
    break;
  }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GenericReport& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, uni);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case  ::OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE: {
    return (strm << uni.sp_report());
  }
  case  ::OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE: {
    return (strm << uni.dp_report());
  }
  case  ::OpenDDS::DCPS::TOPIC_REPORT_TYPE: {
    return (strm << uni.topic_report());
  }
  case  ::OpenDDS::DCPS::PUBLISHER_REPORT_TYPE: {
    return (strm << uni.publisher_report());
  }
  case  ::OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE: {
    return (strm << uni.subscriber_report());
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE: {
    return (strm << uni.dw_report());
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE: {
    return (strm << uni.dw_per_report());
  }
  case  ::OpenDDS::DCPS::DATA_READER_REPORT_TYPE: {
    return (strm << uni.dr_report());
  }
  case  ::OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE: {
    return (strm << uni.dr_per_report());
  }
  case  ::OpenDDS::DCPS::TRANSPORT_REPORT_TYPE: {
    return (strm << uni.transport_report());
  }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GenericReport& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::ReportType disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case  ::OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE: {
     ::OpenDDS::DCPS::ServiceParticipantReport tmp;
    if (strm >> tmp) {
      uni.sp_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE: {
     ::OpenDDS::DCPS::DomainParticipantReport tmp;
    if (strm >> tmp) {
      uni.dp_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::TOPIC_REPORT_TYPE: {
     ::OpenDDS::DCPS::TopicReport tmp;
    if (strm >> tmp) {
      uni.topic_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::PUBLISHER_REPORT_TYPE: {
     ::OpenDDS::DCPS::PublisherReport tmp;
    if (strm >> tmp) {
      uni.publisher_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE: {
     ::OpenDDS::DCPS::SubscriberReport tmp;
    if (strm >> tmp) {
      uni.subscriber_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE: {
     ::OpenDDS::DCPS::DataWriterReport tmp;
    if (strm >> tmp) {
      uni.dw_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE: {
     ::OpenDDS::DCPS::DataWriterPeriodicReport tmp;
    if (strm >> tmp) {
      uni.dw_per_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::DATA_READER_REPORT_TYPE: {
     ::OpenDDS::DCPS::DataReaderReport tmp;
    if (strm >> tmp) {
      uni.dr_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE: {
     ::OpenDDS::DCPS::DataReaderPeriodicReport tmp;
    if (strm >> tmp) {
      uni.dr_per_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  case  ::OpenDDS::DCPS::TRANSPORT_REPORT_TYPE: {
     ::OpenDDS::DCPS::TransportReport tmp;
    if (strm >> tmp) {
      uni.transport_report(tmp);
      uni._d(disc);
      return true;
    }
        strm.set_construction_status(Serializer::ElementConstructionFailure);
        return false;
    }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::GenericReport> uni)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(uni);
}

bool operator<<(Serializer& strm, NestedKeyOnly<const  ::OpenDDS::DCPS::GenericReport> uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::GenericReport> uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::GenericReport> uni)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(uni);
}

bool operator<<(Serializer& strm, KeyOnly<const  ::OpenDDS::DCPS::GenericReport> uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly< ::OpenDDS::DCPS::GenericReport> uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::GenericReport> : MetaStruct {
  typedef  ::OpenDDS::DCPS::GenericReport T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::GenericReport& typed = *static_cast<const  ::OpenDDS::DCPS::GenericReport*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GenericReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    ACE_UNUSED_ARG(ser);
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::OpenDDS::DCPS::GenericReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GenericReport)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    ACE_UNUSED_ARG(stru);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GenericReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GenericReport)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GenericReport)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::GenericReport>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::GenericReport> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GenericReport*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  const bool is_mutable = 0;
  unsigned member_id;
  size_t field_size;
  bool must_understand = false;
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
   ::OpenDDS::DCPS::ReportType disc;
  if (!(ser >> disc)) {
    return false;
  }
  switch (disc) {
  case  ::OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::ServiceParticipantReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DomainParticipantReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::TOPIC_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::TopicReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::PUBLISHER_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::PublisherReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::SubscriberReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DataWriterReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DataWriterPeriodicReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::DATA_READER_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DataReaderReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::DataReaderPeriodicReport*>(0))) return false;
    return true;
  }
  case  ::OpenDDS::DCPS::TRANSPORT_REPORT_TYPE: {
    if (is_mutable) {
      if (!ser.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
    }
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::TransportReport*>(0))) return false;
    return true;
  }
  default:
    break;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: GenericReport */


/* Begin INTERFACE: ProcessMonitor */


/* End INTERFACE: ProcessMonitor */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

namespace {
XTypes::TypeObject minimal_to0()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(239, 141, 154, 37, 164, 156, 92, 159, 62, 117, 207, 69, 96, 177)))))))));
}

XTypes::TypeObject minimal_to1()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(3), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to2()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalUnionType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalUnionHeader(XTypes::MinimalTypeDetail()), XTypes::MinimalDiscriminatorMember(XTypes::CommonDiscriminatorMember(XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(18, 64, 210, 182, 85, 60, 89, 52, 235, 185, 39, 84, 171, 58)))), XTypes::MinimalUnionMemberSeq().append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32), XTypes::UnionCaseLabelSeq().append(0)), XTypes::MinimalMemberDetail(92, 206, 50, 67))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_FLOAT64), XTypes::UnionCaseLabelSeq().append(1)), XTypes::MinimalMemberDetail(218, 89, 44, 149))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0)), XTypes::UnionCaseLabelSeq().append(2)), XTypes::MinimalMemberDetail(134, 58, 133, 180))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 128, 174, 247, 156, 172, 129, 120, 54, 68, 110, 95, 248, 45)), XTypes::UnionCaseLabelSeq().append(3)), XTypes::MinimalMemberDetail(108, 173, 58, 49))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57)), XTypes::UnionCaseLabelSeq().append(4)), XTypes::MinimalMemberDetail(232, 254, 90, 203))))));
}

XTypes::TypeObject minimal_to3()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(194, 7, 25, 38))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(150, 24, 97, 118))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(164, 41, 135, 247))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(3, 0), XTypes::MinimalMemberDetail(150, 203, 96, 173))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(4, 0), XTypes::MinimalMemberDetail(198, 17, 226, 72))))));
}

XTypes::TypeObject minimal_to4()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(103, 179, 219, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(13, 179, 32, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))), XTypes::MinimalMemberDetail(52, 146, 29, 216))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(86, 37, 101, 62, 120, 127, 181, 152, 147, 167, 114, 56, 92, 4))), XTypes::MinimalMemberDetail(152, 140, 121, 55))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to5()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211)))))))));
}

XTypes::TypeObject minimal_to6()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(108, 231, 244, 43, 199, 141, 236, 60, 154, 100, 236, 123, 249, 129)))))))));
}

XTypes::TypeObject minimal_to7()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TK_UINT32))))))));
}

XTypes::TypeObject minimal_to8()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(138, 133, 16, 146))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(65, 161, 46, 29))))));
}

XTypes::TypeObject minimal_to9()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(138, 133, 16, 146))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT16)), XTypes::MinimalMemberDetail(158, 211, 158, 46))))));
}

XTypes::TypeObject minimal_to10()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(50, 226, 203, 15))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(95, 36, 255, 16))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(182, 82, 109, 23))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(25, 180, 215, 39))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(54, 134, 32, 238, 30, 39, 9, 207, 228, 231, 150, 1, 254, 148))), XTypes::MinimalMemberDetail(111, 169, 50, 84))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(81, 162, 161, 191, 55, 203, 74, 217, 27, 202, 197, 229, 223, 120))), XTypes::MinimalMemberDetail(134, 90, 233, 38))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to11()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(89, 81, 27, 10, 154, 138, 143, 75, 220, 91, 103, 105, 233, 4)))))))));
}

XTypes::TypeObject minimal_to12()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT32))))));
}

XTypes::TypeObject minimal_to13()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0)))))))));
}

XTypes::TypeObject minimal_to14()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(177, 178, 109, 157))))));
}

XTypes::TypeObject minimal_to15()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(12), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to16()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(230, 121, 140, 67, 255, 212, 66, 102, 19, 63, 62, 243, 198, 215)))))))));
}

XTypes::TypeObject minimal_to17()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalEnumeratedType(0, XTypes::MinimalEnumeratedHeader(XTypes::CommonEnumeratedHeader(32)), XTypes::MinimalEnumeratedLiteralSeq().append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(0, XTypes::IS_DEFAULT), XTypes::MinimalMemberDetail(144, 156, 17, 211))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(1, 0), XTypes::MinimalMemberDetail(31, 128, 19, 8))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(2, 0), XTypes::MinimalMemberDetail(34, 170, 158, 94))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(3, 0), XTypes::MinimalMemberDetail(16, 203, 81, 148))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(4, 0), XTypes::MinimalMemberDetail(187, 175, 143, 127))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(5, 0), XTypes::MinimalMemberDetail(189, 49, 45, 142))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(6, 0), XTypes::MinimalMemberDetail(23, 172, 87, 55))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(7, 0), XTypes::MinimalMemberDetail(115, 212, 28, 139))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(8, 0), XTypes::MinimalMemberDetail(204, 69, 37, 215))).append(XTypes::MinimalEnumeratedLiteral(XTypes::CommonEnumeratedLiteral(9, 0), XTypes::MinimalMemberDetail(124, 199, 128, 146))))));
}

XTypes::TypeObject minimal_to18()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(225, 38, 8, 148))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(50, 226, 203, 15))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(95, 108, 40, 186))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))), XTypes::MinimalMemberDetail(121, 235, 1, 246))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to19()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(50, 226, 203, 15))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(25, 180, 215, 39))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(235, 102, 36, 53))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(34, 23, 141, 102))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to20()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253)))))))));
}

XTypes::TypeObject minimal_to21()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(103, 179, 219, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(13, 179, 32, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(95, 108, 40, 186))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(157, 89, 81, 62))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to22()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalUnionType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalUnionHeader(XTypes::MinimalTypeDetail()), XTypes::MinimalDiscriminatorMember(XTypes::CommonDiscriminatorMember(XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(182, 129, 179, 8, 126, 53, 81, 10, 11, 104, 40, 141, 245, 3)))), XTypes::MinimalUnionMemberSeq().append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(46, 12, 12, 124, 135, 91, 231, 193, 96, 122, 19, 90, 238, 121)), XTypes::UnionCaseLabelSeq().append(0)), XTypes::MinimalMemberDetail(171, 39, 218, 244))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 39, 201, 99, 6, 22, 39, 179, 24, 201, 41, 224, 214, 90)), XTypes::UnionCaseLabelSeq().append(1)), XTypes::MinimalMemberDetail(165, 81, 231, 193))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(190, 62, 247, 176, 192, 0, 248, 21, 21, 79, 115, 156, 216, 238)), XTypes::UnionCaseLabelSeq().append(2)), XTypes::MinimalMemberDetail(129, 92, 134, 189))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(226, 87, 217, 30, 153, 223, 93, 179, 38, 202, 87, 127, 233, 175)), XTypes::UnionCaseLabelSeq().append(3)), XTypes::MinimalMemberDetail(63, 68, 66, 113))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 80, 30, 145, 7, 41, 214, 11, 173, 240, 217, 37, 27, 129)), XTypes::UnionCaseLabelSeq().append(4)), XTypes::MinimalMemberDetail(132, 242, 79, 151))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(215, 179, 248, 95, 106, 44, 70, 151, 10, 153, 90, 1, 103, 201)), XTypes::UnionCaseLabelSeq().append(5)), XTypes::MinimalMemberDetail(107, 122, 216, 231))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(225, 26, 197, 244, 21, 120, 136, 183, 86, 147, 255, 129, 116, 122)), XTypes::UnionCaseLabelSeq().append(6)), XTypes::MinimalMemberDetail(222, 136, 38, 124))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(119, 36, 91, 200, 250, 82, 229, 142, 97, 244, 125, 240, 105, 188)), XTypes::UnionCaseLabelSeq().append(7)), XTypes::MinimalMemberDetail(182, 155, 158, 231))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(221, 7, 43, 106, 19, 140, 119, 80, 244, 201, 222, 158, 62, 105)), XTypes::UnionCaseLabelSeq().append(8)), XTypes::MinimalMemberDetail(141, 225, 157, 154))).append(XTypes::MinimalUnionMember(XTypes::CommonUnionMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(196, 145, 160, 248, 26, 81, 139, 121, 16, 103, 247, 162, 44, 169)), XTypes::UnionCaseLabelSeq().append(9)), XTypes::MinimalMemberDetail(89, 88, 76, 79))))));
}

XTypes::TypeObject minimal_to23()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(123, 139, 150, 90))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_FLOAT64)), XTypes::MinimalMemberDetail(101, 176, 226, 136))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_FLOAT64)), XTypes::MinimalMemberDetail(227, 131, 35, 76))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_FLOAT64)), XTypes::MinimalMemberDetail(185, 61, 177, 136))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_FLOAT64)), XTypes::MinimalMemberDetail(125, 146, 27, 31))))));
}

XTypes::TypeObject minimal_to24()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(103, 179, 219, 168))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(13, 179, 32, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(50, 226, 203, 15))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(102, 44, 191, 18))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))), XTypes::MinimalMemberDetail(227, 41, 178, 121))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to25()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(50, 226, 203, 15))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(138, 54, 185, 130))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(138, 133, 16, 146))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(25, 180, 215, 39))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(54, 134, 32, 238, 30, 39, 9, 207, 228, 231, 150, 1, 254, 148))), XTypes::MinimalMemberDetail(111, 169, 50, 84))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(172, 30, 138, 111, 124, 204, 7, 228, 71, 236, 229, 225, 30, 151))), XTypes::MinimalMemberDetail(134, 90, 233, 38))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to26()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(182, 82, 109, 23))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(134, 67, 194, 0, 112, 121, 90, 8, 149, 201, 37, 72, 141, 12))), XTypes::MinimalMemberDetail(134, 90, 233, 38))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to27()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(138, 133, 16, 146))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(77, 31, 32, 40))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(81, 103, 115, 185))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(83, 47, 7, 157))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(192, 251, 95, 33))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(9, 55, 16, 127, 233, 130, 146, 93, 171, 107, 196, 111, 236, 147))), XTypes::MinimalMemberDetail(134, 90, 233, 38))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to28()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(225, 38, 8, 148))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(50, 226, 203, 15))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(95, 108, 40, 186))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))), XTypes::MinimalMemberDetail(191, 99, 155, 95))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))), XTypes::MinimalMemberDetail(240, 156, 199, 238))))));
}

XTypes::TypeObject minimal_to29()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(246, 47, 199, 145, 7, 79, 14, 149, 15, 98, 147, 98, 215, 244)))))))));
}

XTypes::TypeObject minimal_to30()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(182, 82, 109, 23))))));
}

XTypes::TypeObject minimal_to31()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))), XTypes::MinimalMemberDetail(87, 2, 74, 74))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(61, 5, 144, 205))))));
}

XTypes::TypeObject minimal_to32()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(182, 82, 109, 23))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(202, 68, 133, 22))))));
}

XTypes::TypeObject minimal_to33()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(12, 82, 28, 208, 107, 19, 44, 103, 146, 93, 239, 13, 190, 124))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeMap get_minimal_type_map_private()
{
  XTypes::TypeMap tm;
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(9, 55, 16, 127, 233, 130, 146, 93, 171, 107, 196, 111, 236, 147))] = minimal_to0();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))] = minimal_to1();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(12, 82, 28, 208, 107, 19, 44, 103, 146, 93, 239, 13, 190, 124))] = minimal_to2();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(18, 64, 210, 182, 85, 60, 89, 52, 235, 185, 39, 84, 171, 58))] = minimal_to3();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(46, 12, 12, 124, 135, 91, 231, 193, 96, 122, 19, 90, 238, 121))] = minimal_to4();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(54, 134, 32, 238, 30, 39, 9, 207, 228, 231, 150, 1, 254, 148))] = minimal_to5();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(81, 162, 161, 191, 55, 203, 74, 217, 27, 202, 197, 229, 223, 120))] = minimal_to6();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(86, 37, 101, 62, 120, 127, 181, 152, 147, 167, 114, 56, 92, 4))] = minimal_to7();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(89, 81, 27, 10, 154, 138, 143, 75, 220, 91, 103, 105, 233, 4))] = minimal_to8();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(108, 231, 244, 43, 199, 141, 236, 60, 154, 100, 236, 123, 249, 129))] = minimal_to9();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(119, 36, 91, 200, 250, 82, 229, 142, 97, 244, 125, 240, 105, 188))] = minimal_to10();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(134, 67, 194, 0, 112, 121, 90, 8, 149, 201, 37, 72, 141, 12))] = minimal_to11();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))] = minimal_to12();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))] = minimal_to13();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))] = minimal_to14();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))] = minimal_to15();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(172, 30, 138, 111, 124, 204, 7, 228, 71, 236, 229, 225, 30, 151))] = minimal_to16();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(182, 129, 179, 8, 126, 53, 81, 10, 11, 104, 40, 141, 245, 3))] = minimal_to17();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 80, 30, 145, 7, 41, 214, 11, 173, 240, 217, 37, 27, 129))] = minimal_to18();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(190, 62, 247, 176, 192, 0, 248, 21, 21, 79, 115, 156, 216, 238))] = minimal_to19();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))] = minimal_to20();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(196, 145, 160, 248, 26, 81, 139, 121, 16, 103, 247, 162, 44, 169))] = minimal_to21();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(199, 197, 33, 51, 165, 2, 74, 12, 33, 68, 177, 178, 40, 185))] = minimal_to22();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(205, 128, 174, 247, 156, 172, 129, 120, 54, 68, 110, 95, 248, 45))] = minimal_to23();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 39, 201, 99, 6, 22, 39, 179, 24, 201, 41, 224, 214, 90))] = minimal_to24();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(215, 179, 248, 95, 106, 44, 70, 151, 10, 153, 90, 1, 103, 201))] = minimal_to25();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(221, 7, 43, 106, 19, 140, 119, 80, 244, 201, 222, 158, 62, 105))] = minimal_to26();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(225, 26, 197, 244, 21, 120, 136, 183, 86, 147, 255, 129, 116, 122))] = minimal_to27();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(226, 87, 217, 30, 153, 223, 93, 179, 38, 202, 87, 127, 233, 175))] = minimal_to28();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(229, 56, 49, 136, 125, 194, 199, 89, 39, 67, 25, 253, 156, 175))] = minimal_to29();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(230, 121, 140, 67, 255, 212, 66, 102, 19, 63, 62, 243, 198, 215))] = minimal_to30();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))] = minimal_to31();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(239, 141, 154, 37, 164, 156, 92, 159, 62, 117, 207, 69, 96, 177))] = minimal_to32();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(246, 47, 199, 145, 7, 79, 14, 149, 15, 98, 147, 98, 215, 244))] = minimal_to33();
  return tm;
}

}

const XTypes::TypeMap& get_minimal_type_map()
{
  static XTypes::TypeMap tm;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), tm);
  if (tm.empty()) {
    tm = get_minimal_type_map_private();
  }
  return tm;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

