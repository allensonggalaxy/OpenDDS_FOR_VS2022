/* Generated by ..\bin\opendds_idl version 3.20.0 (ACE version 6.2a_p23) running on input file OpenddsDcpsExt.idl */
#include "DCPS/DdsDcps_pch.h"
#include "OpenddsDcpsExtTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/XTypes/TypeObject.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: ParticipantLocation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ParticipantLocation_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207));
  }
  return ti;
}

static const XTypes::TypeMap& get_minimal_type_map();
template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ParticipantLocation_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ParticipantLocation */


/* Begin CONST: LOCATION_LOCAL */


/* End CONST: LOCATION_LOCAL */


/* Begin CONST: LOCATION_ICE */


/* End CONST: LOCATION_ICE */


/* Begin CONST: LOCATION_RELAY */


/* End CONST: LOCATION_RELAY */


/* Begin CONST: LOCATION_LOCAL6 */


/* End CONST: LOCATION_LOCAL6 */


/* Begin CONST: LOCATION_ICE6 */


/* End CONST: LOCATION_ICE6 */


/* Begin CONST: LOCATION_RELAY6 */


/* End CONST: LOCATION_RELAY6 */


/* Begin STRUCT: ParticipantLocationBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ParticipantLocationBuiltinTopicData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(13, 2, 4, 16, 239, 47, 232, 19, 82, 196, 234, 72, 252, 84));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ParticipantLocationBuiltinTopicData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"guid",0},{"location",1},{"change_mask",2},{"local_addr",3},{"local_timestamp",4},{"ice_addr",5},{"ice_timestamp",6},{"relay_addr",7},{"relay_timestamp",8},{"local6_addr",9},{"local6_timestamp",10},{"ice6_addr",11},{"ice6_timestamp",12},{"relay6_addr",13},{"relay6_timestamp",14},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.guid, 16)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.location)) return false;
      break;
    }
    case 2: {
      if (!value_reader.read_uint32(value.change_mask)) return false;
      break;
    }
    case 3: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.local_addr = x.c_str();
      }
      break;
    }
    case 4: {
      if (!vread(value_reader, value.local_timestamp)) return false;
      break;
    }
    case 5: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.ice_addr = x.c_str();
      }
      break;
    }
    case 6: {
      if (!vread(value_reader, value.ice_timestamp)) return false;
      break;
    }
    case 7: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relay_addr = x.c_str();
      }
      break;
    }
    case 8: {
      if (!vread(value_reader, value.relay_timestamp)) return false;
      break;
    }
    case 9: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.local6_addr = x.c_str();
      }
      break;
    }
    case 10: {
      if (!vread(value_reader, value.local6_timestamp)) return false;
      break;
    }
    case 11: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.ice6_addr = x.c_str();
      }
      break;
    }
    case 12: {
      if (!vread(value_reader, value.ice6_timestamp)) return false;
      break;
    }
    case 13: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relay6_addr = x.c_str();
      }
      break;
    }
    case 14: {
      if (!vread(value_reader, value.relay6_timestamp)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("guid");
  value_writer.begin_array();
  value_writer.write_byte_array (value.guid, 16);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("location");
  value_writer.write_uint32(value.location);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("change_mask");
  value_writer.write_uint32(value.change_mask);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("local_addr");
  value_writer.write_string(value.local_addr);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("local_timestamp");
  vwrite(value_writer, value.local_timestamp);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ice_addr");
  value_writer.write_string(value.ice_addr);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ice_timestamp");
  vwrite(value_writer, value.ice_timestamp);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("relay_addr");
  value_writer.write_string(value.relay_addr);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("relay_timestamp");
  vwrite(value_writer, value.relay_timestamp);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("local6_addr");
  value_writer.write_string(value.local6_addr);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("local6_timestamp");
  vwrite(value_writer, value.local6_timestamp);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ice6_addr");
  value_writer.write_string(value.ice6_addr);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("ice6_timestamp");
  vwrite(value_writer, value.ice6_timestamp);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("relay6_addr");
  value_writer.write_string(value.relay6_addr);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("relay6_timestamp");
  vwrite(value_writer, value.relay6_timestamp);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(stru);
   ::DDS::OctetArray16_forany stru_guid_temp(const_cast< ::DDS::OctetArray16_slice*>(stru.guid));
  set_default(stru_guid_temp);
  stru.location = 0;
  stru.change_mask = 0;
  stru.local_addr = "";
  set_default(stru.local_timestamp);
  stru.ice_addr = "";
  set_default(stru.ice_timestamp);
  stru.relay_addr = "";
  set_default(stru.relay_timestamp);
  stru.local6_addr = "";
  set_default(stru.local6_timestamp);
  stru.ice6_addr = "";
  set_default(stru.ice6_timestamp);
  stru.relay6_addr = "";
  set_default(stru.relay6_timestamp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.guid));
  serialized_size(encoding, size, stru_guid_forany);
  primitive_serialized_size(encoding, size, stru.location);
  primitive_serialized_size(encoding, size, stru.change_mask);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.local_addr.in()) + 1;
  serialized_size(encoding, size, stru.local_timestamp);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.ice_addr.in()) + 1;
  serialized_size(encoding, size, stru.ice_timestamp);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.relay_addr.in()) + 1;
  serialized_size(encoding, size, stru.relay_timestamp);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.local6_addr.in()) + 1;
  serialized_size(encoding, size, stru.local6_timestamp);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.ice6_addr.in()) + 1;
  serialized_size(encoding, size, stru.ice6_timestamp);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.relay6_addr.in()) + 1;
  serialized_size(encoding, size, stru.relay6_timestamp);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.guid));
  return (strm << stru_guid_forany)
    && (strm << stru.location)
    && (strm << stru.change_mask)
    && (strm << stru.local_addr.in())
    && (strm << stru.local_timestamp)
    && (strm << stru.ice_addr.in())
    && (strm << stru.ice_timestamp)
    && (strm << stru.relay_addr.in())
    && (strm << stru.relay_timestamp)
    && (strm << stru.local6_addr.in())
    && (strm << stru.local6_timestamp)
    && (strm << stru.ice6_addr.in())
    && (strm << stru.ice6_timestamp)
    && (strm << stru.relay6_addr.in())
    && (strm << stru.relay6_timestamp);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.guid));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_guid_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.location)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.change_mask)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.local_addr.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.local_timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ice_addr.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ice_timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.relay_addr.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.relay_timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.local6_addr.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.local6_timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ice6_addr.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.ice6_timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.relay6_addr.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.relay6_timestamp)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  serialized_size(encoding, size, stru_value_guid_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  return (strm << stru_value_guid_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guid_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  serialized_size(encoding, size, stru_value_guid_forany);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  return (strm << stru_value_guid_forany);
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guid_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr ParticipantLocationBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ParticipantLocationBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr ParticipantLocationBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantLocationBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ParticipantLocationBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantLocationBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ParticipantLocationBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ParticipantLocationBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ParticipantLocationBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool ParticipantLocationBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* ParticipantLocationBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void ParticipantLocationBuiltinTopicDataTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& ParticipantLocationBuiltinTopicDataTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_ParticipantLocationBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeMap& ParticipantLocationBuiltinTopicDataTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_ParticipantLocationBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& ParticipantLocationBuiltinTopicDataTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& ParticipantLocationBuiltinTopicDataTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility ParticipantLocationBuiltinTopicDataTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

ParticipantLocationBuiltinTopicDataTypeSupport::_ptr_type ParticipantLocationBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData> : MetaStruct {
  typedef  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "guid[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[12]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[13]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[14]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[15]")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("guid", 0),
      std::make_pair("location", 1),
      std::make_pair("change_mask", 2),
      std::make_pair("local_addr", 3),
      std::make_pair("local_timestamp", 4),
      std::make_pair("ice_addr", 5),
      std::make_pair("ice_timestamp", 6),
      std::make_pair("relay_addr", 7),
      std::make_pair("relay_timestamp", 8),
      std::make_pair("local6_addr", 9),
      std::make_pair("local6_timestamp", 10),
      std::make_pair("ice6_addr", 11),
      std::make_pair("ice6_timestamp", 12),
      std::make_pair("relay6_addr", 13),
      std::make_pair("relay6_timestamp", 14),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 15);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& typed = *static_cast<const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "location") == 0) {
      return typed.location;
    }
    if (std::strcmp(field, "change_mask") == 0) {
      return typed.change_mask;
    }
    if (std::strcmp(field, "local_addr") == 0) {
      return typed.local_addr.in();
    }
    if (std::strncmp(field, "local_timestamp.", 16) == 0) {
      return getMetaStruct< ::DDS::Time_t>().getValue(&typed.local_timestamp, field + 16);
    }
    if (std::strcmp(field, "ice_addr") == 0) {
      return typed.ice_addr.in();
    }
    if (std::strncmp(field, "ice_timestamp.", 14) == 0) {
      return getMetaStruct< ::DDS::Time_t>().getValue(&typed.ice_timestamp, field + 14);
    }
    if (std::strcmp(field, "relay_addr") == 0) {
      return typed.relay_addr.in();
    }
    if (std::strncmp(field, "relay_timestamp.", 16) == 0) {
      return getMetaStruct< ::DDS::Time_t>().getValue(&typed.relay_timestamp, field + 16);
    }
    if (std::strcmp(field, "local6_addr") == 0) {
      return typed.local6_addr.in();
    }
    if (std::strncmp(field, "local6_timestamp.", 17) == 0) {
      return getMetaStruct< ::DDS::Time_t>().getValue(&typed.local6_timestamp, field + 17);
    }
    if (std::strcmp(field, "ice6_addr") == 0) {
      return typed.ice6_addr.in();
    }
    if (std::strncmp(field, "ice6_timestamp.", 15) == 0) {
      return getMetaStruct< ::DDS::Time_t>().getValue(&typed.ice6_timestamp, field + 15);
    }
    if (std::strcmp(field, "relay6_addr") == 0) {
      return typed.relay6_addr.in();
    }
    if (std::strncmp(field, "relay6_timestamp.", 17) == 0) {
      return getMetaStruct< ::DDS::Time_t>().getValue(&typed.relay6_timestamp, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetArray16_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "location") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'location' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'location' could not be skipped");
      }
    }
    if (base_field == "change_mask") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'change_mask' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'change_mask' could not be skipped");
      }
    }
    if (base_field == "local_addr") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'local_addr' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'local_addr' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'local_addr' contents could not be skipped");
      }
    }
    if (base_field == "local_timestamp") {
      return getMetaStruct< ::DDS::Time_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Time_t*>(0))) {
        throw std::runtime_error("Field 'local_timestamp' could not be skipped");
      }
    }
    if (base_field == "ice_addr") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'ice_addr' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'ice_addr' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'ice_addr' contents could not be skipped");
      }
    }
    if (base_field == "ice_timestamp") {
      return getMetaStruct< ::DDS::Time_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Time_t*>(0))) {
        throw std::runtime_error("Field 'ice_timestamp' could not be skipped");
      }
    }
    if (base_field == "relay_addr") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'relay_addr' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relay_addr' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relay_addr' contents could not be skipped");
      }
    }
    if (base_field == "relay_timestamp") {
      return getMetaStruct< ::DDS::Time_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Time_t*>(0))) {
        throw std::runtime_error("Field 'relay_timestamp' could not be skipped");
      }
    }
    if (base_field == "local6_addr") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'local6_addr' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'local6_addr' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'local6_addr' contents could not be skipped");
      }
    }
    if (base_field == "local6_timestamp") {
      return getMetaStruct< ::DDS::Time_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Time_t*>(0))) {
        throw std::runtime_error("Field 'local6_timestamp' could not be skipped");
      }
    }
    if (base_field == "ice6_addr") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'ice6_addr' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'ice6_addr' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'ice6_addr' contents could not be skipped");
      }
    }
    if (base_field == "ice6_timestamp") {
      return getMetaStruct< ::DDS::Time_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Time_t*>(0))) {
        throw std::runtime_error("Field 'ice6_timestamp' could not be skipped");
      }
    }
    if (base_field == "relay6_addr") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'relay6_addr' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relay6_addr' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relay6_addr' contents could not be skipped");
      }
    }
    if (base_field == "relay6_timestamp") {
      return getMetaStruct< ::DDS::Time_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::Time_t*>(0))) {
        throw std::runtime_error("Field 'relay6_timestamp' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "location") == 0) {
      return make_field_cmp(&T::location, next);
    }
    if (std::strcmp(field, "change_mask") == 0) {
      return make_field_cmp(&T::change_mask, next);
    }
    if (std::strcmp(field, "local_addr") == 0) {
      return make_field_cmp(&T::local_addr, next);
    }
    if (std::strncmp(field, "local_timestamp.", 16) == 0) {
      return make_struct_cmp(&T::local_timestamp, getMetaStruct< ::DDS::Time_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strcmp(field, "ice_addr") == 0) {
      return make_field_cmp(&T::ice_addr, next);
    }
    if (std::strncmp(field, "ice_timestamp.", 14) == 0) {
      return make_struct_cmp(&T::ice_timestamp, getMetaStruct< ::DDS::Time_t>().create_qc_comparator(field + 14), next);
    }
    if (std::strcmp(field, "relay_addr") == 0) {
      return make_field_cmp(&T::relay_addr, next);
    }
    if (std::strncmp(field, "relay_timestamp.", 16) == 0) {
      return make_struct_cmp(&T::relay_timestamp, getMetaStruct< ::DDS::Time_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strcmp(field, "local6_addr") == 0) {
      return make_field_cmp(&T::local6_addr, next);
    }
    if (std::strncmp(field, "local6_timestamp.", 17) == 0) {
      return make_struct_cmp(&T::local6_timestamp, getMetaStruct< ::DDS::Time_t>().create_qc_comparator(field + 17), next);
    }
    if (std::strcmp(field, "ice6_addr") == 0) {
      return make_field_cmp(&T::ice6_addr, next);
    }
    if (std::strncmp(field, "ice6_timestamp.", 15) == 0) {
      return make_struct_cmp(&T::ice6_timestamp, getMetaStruct< ::DDS::Time_t>().create_qc_comparator(field + 15), next);
    }
    if (std::strcmp(field, "relay6_addr") == 0) {
      return make_field_cmp(&T::relay6_addr, next);
    }
    if (std::strncmp(field, "relay6_timestamp.", 17) == 0) {
      return make_struct_cmp(&T::relay6_timestamp, getMetaStruct< ::DDS::Time_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"guid", "location", "change_mask", "local_addr", "local_timestamp", "ice_addr", "ice_timestamp", "relay_addr", "relay_timestamp", "local6_addr", "local6_timestamp", "ice6_addr", "ice6_timestamp", "relay6_addr", "relay6_timestamp", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "guid") == 0) {
      return &static_cast<const T*>(stru)->guid;
    }
    if (std::strcmp(field, "location") == 0) {
      return &static_cast<const T*>(stru)->location;
    }
    if (std::strcmp(field, "change_mask") == 0) {
      return &static_cast<const T*>(stru)->change_mask;
    }
    if (std::strcmp(field, "local_addr") == 0) {
      return &static_cast<const T*>(stru)->local_addr;
    }
    if (std::strcmp(field, "local_timestamp") == 0) {
      return &static_cast<const T*>(stru)->local_timestamp;
    }
    if (std::strcmp(field, "ice_addr") == 0) {
      return &static_cast<const T*>(stru)->ice_addr;
    }
    if (std::strcmp(field, "ice_timestamp") == 0) {
      return &static_cast<const T*>(stru)->ice_timestamp;
    }
    if (std::strcmp(field, "relay_addr") == 0) {
      return &static_cast<const T*>(stru)->relay_addr;
    }
    if (std::strcmp(field, "relay_timestamp") == 0) {
      return &static_cast<const T*>(stru)->relay_timestamp;
    }
    if (std::strcmp(field, "local6_addr") == 0) {
      return &static_cast<const T*>(stru)->local6_addr;
    }
    if (std::strcmp(field, "local6_timestamp") == 0) {
      return &static_cast<const T*>(stru)->local6_timestamp;
    }
    if (std::strcmp(field, "ice6_addr") == 0) {
      return &static_cast<const T*>(stru)->ice6_addr;
    }
    if (std::strcmp(field, "ice6_timestamp") == 0) {
      return &static_cast<const T*>(stru)->ice6_timestamp;
    }
    if (std::strcmp(field, "relay6_addr") == 0) {
      return &static_cast<const T*>(stru)->relay6_addr;
    }
    if (std::strcmp(field, "relay6_timestamp") == 0) {
      return &static_cast<const T*>(stru)->relay6_timestamp;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "guid") == 0) {
       ::DDS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->guid;
      const  ::DDS::OctetArray16* rhsArr = static_cast<const  ::DDS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "location") == 0) {
      static_cast<T*>(lhs)->location = *static_cast<const  ::OpenDDS::DCPS::ParticipantLocation*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "change_mask") == 0) {
      static_cast<T*>(lhs)->change_mask = *static_cast<const  ::OpenDDS::DCPS::ParticipantLocation*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "local_addr") == 0) {
      static_cast<T*>(lhs)->local_addr = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "local_timestamp") == 0) {
      static_cast<T*>(lhs)->local_timestamp = *static_cast<const  ::DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ice_addr") == 0) {
      static_cast<T*>(lhs)->ice_addr = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ice_timestamp") == 0) {
      static_cast<T*>(lhs)->ice_timestamp = *static_cast<const  ::DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relay_addr") == 0) {
      static_cast<T*>(lhs)->relay_addr = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relay_timestamp") == 0) {
      static_cast<T*>(lhs)->relay_timestamp = *static_cast<const  ::DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "local6_addr") == 0) {
      static_cast<T*>(lhs)->local6_addr = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "local6_timestamp") == 0) {
      static_cast<T*>(lhs)->local6_timestamp = *static_cast<const  ::DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ice6_addr") == 0) {
      static_cast<T*>(lhs)->ice6_addr = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ice6_timestamp") == 0) {
      static_cast<T*>(lhs)->ice6_timestamp = *static_cast<const  ::DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relay6_addr") == 0) {
      static_cast<T*>(lhs)->relay6_addr = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relay6_timestamp") == 0) {
      static_cast<T*>(lhs)->relay6_timestamp = *static_cast<const  ::DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "location") == 0) {
      return static_cast<const T*>(lhs)->location == static_cast<const T*>(rhs)->location;
    }
    if (std::strcmp(field, "change_mask") == 0) {
      return static_cast<const T*>(lhs)->change_mask == static_cast<const T*>(rhs)->change_mask;
    }
    if (std::strcmp(field, "local_addr") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->local_addr.in(), static_cast<const T*>(rhs)->local_addr.in());
    }
    if (std::strcmp(field, "ice_addr") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->ice_addr.in(), static_cast<const T*>(rhs)->ice_addr.in());
    }
    if (std::strcmp(field, "relay_addr") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->relay_addr.in(), static_cast<const T*>(rhs)->relay_addr.in());
    }
    if (std::strcmp(field, "local6_addr") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->local6_addr.in(), static_cast<const T*>(rhs)->local6_addr.in());
    }
    if (std::strcmp(field, "ice6_addr") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->ice6_addr.in(), static_cast<const T*>(rhs)->ice6_addr.in());
    }
    if (std::strcmp(field, "relay6_addr") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->relay6_addr.in(), static_cast<const T*>(rhs)->relay6_addr.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantLocationBuiltinTopicData */


/* Begin CONST: RTPS_RELAY_STUN_PROTOCOL */


/* End CONST: RTPS_RELAY_STUN_PROTOCOL */


/* Begin STRUCT: ConnectionRecord */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ConnectionRecord_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(214, 144, 243, 161, 6, 205, 79, 1, 183, 67, 44, 42, 153, 56));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ConnectionRecord_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ConnectionRecord& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"guid",0},{"address",1},{"protocol",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.guid, 16)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    case 1: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.address = x.c_str();
      }
      break;
    }
    case 2: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.protocol = x.c_str();
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ConnectionRecord& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("guid");
  value_writer.begin_array();
  value_writer.write_byte_array (value.guid, 16);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("address");
  value_writer.write_string(value.address);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("protocol");
  value_writer.write_string(value.protocol);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::ConnectionRecord& stru)
{
  ACE_UNUSED_ARG(stru);
   ::DDS::OctetArray16_forany stru_guid_temp(const_cast< ::DDS::OctetArray16_slice*>(stru.guid));
  set_default(stru_guid_temp);
  stru.address = "";
  stru.protocol = "";
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ConnectionRecord& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.guid));
  serialized_size(encoding, size, stru_guid_forany);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.address.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.protocol.in()) + 1;
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ConnectionRecord& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.guid));
  return (strm << stru_guid_forany)
    && (strm << stru.address.in())
    && (strm << stru.protocol.in());
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ConnectionRecord& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.guid));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_guid_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.address.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.protocol.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ConnectionRecord>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  serialized_size(encoding, size, stru_value_guid_forany);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.address.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.protocol.in()) + 1;
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::ConnectionRecord>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  return (strm << stru_value_guid_forany)
    && (strm << stru.value.address.in())
    && (strm << stru.value.protocol.in());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ConnectionRecord>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guid_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.address.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.protocol.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::ConnectionRecord>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  serialized_size(encoding, size, stru_value_guid_forany);
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.address.in()) + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.protocol.in()) + 1;
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::ConnectionRecord>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  return (strm << stru_value_guid_forany)
    && (strm << stru.value.address.in())
    && (strm << stru.value.protocol.in());
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::ConnectionRecord>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_guid_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.guid));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guid_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.address.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.protocol.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr ConnectionRecordTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ConnectionRecord> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr ConnectionRecordTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ConnectionRecord> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ConnectionRecordTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ConnectionRecord> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ConnectionRecord, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ConnectionRecordTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ConnectionRecord>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool ConnectionRecordTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* ConnectionRecordTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void ConnectionRecordTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& ConnectionRecordTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_ConnectionRecord_xtag>();
}

const OpenDDS::XTypes::TypeMap& ConnectionRecordTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_ConnectionRecord_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& ConnectionRecordTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& ConnectionRecordTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility ConnectionRecordTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

ConnectionRecordTypeSupport::_ptr_type ConnectionRecordTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::ConnectionRecord> : MetaStruct {
  typedef  ::OpenDDS::DCPS::ConnectionRecord T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 18; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "guid[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[12]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[13]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[14]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid[15]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "address")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "protocol")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("guid", 0),
      std::make_pair("address", 1),
      std::make_pair("protocol", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ConnectionRecord)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::ConnectionRecord& typed = *static_cast<const  ::OpenDDS::DCPS::ConnectionRecord*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "address") == 0) {
      return typed.address.in();
    }
    if (std::strcmp(field, "protocol") == 0) {
      return typed.protocol.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ConnectionRecord)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetArray16_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "address") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'address' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'address' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'address' contents could not be skipped");
      }
    }
    if (base_field == "protocol") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'protocol' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'protocol' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'protocol' contents could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "address") == 0) {
      return make_field_cmp(&T::address, next);
    }
    if (std::strcmp(field, "protocol") == 0) {
      return make_field_cmp(&T::protocol, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ConnectionRecord)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"guid", "address", "protocol", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "guid") == 0) {
      return &static_cast<const T*>(stru)->guid;
    }
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->address;
    }
    if (std::strcmp(field, "protocol") == 0) {
      return &static_cast<const T*>(stru)->protocol;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ConnectionRecord)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "guid") == 0) {
       ::DDS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->guid;
      const  ::DDS::OctetArray16* rhsArr = static_cast<const  ::DDS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "address") == 0) {
      static_cast<T*>(lhs)->address = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "protocol") == 0) {
      static_cast<T*>(lhs)->protocol = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ConnectionRecord)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "address") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->address.in(), static_cast<const T*>(rhs)->address.in());
    }
    if (std::strcmp(field, "protocol") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->protocol.in(), static_cast<const T*>(rhs)->protocol.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::ConnectionRecord)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ConnectionRecord>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::ConnectionRecord> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ConnectionRecord*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::ConnectionRecord>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ConnectionRecord */


/* Begin STRUCT: InternalThreadBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_InternalThreadBuiltinTopicData_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(85, 71, 97, 115, 146, 44, 133, 142, 164, 43, 138, 32, 131, 181));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_InternalThreadBuiltinTopicData_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"thread_id",0},{"utilization",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.thread_id = x.c_str();
      }
      break;
    }
    case 1: {
      if (!value_reader.read_float64(value.utilization)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("thread_id");
  value_writer.write_string(value.thread_id);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("utilization");
  value_writer.write_float64(value.utilization);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.thread_id = "";
  stru.utilization = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.thread_id.in()) + 1;
  primitive_serialized_size(encoding, size, stru.utilization);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.thread_id.in())
    && (strm << stru.utilization);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.thread_id.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.utilization)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.thread_id.in()) + 1;
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.thread_id.in());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.thread_id.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.thread_id.in()) + 1;
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.thread_id.in());
}

bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.thread_id.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr InternalThreadBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<InternalThreadBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr InternalThreadBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<InternalThreadBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr InternalThreadBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<InternalThreadBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<InternalThreadBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& InternalThreadBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<InternalThreadBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool InternalThreadBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* InternalThreadBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void InternalThreadBuiltinTopicDataTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& InternalThreadBuiltinTopicDataTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::OpenDDS_DCPS_InternalThreadBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeMap& InternalThreadBuiltinTopicDataTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::OpenDDS_DCPS_InternalThreadBuiltinTopicData_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& InternalThreadBuiltinTopicDataTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& InternalThreadBuiltinTopicDataTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility InternalThreadBuiltinTopicDataTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

InternalThreadBuiltinTopicDataTypeSupport::_ptr_type InternalThreadBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData> : MetaStruct {
  typedef  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 1; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "thread_id")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("thread_id", 0),
      std::make_pair("utilization", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::InternalThreadBuiltinTopicData)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& typed = *static_cast<const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "thread_id") == 0) {
      return typed.thread_id.in();
    }
    if (std::strcmp(field, "utilization") == 0) {
      return typed.utilization;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::InternalThreadBuiltinTopicData)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "thread_id") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'thread_id' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'thread_id' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'thread_id' contents could not be skipped");
      }
    }
    if (base_field == "utilization") {
      ACE_CDR::Double val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'utilization' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'utilization' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "thread_id") == 0) {
      return make_field_cmp(&T::thread_id, next);
    }
    if (std::strcmp(field, "utilization") == 0) {
      return make_field_cmp(&T::utilization, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::InternalThreadBuiltinTopicData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"thread_id", "utilization", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "thread_id") == 0) {
      return &static_cast<const T*>(stru)->thread_id;
    }
    if (std::strcmp(field, "utilization") == 0) {
      return &static_cast<const T*>(stru)->utilization;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::InternalThreadBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "thread_id") == 0) {
      static_cast<T*>(lhs)->thread_id = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "utilization") == 0) {
      static_cast<T*>(lhs)->utilization = *static_cast<const  ::CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::InternalThreadBuiltinTopicData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "thread_id") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->thread_id.in(), static_cast<const T*>(rhs)->thread_id.in());
    }
    if (std::strcmp(field, "utilization") == 0) {
      return static_cast<const T*>(lhs)->utilization == static_cast<const T*>(rhs)->utilization;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::InternalThreadBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InternalThreadBuiltinTopicData */


/* Begin CONST: LOCATOR_KIND_INVALID */


/* End CONST: LOCATOR_KIND_INVALID */


/* Begin CONST: LOCATOR_KIND_RESERVED */


/* End CONST: LOCATOR_KIND_RESERVED */


/* Begin CONST: LOCATOR_KIND_UDPv4 */


/* End CONST: LOCATOR_KIND_UDPv4 */


/* Begin CONST: LOCATOR_KIND_UDPv6 */


/* End CONST: LOCATOR_KIND_UDPv6 */


/* Begin CONST: LOCATOR_PORT_INVALID */


/* End CONST: LOCATOR_PORT_INVALID */


/* Begin STRUCT: Locator_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_Locator_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_Locator_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::Locator_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"kind",0},{"port",1},{"address",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.kind)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.port)) return false;
      break;
    }
    case 2: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.address, 16)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::Locator_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("kind");
  value_writer.write_int32(value.kind);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("port");
  value_writer.write_uint32(value.port);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("address");
  value_writer.begin_array();
  value_writer.write_byte_array (value.address, 16);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::Locator_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.kind = 0;
  stru.port = 0;
   ::DDS::OctetArray16_forany stru_address_temp(const_cast< ::DDS::OctetArray16_slice*>(stru.address));
  set_default(stru_address_temp);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::Locator_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_address_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.address));
  primitive_serialized_size(encoding, size, stru.kind);
  primitive_serialized_size(encoding, size, stru.port);
  serialized_size(encoding, size, stru_address_forany);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::Locator_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_address_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.address));
  return (strm << stru.kind)
    && (strm << stru.port)
    && (strm << stru_address_forany);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::Locator_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_address_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.address));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.port)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_address_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::Locator_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
   ::DDS::OctetArray16_forany stru_value_address_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.address));
  primitive_serialized_size(encoding, size, stru.value.kind);
  primitive_serialized_size(encoding, size, stru.value.port);
  serialized_size(encoding, size, stru_value_address_forany);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::Locator_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
   ::DDS::OctetArray16_forany stru_value_address_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.address));
  return (strm << stru.value.kind)
    && (strm << stru.value.port)
    && (strm << stru_value_address_forany);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::Locator_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

   ::DDS::OctetArray16_forany stru_value_address_forany(const_cast< ::DDS::OctetArray16_slice*>(stru.value.address));
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.port)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_address_forany)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::Locator_t> : MetaStruct {
  typedef  ::OpenDDS::DCPS::Locator_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("kind", 0),
      std::make_pair("port", 1),
      std::make_pair("address", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Locator_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::Locator_t& typed = *static_cast<const  ::OpenDDS::DCPS::Locator_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return typed.kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return typed.port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Locator_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "kind") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (base_field == "port") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'port' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'port' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::DDS::OctetArray16_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strcmp(field, "port") == 0) {
      return make_field_cmp(&T::port, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Locator_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "port", "address", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return &static_cast<const T*>(stru)->port;
    }
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->address;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Locator_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "port") == 0) {
      static_cast<T*>(lhs)->port = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "address") == 0) {
       ::DDS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->address;
      const  ::DDS::OctetArray16* rhsArr = static_cast<const  ::DDS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Locator_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return static_cast<const T*>(lhs)->port == static_cast<const T*>(rhs)->port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::Locator_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::Locator_t>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::Locator_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::Locator_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::Locator_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Locator_t */


/* Begin TYPEDEF: LocatorSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_LocatorSeq_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(3, 25, 45, 83, 244, 194, 80, 75, 84, 30, 189, 230, 238, 219));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_LocatorSeq_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::LocatorSeq& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::LocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::LocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::LocatorSeq tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::LocatorSeq tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::LocatorSeq*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::Locator_t*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LocatorSeq */


/* Begin TYPEDEF: MessageCountKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_MessageCountKind_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_MessageCountKind_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: MessageCountKind */


/* Begin CONST: MCK_RTPS */


/* End CONST: MCK_RTPS */


/* Begin CONST: MCK_STUN */


/* End CONST: MCK_STUN */


/* Begin STRUCT: MessageCount */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_MessageCount_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(213, 134, 121, 243, 188, 156, 21, 81, 85, 152, 159, 103, 43, 209));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_MessageCount_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::MessageCount& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"locator",0},{"kind",1},{"relay",2},{"send_count",3},{"send_bytes",4},{"send_fail_count",5},{"send_fail_bytes",6},{"recv_count",7},{"recv_bytes",8},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.locator)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_int32(value.kind)) return false;
      break;
    }
    case 2: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.relay = bx;
      }
      break;
    }
    case 3: {
      if (!value_reader.read_uint32(value.send_count)) return false;
      break;
    }
    case 4: {
      if (!value_reader.read_uint32(value.send_bytes)) return false;
      break;
    }
    case 5: {
      if (!value_reader.read_uint32(value.send_fail_count)) return false;
      break;
    }
    case 6: {
      if (!value_reader.read_uint32(value.send_fail_bytes)) return false;
      break;
    }
    case 7: {
      if (!value_reader.read_uint32(value.recv_count)) return false;
      break;
    }
    case 8: {
      if (!value_reader.read_uint32(value.recv_bytes)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::MessageCount& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("locator");
  vwrite(value_writer, value.locator);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("kind");
  value_writer.write_int32(value.kind);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("relay");
  value_writer.write_boolean(value.relay);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("send_count");
  value_writer.write_uint32(value.send_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("send_bytes");
  value_writer.write_uint32(value.send_bytes);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("send_fail_count");
  value_writer.write_uint32(value.send_fail_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("send_fail_bytes");
  value_writer.write_uint32(value.send_fail_bytes);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("recv_count");
  value_writer.write_uint32(value.recv_count);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("recv_bytes");
  value_writer.write_uint32(value.recv_bytes);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::MessageCount& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.locator);
  stru.kind = 0;
  stru.relay = 0;
  stru.send_count = 0;
  stru.send_bytes = 0;
  stru.send_fail_count = 0;
  stru.send_fail_bytes = 0;
  stru.recv_count = 0;
  stru.recv_bytes = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::MessageCount& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.locator);
  primitive_serialized_size(encoding, size, stru.kind);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.relay));
  primitive_serialized_size(encoding, size, stru.send_count);
  primitive_serialized_size(encoding, size, stru.send_bytes);
  primitive_serialized_size(encoding, size, stru.send_fail_count);
  primitive_serialized_size(encoding, size, stru.send_fail_bytes);
  primitive_serialized_size(encoding, size, stru.recv_count);
  primitive_serialized_size(encoding, size, stru.recv_bytes);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::MessageCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.locator)
    && (strm << stru.kind)
    && (strm << ACE_OutputCDR::from_boolean(stru.relay))
    && (strm << stru.send_count)
    && (strm << stru.send_bytes)
    && (strm << stru.send_fail_count)
    && (strm << stru.send_fail_bytes)
    && (strm << stru.recv_count)
    && (strm << stru.recv_bytes);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::MessageCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.locator)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.relay))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.send_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.send_bytes)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.send_fail_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.send_fail_bytes)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.recv_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.recv_bytes)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::MessageCount>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.value.locator);
  primitive_serialized_size(encoding, size, stru.value.kind);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::MessageCount>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.locator)
    && (strm << stru.value.kind);
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::MessageCount>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.locator)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.kind)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::MessageCount> : MetaStruct {
  typedef  ::OpenDDS::DCPS::MessageCount T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("locator", 0),
      std::make_pair("kind", 1),
      std::make_pair("relay", 2),
      std::make_pair("send_count", 3),
      std::make_pair("send_bytes", 4),
      std::make_pair("send_fail_count", 5),
      std::make_pair("send_fail_bytes", 6),
      std::make_pair("recv_count", 7),
      std::make_pair("recv_bytes", 8),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 9);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MessageCount)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::MessageCount& typed = *static_cast<const  ::OpenDDS::DCPS::MessageCount*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "locator.", 8) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::Locator_t>().getValue(&typed.locator, field + 8);
    }
    if (std::strcmp(field, "kind") == 0) {
      return typed.kind;
    }
    if (std::strcmp(field, "relay") == 0) {
      return typed.relay;
    }
    if (std::strcmp(field, "send_count") == 0) {
      return typed.send_count;
    }
    if (std::strcmp(field, "send_bytes") == 0) {
      return typed.send_bytes;
    }
    if (std::strcmp(field, "send_fail_count") == 0) {
      return typed.send_fail_count;
    }
    if (std::strcmp(field, "send_fail_bytes") == 0) {
      return typed.send_fail_bytes;
    }
    if (std::strcmp(field, "recv_count") == 0) {
      return typed.recv_count;
    }
    if (std::strcmp(field, "recv_bytes") == 0) {
      return typed.recv_bytes;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MessageCount)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "locator") {
      return getMetaStruct< ::OpenDDS::DCPS::Locator_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::Locator_t*>(0))) {
        throw std::runtime_error("Field 'locator' could not be skipped");
      }
    }
    if (base_field == "kind") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (base_field == "relay") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'relay' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'relay' could not be skipped");
      }
    }
    if (base_field == "send_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'send_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'send_count' could not be skipped");
      }
    }
    if (base_field == "send_bytes") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'send_bytes' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'send_bytes' could not be skipped");
      }
    }
    if (base_field == "send_fail_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'send_fail_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'send_fail_count' could not be skipped");
      }
    }
    if (base_field == "send_fail_bytes") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'send_fail_bytes' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'send_fail_bytes' could not be skipped");
      }
    }
    if (base_field == "recv_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'recv_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'recv_count' could not be skipped");
      }
    }
    if (base_field == "recv_bytes") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'recv_bytes' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'recv_bytes' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "locator.", 8) == 0) {
      return make_struct_cmp(&T::locator, getMetaStruct< ::OpenDDS::DCPS::Locator_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strcmp(field, "relay") == 0) {
      return make_field_cmp(&T::relay, next);
    }
    if (std::strcmp(field, "send_count") == 0) {
      return make_field_cmp(&T::send_count, next);
    }
    if (std::strcmp(field, "send_bytes") == 0) {
      return make_field_cmp(&T::send_bytes, next);
    }
    if (std::strcmp(field, "send_fail_count") == 0) {
      return make_field_cmp(&T::send_fail_count, next);
    }
    if (std::strcmp(field, "send_fail_bytes") == 0) {
      return make_field_cmp(&T::send_fail_bytes, next);
    }
    if (std::strcmp(field, "recv_count") == 0) {
      return make_field_cmp(&T::recv_count, next);
    }
    if (std::strcmp(field, "recv_bytes") == 0) {
      return make_field_cmp(&T::recv_bytes, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MessageCount)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"locator", "kind", "relay", "send_count", "send_bytes", "send_fail_count", "send_fail_bytes", "recv_count", "recv_bytes", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "locator") == 0) {
      return &static_cast<const T*>(stru)->locator;
    }
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "relay") == 0) {
      return &static_cast<const T*>(stru)->relay;
    }
    if (std::strcmp(field, "send_count") == 0) {
      return &static_cast<const T*>(stru)->send_count;
    }
    if (std::strcmp(field, "send_bytes") == 0) {
      return &static_cast<const T*>(stru)->send_bytes;
    }
    if (std::strcmp(field, "send_fail_count") == 0) {
      return &static_cast<const T*>(stru)->send_fail_count;
    }
    if (std::strcmp(field, "send_fail_bytes") == 0) {
      return &static_cast<const T*>(stru)->send_fail_bytes;
    }
    if (std::strcmp(field, "recv_count") == 0) {
      return &static_cast<const T*>(stru)->recv_count;
    }
    if (std::strcmp(field, "recv_bytes") == 0) {
      return &static_cast<const T*>(stru)->recv_bytes;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MessageCount)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "locator") == 0) {
      static_cast<T*>(lhs)->locator = *static_cast<const  ::OpenDDS::DCPS::Locator_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const  ::OpenDDS::DCPS::MessageCountKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relay") == 0) {
      static_cast<T*>(lhs)->relay = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "send_count") == 0) {
      static_cast<T*>(lhs)->send_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "send_bytes") == 0) {
      static_cast<T*>(lhs)->send_bytes = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "send_fail_count") == 0) {
      static_cast<T*>(lhs)->send_fail_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "send_fail_bytes") == 0) {
      static_cast<T*>(lhs)->send_fail_bytes = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "recv_count") == 0) {
      static_cast<T*>(lhs)->recv_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "recv_bytes") == 0) {
      static_cast<T*>(lhs)->recv_bytes = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MessageCount)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    if (std::strcmp(field, "relay") == 0) {
      return static_cast<const T*>(lhs)->relay == static_cast<const T*>(rhs)->relay;
    }
    if (std::strcmp(field, "send_count") == 0) {
      return static_cast<const T*>(lhs)->send_count == static_cast<const T*>(rhs)->send_count;
    }
    if (std::strcmp(field, "send_bytes") == 0) {
      return static_cast<const T*>(lhs)->send_bytes == static_cast<const T*>(rhs)->send_bytes;
    }
    if (std::strcmp(field, "send_fail_count") == 0) {
      return static_cast<const T*>(lhs)->send_fail_count == static_cast<const T*>(rhs)->send_fail_count;
    }
    if (std::strcmp(field, "send_fail_bytes") == 0) {
      return static_cast<const T*>(lhs)->send_fail_bytes == static_cast<const T*>(rhs)->send_fail_bytes;
    }
    if (std::strcmp(field, "recv_count") == 0) {
      return static_cast<const T*>(lhs)->recv_count == static_cast<const T*>(rhs)->recv_count;
    }
    if (std::strcmp(field, "recv_bytes") == 0) {
      return static_cast<const T*>(lhs)->recv_bytes == static_cast<const T*>(rhs)->recv_bytes;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::MessageCount)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::MessageCount>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::MessageCount> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::MessageCount*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::MessageCount>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: MessageCount */


/* Begin STRUCT: GuidCount */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GuidCount_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 252, 4, 152, 204, 116, 8, 4, 14, 139, 123, 245, 142, 147));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GuidCount_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::GuidCount& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"guid",0},{"count",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!vread(value_reader, value.guid)) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.count)) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::GuidCount& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("guid");
  vwrite(value_writer, value.guid);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("count");
  value_writer.write_uint32(value.count);
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::GuidCount& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.guid);
  stru.count = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GuidCount& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, stru.guid);
  primitive_serialized_size(encoding, size, stru.count);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GuidCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.guid)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GuidCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.guid)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::GuidCount>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.guid));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::GuidCount>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GUID_t>(stru.value.guid));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::GuidCount>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  NestedKeyOnly< ::OpenDDS::DCPS::GUID_t> stru_value_guid_nested_key_only(stru.value.guid);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guid_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::GuidCount> : MetaStruct {
  typedef  ::OpenDDS::DCPS::GuidCount T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("guid", 0),
      std::make_pair("count", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GuidCount)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::GuidCount& typed = *static_cast<const  ::OpenDDS::DCPS::GuidCount*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "guid.", 5) == 0) {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(&typed.guid, field + 5);
    }
    if (std::strcmp(field, "count") == 0) {
      return typed.count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GuidCount)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "guid") {
      return getMetaStruct< ::OpenDDS::DCPS::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'guid' could not be skipped");
      }
    }
    if (base_field == "count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "guid.", 5) == 0) {
      return make_struct_cmp(&T::guid, getMetaStruct< ::OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 5), next);
    }
    if (std::strcmp(field, "count") == 0) {
      return make_field_cmp(&T::count, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GuidCount)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"guid", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "guid") == 0) {
      return &static_cast<const T*>(stru)->guid;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GuidCount)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "guid") == 0) {
      static_cast<T*>(lhs)->guid = *static_cast<const  ::OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GuidCount)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "count") == 0) {
      return static_cast<const T*>(lhs)->count == static_cast<const T*>(rhs)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::GuidCount)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::GuidCount>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::GuidCount> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GuidCount*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::GuidCount>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GuidCount */


/* Begin TYPEDEF: MessageCountSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_MessageCountSequence_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 132, 251, 41, 232, 103, 164, 105, 240, 245, 175, 239, 26, 202));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_MessageCountSequence_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::MessageCountSequence& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::MessageCountSequence& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::MessageCountSequence& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::MessageCountSequence tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::MessageCountSequence tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::MessageCountSequence>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::MessageCount>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::MessageCountSequence>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::MessageCount>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::MessageCountSequence>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::MessageCount> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::MessageCountSequence tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::MessageCountSequence tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::MessageCountSequence*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::MessageCount*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: MessageCountSequence */


/* Begin TYPEDEF: GuidCountSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GuidCountSequence_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(93, 240, 214, 130, 253, 104, 107, 219, 208, 252, 99, 248, 228, 158));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GuidCountSequence_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GuidCountSequence& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GuidCountSequence& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GuidCountSequence& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::GuidCountSequence tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::GuidCountSequence tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::GuidCountSequence>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::GuidCount>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::GuidCountSequence>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::GuidCount>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::GuidCountSequence>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::GuidCount> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::GuidCountSequence tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::GuidCountSequence tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GuidCountSequence*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::GuidCount*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GuidCountSequence */


/* Begin STRUCT: TransportStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportStatistics_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(176, 92, 89, 14, 248, 48, 94, 151, 138, 130, 149, 79, 101, 240));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportStatistics_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::TransportStatistics& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"transport",0},{"message_count",1},{"writer_resend_count",2},{"reader_nack_count",3},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.transport = x.c_str();
      }
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.message_count);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.message_count[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 2: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.writer_resend_count);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.writer_resend_count[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 3: {
      if (!value_reader.begin_sequence()) return false;
      for (unsigned int i = 0; value_reader.elements_remaining(); ++i) {
        OpenDDS::DCPS::grow(value.reader_nack_count);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.reader_nack_count[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::TransportStatistics& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("transport");
  value_writer.write_string(value.transport);
  value_writer.end_struct_member();
  value_writer.begin_struct_member("message_count");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.message_count.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.message_count[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("writer_resend_count");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.writer_resend_count.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.writer_resend_count[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("reader_nack_count");
  value_writer.begin_sequence();
  for (::CORBA::ULong i = 0; i != value.reader_nack_count.length(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.reader_nack_count[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::OpenDDS::DCPS::TransportStatistics& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.transport = "";
  stru.message_count.length(0);
  stru.writer_resend_count.length(0);
  stru.reader_nack_count.length(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::TransportStatistics& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.transport.in()) + 1;
  serialized_size(encoding, size, stru.message_count);
  serialized_size(encoding, size, stru.writer_resend_count);
  serialized_size(encoding, size, stru.reader_nack_count);
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::TransportStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.transport.in())
    && (strm << stru.message_count)
    && (strm << stru.writer_resend_count)
    && (strm << stru.reader_nack_count);
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TransportStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.transport.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.message_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.writer_resend_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.reader_nack_count)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportStatistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += ACE_OS::strlen(stru.value.transport.in()) + 1;
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.transport.in());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::TransportStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.transport.out())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::OpenDDS::DCPS::TransportStatistics> : MetaStruct {
  typedef  ::OpenDDS::DCPS::TransportStatistics T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("transport", 0),
      std::make_pair("message_count", 1),
      std::make_pair("writer_resend_count", 2),
      std::make_pair("reader_nack_count", 3),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 4);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportStatistics)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::OpenDDS::DCPS::TransportStatistics& typed = *static_cast<const  ::OpenDDS::DCPS::TransportStatistics*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "transport") == 0) {
      return typed.transport.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportStatistics)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "transport") {
      TAO::String_Manager val;
      if (!(strm >> val.out())) {
        throw std::runtime_error("Field 'transport' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'transport' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'transport' contents could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::MessageCountSequence*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GuidCountSequence*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast< ::OpenDDS::DCPS::GuidCountSequence*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "transport") == 0) {
      return make_field_cmp(&T::transport, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportStatistics)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"transport", "message_count", "writer_resend_count", "reader_nack_count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "transport") == 0) {
      return &static_cast<const T*>(stru)->transport;
    }
    if (std::strcmp(field, "message_count") == 0) {
      return &static_cast<const T*>(stru)->message_count;
    }
    if (std::strcmp(field, "writer_resend_count") == 0) {
      return &static_cast<const T*>(stru)->writer_resend_count;
    }
    if (std::strcmp(field, "reader_nack_count") == 0) {
      return &static_cast<const T*>(stru)->reader_nack_count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportStatistics)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "transport") == 0) {
      static_cast<T*>(lhs)->transport = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "message_count") == 0) {
      static_cast<T*>(lhs)->message_count = *static_cast<const  ::OpenDDS::DCPS::MessageCountSequence*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writer_resend_count") == 0) {
      static_cast<T*>(lhs)->writer_resend_count = *static_cast<const  ::OpenDDS::DCPS::GuidCountSequence*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reader_nack_count") == 0) {
      static_cast<T*>(lhs)->reader_nack_count = *static_cast<const  ::OpenDDS::DCPS::GuidCountSequence*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportStatistics)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "transport") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->transport.in(), static_cast<const T*>(rhs)->transport.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::OpenDDS::DCPS::TransportStatistics)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::TransportStatistics>()
{
  static MetaStructImpl< ::OpenDDS::DCPS::TransportStatistics> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TransportStatistics*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::OpenDDS::DCPS::TransportStatistics>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportStatistics */


/* Begin TYPEDEF: TransportStatisticsSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportStatisticsSequence_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 69, 13, 22, 117, 187, 248, 214, 221, 230, 93, 57, 68, 116));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportStatisticsSequence_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::TransportStatisticsSequence& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    serialized_size(encoding, size, seq[i]);
  }
}

bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::TransportStatisticsSequence& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TransportStatisticsSequence& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> seq[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::TransportStatisticsSequence tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::TransportStatisticsSequence tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportStatisticsSequence>& seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if (seq.value.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.value.length(); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::OpenDDS::DCPS::TransportStatistics>(seq.value[i]));
  }
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportStatisticsSequence>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = seq.value.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::OpenDDS::DCPS::TransportStatistics>(seq.value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::TransportStatisticsSequence>& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  seq.value.length(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::OpenDDS::DCPS::TransportStatistics> seq_value_i_nested_key_only(seq.value[i]);
     if (!(strm >> seq_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::OpenDDS::DCPS::TransportStatisticsSequence tempvar;
        tempvar.length(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::OpenDDS::DCPS::TransportStatisticsSequence tempvar;
      tempvar.length(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TransportStatisticsSequence*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::OpenDDS::DCPS::TransportStatistics*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: TransportStatisticsSequence */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

namespace {
XTypes::TypeObject minimal_to0()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100)))))))));
}

XTypes::TypeObject minimal_to1()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(3), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to2()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))), XTypes::MinimalMemberDetail(30, 12, 165, 177))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(213, 24, 157, 224))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))), XTypes::MinimalMemberDetail(21, 170, 22, 218))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(166, 10, 214, 8))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(143, 57, 179, 91))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(200, 233, 178, 101))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(216, 121, 55, 44))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(16, 39, 183, 238))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(37, 108, 110, 159))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(9, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(226, 190, 113, 181))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(10, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(97, 177, 238, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(11, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(57, 191, 253, 100))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(12, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(253, 233, 225, 120))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(13, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(95, 187, 71, 139))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(14, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(169, 187, 211, 30))))));
}

XTypes::TypeObject minimal_to3()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(176, 92, 89, 14, 248, 48, 94, 151, 138, 130, 149, 79, 101, 240)))))))));
}

XTypes::TypeObject minimal_to4()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(16), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to5()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(116, 69, 156, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 4, 100, 213))))));
}

XTypes::TypeObject minimal_to6()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(227, 70, 76, 151))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_FLOAT64)), XTypes::MinimalMemberDetail(105, 111, 142, 68))))));
}

XTypes::TypeObject minimal_to7()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 252, 4, 152, 204, 116, 8, 4, 14, 139, 123, 245, 142, 147)))))))));
}

XTypes::TypeObject minimal_to8()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_UINT32))))));
}

XTypes::TypeObject minimal_to9()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(213, 134, 121, 243, 188, 156, 21, 81, 85, 152, 159, 103, 43, 209)))))))));
}

XTypes::TypeObject minimal_to10()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(30, 12, 165, 177))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 148, 42, 4))))));
}

XTypes::TypeObject minimal_to11()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TK_INT32))))));
}

XTypes::TypeObject minimal_to12()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(177, 178, 109, 157))))));
}

XTypes::TypeObject minimal_to13()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(12), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to14()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(123, 51, 75, 114))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 132, 251, 41, 232, 103, 164, 105, 240, 245, 175, 239, 26, 202))), XTypes::MinimalMemberDetail(63, 146, 89, 95))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(93, 240, 214, 130, 253, 104, 107, 219, 208, 252, 99, 248, 228, 158))), XTypes::MinimalMemberDetail(204, 25, 9, 83))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(93, 240, 214, 130, 253, 104, 107, 219, 208, 252, 99, 248, 228, 158))), XTypes::MinimalMemberDetail(90, 14, 0, 34))))));
}

XTypes::TypeObject minimal_to15()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(144, 21, 85, 251))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))), XTypes::MinimalMemberDetail(136, 77, 152, 4))))));
}

XTypes::TypeObject minimal_to16()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100))), XTypes::MinimalMemberDetail(171, 30, 7, 248))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))), XTypes::MinimalMemberDetail(217, 57, 170, 247))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(49, 116, 124, 184))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(3, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(245, 54, 175, 173))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(4, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 92, 95, 53))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(5, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(90, 50, 165, 250))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(79, 119, 215, 70))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(7, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(45, 119, 25, 208))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(8, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(171, 241, 178, 172))))));
}

XTypes::TypeObject minimal_to17()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))), XTypes::MinimalMemberDetail(30, 12, 165, 177))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(136, 77, 152, 4))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(129, 120, 139, 160))))));
}

XTypes::TypeObject minimal_to18()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))), XTypes::MinimalMemberDetail(87, 2, 74, 74))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(61, 5, 144, 205))))));
}

XTypes::TypeMap get_minimal_type_map_private()
{
  XTypes::TypeMap tm;
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(3, 25, 45, 83, 244, 194, 80, 75, 84, 30, 189, 230, 238, 219))] = minimal_to0();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))] = minimal_to1();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(13, 2, 4, 16, 239, 47, 232, 19, 82, 196, 234, 72, 252, 84))] = minimal_to2();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(29, 69, 13, 22, 117, 187, 248, 214, 221, 230, 93, 57, 68, 116))] = minimal_to3();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(67, 245, 58, 43, 227, 91, 67, 44, 199, 53, 233, 67, 26, 137))] = minimal_to4();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))] = minimal_to5();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(85, 71, 97, 115, 146, 44, 133, 142, 164, 43, 138, 32, 131, 181))] = minimal_to6();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(93, 240, 214, 130, 253, 104, 107, 219, 208, 252, 99, 248, 228, 158))] = minimal_to7();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 1, 210, 12, 62, 253, 251, 125, 199, 163, 108, 154, 121, 207))] = minimal_to8();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(107, 132, 251, 41, 232, 103, 164, 105, 240, 245, 175, 239, 26, 202))] = minimal_to9();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(137, 252, 4, 152, 204, 116, 8, 4, 14, 139, 123, 245, 142, 147))] = minimal_to10();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(142, 169, 127, 69, 41, 166, 192, 124, 184, 9, 110, 86, 123, 211))] = minimal_to11();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))] = minimal_to12();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))] = minimal_to13();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(176, 92, 89, 14, 248, 48, 94, 151, 138, 130, 149, 79, 101, 240))] = minimal_to14();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(178, 71, 137, 64, 115, 111, 63, 25, 161, 112, 94, 154, 219, 100))] = minimal_to15();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(213, 134, 121, 243, 188, 156, 21, 81, 85, 152, 159, 103, 43, 209))] = minimal_to16();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(214, 144, 243, 161, 6, 205, 79, 1, 183, 67, 44, 42, 153, 56))] = minimal_to17();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))] = minimal_to18();
  return tm;
}

}

const XTypes::TypeMap& get_minimal_type_map()
{
  static XTypes::TypeMap tm;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), tm);
  if (tm.empty()) {
    tm = get_minimal_type_map_private();
  }
  return tm;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

