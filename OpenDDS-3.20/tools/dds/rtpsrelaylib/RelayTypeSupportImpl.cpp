/* Generated by ..\..\..\bin\opendds_idl version 3.20.0 (ACE version 6.2a_p23) running on input file Relay.idl */
#include "RelayTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/XTypes/TypeObject.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: RtpsRelay */



/* Begin CONST: HSPDP */


/* End CONST: HSPDP */


/* Begin CONST: HSEDP */


/* End CONST: HSEDP */


/* Begin CONST: HDATA */


/* End CONST: HDATA */


/* Begin CONST: VSPDP */


/* End CONST: VSPDP */


/* Begin CONST: VSEDP */


/* End CONST: VSEDP */


/* Begin CONST: VDATA */


/* End CONST: VDATA */


/* Begin TYPEDEF: GuidPrefix_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_GuidPrefix_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45));
  }
  return ti;
}

static const XTypes::TypeMap& get_minimal_type_map();
template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_GuidPrefix_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default(IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
    (*arr.val_)[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const  ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size_octet(encoding, size, 12);
}

bool operator<<(Serializer& strm, const IDL::DistinctType<const  ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_octet_array((*arr.val_).data(), 12);
}

bool operator>>(Serializer& strm, IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_octet_array((*arr.val_).data(), 12);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag>*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(12, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_EntityKey_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_EntityKey_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default(IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> arr)
{
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    (*arr.val_)[i0] = 0;
  }
}

void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const  ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> arr)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(arr);
  primitive_serialized_size_octet(encoding, size, 3);
}

bool operator<<(Serializer& strm, const IDL::DistinctType<const  ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.write_octet_array((*arr.val_).data(), 3);
}

bool operator>>(Serializer& strm, IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return strm.read_octet_array((*arr.val_).data(), 3);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag>*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  return ser.skip(3, 1);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_EntityId_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_EntityId_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::EntityId_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"entityKey",0},{"entityKind",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.entityKey().data(), 3)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_byte(value.entityKind())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::EntityId_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("entityKey");
  value_writer.begin_array();
  value_writer.write_byte_array (value.entityKey().data(), 3);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("entityKind");
  value_writer.write_byte(value.entityKind());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::EntityId_t& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag>(stru.entityKey()));
  stru.entityKind() = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::EntityId_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag>(stru.entityKey()));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.entityKind()));
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::EntityId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm << IDL::DistinctType<const  ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag>(stru.entityKey()))
    && (strm << ACE_OutputCDR::from_octet(stru.entityKind()));
}

bool operator>>(Serializer& strm,  ::RtpsRelay::EntityId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> stru_entityKey_distinct_type(stru.entityKey());
  return (strm >> stru_entityKey_distinct_type)
    && (strm >> ACE_InputCDR::to_octet(stru.entityKind()));
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::EntityId_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag>(stru.value.entityKey()));
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_octet(stru.value.entityKind()));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::EntityId_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm << IDL::DistinctType<const  ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag>(stru.value.entityKey()))
    && (strm << ACE_OutputCDR::from_octet(stru.value.entityKind()));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::EntityId_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> stru_value_entityKey_distinct_type(stru.value.entityKey());
  return (strm >> stru_value_entityKey_distinct_type)
    && (strm >> ACE_InputCDR::to_octet(stru.value.entityKind()));
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::EntityId_t> : MetaStruct {
  typedef  ::RtpsRelay::EntityId_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("entityKey", 0),
      std::make_pair("entityKind", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::EntityId_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::EntityId_t& typed = *static_cast<const  ::RtpsRelay::EntityId_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "entityKind") == 0) {
      return typed.entityKind();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::EntityId_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast<IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag>*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "entityKind") {
      ACE_CDR::Octet val;
      if (!(strm >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'entityKind' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'entityKind' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "entityKind") == 0) {
      return make_field_cmp(&T::_entityKind, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::EntityId_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"entityKey", "entityKind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "entityKey") == 0) {
      return &static_cast<const T*>(stru)->_entityKey;
    }
    if (std::strcmp(field, "entityKind") == 0) {
      return &static_cast<const T*>(stru)->_entityKind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::EntityId_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "entityKey") == 0) {
      static_cast<T*>(lhs)->_entityKey = *static_cast<const  ::RtpsRelay::EntityKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entityKind") == 0) {
      static_cast<T*>(lhs)->_entityKind = *static_cast<const  ::CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::EntityId_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "entityKind") == 0) {
      return static_cast<const T*>(lhs)->_entityKind == static_cast<const T*>(rhs)->_entityKind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::EntityId_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::EntityId_t>()
{
  static MetaStructImpl< ::RtpsRelay::EntityId_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::EntityId_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::EntityId_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
EntityId_t::EntityId_t(const  ::RtpsRelay::EntityKey_t& entityKey,
    uint8_t entityKind)
  : _entityKey(entityKey)
  , _entityKind(entityKind)
{}

void swap(EntityId_t& lhs, EntityId_t& rhs)
{
  using std::swap;
  swap(lhs._entityKey, rhs._entityKey);
  swap(lhs._entityKind, rhs._entityKind);
}

}

/* End STRUCT: EntityId_t */


/* Begin STRUCT: GUID_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_GUID_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_GUID_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::GUID_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"guidPrefix",0},{"entityId",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_array()) return false;
      if (!value_reader.read_byte_array (value.guidPrefix().data(), 12)) return false;
      if (!value_reader.end_array()) return false;
      break;
    }
    case 1: {
      if (!vread(value_reader, value.entityId())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::GUID_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("guidPrefix");
  value_writer.begin_array();
  value_writer.write_byte_array (value.guidPrefix().data(), 12);
  value_writer.end_array();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("entityId");
  vwrite(value_writer, value.entityId());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::GUID_t& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag>(stru.guidPrefix()));
  set_default(stru.entityId());
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::GUID_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag>(stru.guidPrefix()));
  serialized_size(encoding, size, stru.entityId());
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::GUID_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm << IDL::DistinctType<const  ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag>(stru.guidPrefix()))
    && (strm << stru.entityId());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::GUID_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> stru_guidPrefix_distinct_type(stru.guidPrefix());
  return (strm >> stru_guidPrefix_distinct_type)
    && (strm >> stru.entityId());
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::GUID_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag>(stru.value.guidPrefix()));
  serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::EntityId_t>(stru.value.entityId()));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::GUID_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  return (strm << IDL::DistinctType<const  ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag>(stru.value.guidPrefix()))
    && (strm << NestedKeyOnly<const  ::RtpsRelay::EntityId_t>(stru.value.entityId()));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::GUID_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> stru_value_guidPrefix_distinct_type(stru.value.guidPrefix());
  NestedKeyOnly< ::RtpsRelay::EntityId_t> stru_value_entityId_nested_key_only(stru.value.entityId());
  return (strm >> stru_value_guidPrefix_distinct_type)
    && (strm >> stru_value_entityId_nested_key_only);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::GUID_t> : MetaStruct {
  typedef  ::RtpsRelay::GUID_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("guidPrefix", 0),
      std::make_pair("entityId", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::GUID_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::GUID_t& typed = *static_cast<const  ::RtpsRelay::GUID_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "entityId.", 9) == 0) {
      return getMetaStruct< ::RtpsRelay::EntityId_t>().getValue(&typed._entityId, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::GUID_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast<IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag>*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "entityId") {
      return getMetaStruct< ::RtpsRelay::EntityId_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'entityId' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "entityId.", 9) == 0) {
      return make_struct_cmp(&T::_entityId, getMetaStruct< ::RtpsRelay::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::GUID_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"guidPrefix", "entityId", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->_guidPrefix;
    }
    if (std::strcmp(field, "entityId") == 0) {
      return &static_cast<const T*>(stru)->_entityId;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::GUID_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "guidPrefix") == 0) {
      static_cast<T*>(lhs)->_guidPrefix = *static_cast<const  ::RtpsRelay::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entityId") == 0) {
      static_cast<T*>(lhs)->_entityId = *static_cast<const  ::RtpsRelay::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::GUID_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::GUID_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::GUID_t>()
{
  static MetaStructImpl< ::RtpsRelay::GUID_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::GUID_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::GUID_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
GUID_t::GUID_t(const  ::RtpsRelay::GuidPrefix_t& guidPrefix,
    const  ::RtpsRelay::EntityId_t& entityId)
  : _guidPrefix(guidPrefix)
  , _entityId(entityId)
{}

void swap(GUID_t& lhs, GUID_t& rhs)
{
  using std::swap;
  swap(lhs._guidPrefix, rhs._guidPrefix);
  swap(lhs._entityId, rhs._entityId);
}

}

/* End STRUCT: GUID_t */


/* Begin TYPEDEF: StringSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_StringSequence_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_StringSequence_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if ((*seq.val_).empty()) {
    return;
  }
  for (CORBA::ULong i = 0; i < static_cast<uint32_t>((*seq.val_).size()); ++i) {
    primitive_serialized_size_ulong(encoding, size);
    size += (*seq.val_)[i].size() + 1;
  }
}

bool operator<<(Serializer& strm, const IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = static_cast<uint32_t>((*seq.val_).size());
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << (*seq.val_)[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  (*seq.val_).resize(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> (*seq.val_)[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::RtpsRelay::StringSequence tempvar;
        tempvar.resize(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
;
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::RtpsRelay::StringSequence tempvar;
      tempvar.resize(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
;
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    ACE_CDR::ULong strlength;
    if (!(ser >> strlength)) return false;
    if (!ser.skip(strlength)) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: StringSequence */


/* Begin TYPEDEF: GuidSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_GuidSequence_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_GuidSequence_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const  ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag> seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if ((*seq.val_).empty()) {
    return;
  }
  for (CORBA::ULong i = 0; i < static_cast<uint32_t>((*seq.val_).size()); ++i) {
    serialized_size(encoding, size, (*seq.val_)[i]);
  }
}

bool operator<<(Serializer& strm, const IDL::DistinctType<const  ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag> seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = static_cast<uint32_t>((*seq.val_).size());
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << (*seq.val_)[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, IDL::DistinctType< ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag> seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  (*seq.val_).resize(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
     if (!(strm >> (*seq.val_)[i])) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::RtpsRelay::GuidSequence tempvar;
        tempvar.resize(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::RtpsRelay::GuidSequence tempvar;
      tempvar.resize(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const NestedKeyOnly<const  ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag> seq)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(seq);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  if ((*seq.val_).value.empty()) {
    return;
  }
  for (CORBA::ULong i = 0; i < static_cast<uint32_t>((*seq.val_).value.size()); ++i) {
    serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>((*seq.val_).value[i]));
  }
}

bool operator<<(Serializer& strm, const IDL::DistinctType<const NestedKeyOnly<const  ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag> seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, seq);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  const CORBA::ULong length = static_cast<uint32_t>((*seq.val_).value.size());
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>((*seq.val_).value[i]))) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, IDL::DistinctType<NestedKeyOnly< ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag> seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_seq = strm.rpos() + total_size;
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > strm.length()) {
    if (DCPS_debug_level >= 8) {
      ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) Invalid sequence length (%u)\n"), length));
    }
    return false;
  }
  CORBA::ULong new_length = length;
  (*seq.val_).value.resize(new_length);
  for (CORBA::ULong i = 0; i < new_length; ++i) {
    NestedKeyOnly< ::RtpsRelay::GUID_t> seq_val_9_value_i_nested_key_only((*seq.val_).value[i]);
     if (!(strm >> seq_val_9_value_i_nested_key_only)) {
      strm.set_construction_status(Serializer::ElementConstructionFailure);
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
        strm.skip(end_of_seq - strm.rpos());
      } else {
         ::RtpsRelay::GuidSequence tempvar;
        tempvar.resize(1);
        for (CORBA::ULong j = i + 1; j < length; ++j) {
          strm >> tempvar[0];
        }
      }
      return false;
    }
  }
  if (new_length != length) {
    if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
      strm.skip(end_of_seq - strm.rpos());
    } else {
       ::RtpsRelay::GuidSequence tempvar;
      tempvar.resize(1);
      for (CORBA::ULong j = new_length + 1; j < length; ++j) {
        strm >> tempvar[0];
      }
    }
    strm.set_construction_status(Serializer::BoundConstructionFailure);
    return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, IDL::DistinctType< ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag>*)
{
  ACE_UNUSED_ARG(ser);
  const Encoding& encoding = ser.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!ser.read_delimiter(total_size)) {
      return false;
    }
  }
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast< ::RtpsRelay::GUID_t*>(0))) return false;
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GuidSequence */


/* Begin CONST: RELAY_PARTITIONS_TOPIC_NAME */


/* End CONST: RELAY_PARTITIONS_TOPIC_NAME */


/* Begin STRUCT: RelayPartitions */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayPartitions_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(167, 66, 191, 138, 175, 21, 47, 188, 150, 90, 174, 31, 217, 250));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayPartitions_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayPartitions& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"relay_id",0},{"slot",1},{"partitions",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relay_id() = x;
      }
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.slot())) return false;
      break;
    }
    case 2: {
      if (!value_reader.begin_sequence()) return false;
      for (size_t i = 0; value_reader.elements_remaining(); ++i) {
        value.partitions().resize(value.partitions().size() + 1);
        if (!value_reader.begin_element()) return false;
        {
          String x;
          if (!value_reader.read_string(x)) return false;
          value.partitions()[i] = x;
        }
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayPartitions& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("relay_id");
  value_writer.write_string(value.relay_id());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("slot");
  value_writer.write_uint32(value.slot());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("partitions");
  value_writer.begin_sequence();
  for (size_t i = 0; i != value.partitions().size(); ++i) {
    value_writer.begin_element(i);
    value_writer.write_string(value.partitions()[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::RelayPartitions& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.relay_id() = "";
  stru.slot() = 0;
  stru.partitions().resize(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::RelayPartitions& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.relay_id().size() + 1;
  primitive_serialized_size(encoding, size, stru.slot());
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.partitions()));
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::RelayPartitions& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.relay_id())
    && (strm << stru.slot())
    && (strm << IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.partitions()));
}

bool operator>>(Serializer& strm,  ::RtpsRelay::RelayPartitions& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> stru_partitions_distinct_type(stru.partitions());
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.slot())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_partitions_distinct_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::RelayPartitions>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  primitive_serialized_size(encoding, size, stru.value.slot());
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::RelayPartitions>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.relay_id())
    && (strm << stru.value.slot());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayPartitions>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.slot())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::RtpsRelay::RelayPartitions>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  primitive_serialized_size(encoding, size, stru.value.slot());
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::RtpsRelay::RelayPartitions>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.relay_id())
    && (strm << stru.value.slot());
}

bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayPartitions>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.slot())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
::DDS::DataWriter_ptr RelayPartitionsTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<RelayPartitions> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr RelayPartitionsTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayPartitions> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr RelayPartitionsTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayPartitions> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<RelayPartitions, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& RelayPartitionsTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<RelayPartitions>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool RelayPartitionsTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* RelayPartitionsTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void RelayPartitionsTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& RelayPartitionsTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::RtpsRelay_RelayPartitions_xtag>();
}

const OpenDDS::XTypes::TypeMap& RelayPartitionsTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::RtpsRelay_RelayPartitions_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& RelayPartitionsTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& RelayPartitionsTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility RelayPartitionsTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

RelayPartitionsTypeSupport::_ptr_type RelayPartitionsTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::RelayPartitions> : MetaStruct {
  typedef  ::RtpsRelay::RelayPartitions T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 2; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "relay_id")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "slot")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("relay_id", 0),
      std::make_pair("slot", 1),
      std::make_pair("partitions", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayPartitions)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::RelayPartitions& typed = *static_cast<const  ::RtpsRelay::RelayPartitions*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "relay_id") == 0) {
      return typed.relay_id();
    }
    if (std::strcmp(field, "slot") == 0) {
      return typed.slot();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayPartitions)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "relay_id") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'relay_id' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relay_id' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relay_id' contents could not be skipped");
      }
    }
    if (base_field == "slot") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'slot' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'slot' could not be skipped");
      }
    }
    if (!gen_skip_over(strm, static_cast<IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "relay_id") == 0) {
      return make_field_cmp(&T::_relay_id, next);
    }
    if (std::strcmp(field, "slot") == 0) {
      return make_field_cmp(&T::_slot, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayPartitions)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"relay_id", "slot", "partitions", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "relay_id") == 0) {
      return &static_cast<const T*>(stru)->_relay_id;
    }
    if (std::strcmp(field, "slot") == 0) {
      return &static_cast<const T*>(stru)->_slot;
    }
    if (std::strcmp(field, "partitions") == 0) {
      return &static_cast<const T*>(stru)->_partitions;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayPartitions)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "relay_id") == 0) {
      static_cast<T*>(lhs)->_relay_id = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "slot") == 0) {
      static_cast<T*>(lhs)->_slot = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partitions") == 0) {
      static_cast<T*>(lhs)->_partitions = *static_cast<const  ::RtpsRelay::StringSequence*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayPartitions)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "relay_id") == 0) {
      return static_cast<const T*>(lhs)->_relay_id == static_cast<const T*>(rhs)->_relay_id;
    }
    if (std::strcmp(field, "slot") == 0) {
      return static_cast<const T*>(lhs)->_slot == static_cast<const T*>(rhs)->_slot;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayPartitions)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayPartitions>()
{
  static MetaStructImpl< ::RtpsRelay::RelayPartitions> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayPartitions*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::RelayPartitions>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
RelayPartitions::RelayPartitions(const std::string& relay_id,
    uint32_t slot,
    const  ::RtpsRelay::StringSequence& partitions)
  : _relay_id(relay_id)
  , _slot(slot)
  , _partitions(partitions)
{}

void swap(RelayPartitions& lhs, RelayPartitions& rhs)
{
  using std::swap;
  swap(lhs._relay_id, rhs._relay_id);
  swap(lhs._slot, rhs._slot);
  swap(lhs._partitions, rhs._partitions);
}

}

/* End STRUCT: RelayPartitions */


/* Begin CONST: RELAY_ADDRESSES_TOPIC_NAME */


/* End CONST: RELAY_ADDRESSES_TOPIC_NAME */


/* Begin STRUCT: RelayAddress */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayAddress_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(40, 115, 44, 121, 247, 153, 9, 247, 20, 247, 224, 100, 254, 136));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayAddress_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayAddress& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"relay_id",0},{"name",1},{"address",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relay_id() = x;
      }
      break;
    }
    case 1: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.name() = x;
      }
      break;
    }
    case 2: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.address() = x;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayAddress& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("relay_id");
  value_writer.write_string(value.relay_id());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("name");
  value_writer.write_string(value.name());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("address");
  value_writer.write_string(value.address());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::RelayAddress& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.relay_id() = "";
  stru.name() = "";
  stru.address() = "";
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::RelayAddress& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.relay_id().size() + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += stru.name().size() + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += stru.address().size() + 1;
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::RelayAddress& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.relay_id())
    && (strm << stru.name())
    && (strm << stru.address());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::RelayAddress& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.name())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.address())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::RelayAddress>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.name().size() + 1;
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::RelayAddress>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.relay_id())
    && (strm << stru.value.name());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayAddress>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.name())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::RtpsRelay::RelayAddress>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.name().size() + 1;
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::RtpsRelay::RelayAddress>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.relay_id())
    && (strm << stru.value.name());
}

bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayAddress>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.name())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
::DDS::DataWriter_ptr RelayAddressTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<RelayAddress> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr RelayAddressTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayAddress> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr RelayAddressTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayAddress> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<RelayAddress, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& RelayAddressTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<RelayAddress>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool RelayAddressTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* RelayAddressTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void RelayAddressTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& RelayAddressTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::RtpsRelay_RelayAddress_xtag>();
}

const OpenDDS::XTypes::TypeMap& RelayAddressTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::RtpsRelay_RelayAddress_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& RelayAddressTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& RelayAddressTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility RelayAddressTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

RelayAddressTypeSupport::_ptr_type RelayAddressTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::RelayAddress> : MetaStruct {
  typedef  ::RtpsRelay::RelayAddress T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 2; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "relay_id")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "name")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("relay_id", 0),
      std::make_pair("name", 1),
      std::make_pair("address", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayAddress)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::RelayAddress& typed = *static_cast<const  ::RtpsRelay::RelayAddress*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "relay_id") == 0) {
      return typed.relay_id();
    }
    if (std::strcmp(field, "name") == 0) {
      return typed.name();
    }
    if (std::strcmp(field, "address") == 0) {
      return typed.address();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayAddress)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "relay_id") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'relay_id' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relay_id' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relay_id' contents could not be skipped");
      }
    }
    if (base_field == "name") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (base_field == "address") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'address' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'address' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'address' contents could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "relay_id") == 0) {
      return make_field_cmp(&T::_relay_id, next);
    }
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::_name, next);
    }
    if (std::strcmp(field, "address") == 0) {
      return make_field_cmp(&T::_address, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayAddress)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"relay_id", "name", "address", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "relay_id") == 0) {
      return &static_cast<const T*>(stru)->_relay_id;
    }
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->_name;
    }
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->_address;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayAddress)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "relay_id") == 0) {
      static_cast<T*>(lhs)->_relay_id = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->_name = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "address") == 0) {
      static_cast<T*>(lhs)->_address = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayAddress)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "relay_id") == 0) {
      return static_cast<const T*>(lhs)->_relay_id == static_cast<const T*>(rhs)->_relay_id;
    }
    if (std::strcmp(field, "name") == 0) {
      return static_cast<const T*>(lhs)->_name == static_cast<const T*>(rhs)->_name;
    }
    if (std::strcmp(field, "address") == 0) {
      return static_cast<const T*>(lhs)->_address == static_cast<const T*>(rhs)->_address;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayAddress)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayAddress>()
{
  static MetaStructImpl< ::RtpsRelay::RelayAddress> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayAddress*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::RelayAddress>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
RelayAddress::RelayAddress(const std::string& relay_id,
    const std::string& name,
    const std::string& address)
  : _relay_id(relay_id)
  , _name(name)
  , _address(address)
{}

void swap(RelayAddress& lhs, RelayAddress& rhs)
{
  using std::swap;
  swap(lhs._relay_id, rhs._relay_id);
  swap(lhs._name, rhs._name);
  swap(lhs._address, rhs._address);
}

}

/* End STRUCT: RelayAddress */


/* Begin CONST: RELAY_STATUS_TOPIC_NAME */


/* End CONST: RELAY_STATUS_TOPIC_NAME */


/* Begin STRUCT: RelayStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(81, 10, 91, 75, 77, 139, 48, 187, 15, 190, 19, 210, 177, 240));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"relay_id",0},{"admitting",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relay_id() = x;
      }
      break;
    }
    case 1: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.admitting() = bx;
      }
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("relay_id");
  value_writer.write_string(value.relay_id());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("admitting");
  value_writer.write_boolean(value.admitting());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::RelayStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.relay_id() = "";
  stru.admitting() = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::RelayStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.relay_id().size() + 1;
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.admitting()));
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::RelayStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.relay_id())
    && (strm << ACE_OutputCDR::from_boolean(stru.admitting()));
}

bool operator>>(Serializer& strm,  ::RtpsRelay::RelayStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> ACE_InputCDR::to_boolean(stru.admitting()))) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::RelayStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::RelayStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.relay_id());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::RtpsRelay::RelayStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::RtpsRelay::RelayStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.relay_id());
}

bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.relay_id())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
::DDS::DataWriter_ptr RelayStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<RelayStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr RelayStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr RelayStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<RelayStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& RelayStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<RelayStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool RelayStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* RelayStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void RelayStatusTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& RelayStatusTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::RtpsRelay_RelayStatus_xtag>();
}

const OpenDDS::XTypes::TypeMap& RelayStatusTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::RtpsRelay_RelayStatus_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& RelayStatusTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& RelayStatusTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility RelayStatusTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

RelayStatusTypeSupport::_ptr_type RelayStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::RelayStatus> : MetaStruct {
  typedef  ::RtpsRelay::RelayStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 1; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "relay_id")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("relay_id", 0),
      std::make_pair("admitting", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::RelayStatus& typed = *static_cast<const  ::RtpsRelay::RelayStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "relay_id") == 0) {
      return typed.relay_id();
    }
    if (std::strcmp(field, "admitting") == 0) {
      return typed.admitting();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "relay_id") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'relay_id' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relay_id' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relay_id' contents could not be skipped");
      }
    }
    if (base_field == "admitting") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'admitting' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'admitting' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "relay_id") == 0) {
      return make_field_cmp(&T::_relay_id, next);
    }
    if (std::strcmp(field, "admitting") == 0) {
      return make_field_cmp(&T::_admitting, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"relay_id", "admitting", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "relay_id") == 0) {
      return &static_cast<const T*>(stru)->_relay_id;
    }
    if (std::strcmp(field, "admitting") == 0) {
      return &static_cast<const T*>(stru)->_admitting;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "relay_id") == 0) {
      static_cast<T*>(lhs)->_relay_id = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "admitting") == 0) {
      static_cast<T*>(lhs)->_admitting = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "relay_id") == 0) {
      return static_cast<const T*>(lhs)->_relay_id == static_cast<const T*>(rhs)->_relay_id;
    }
    if (std::strcmp(field, "admitting") == 0) {
      return static_cast<const T*>(lhs)->_admitting == static_cast<const T*>(rhs)->_admitting;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayStatus>()
{
  static MetaStructImpl< ::RtpsRelay::RelayStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::RelayStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
RelayStatus::RelayStatus(const std::string& relay_id,
    bool admitting)
  : _relay_id(relay_id)
  , _admitting(admitting)
{}

void swap(RelayStatus& lhs, RelayStatus& rhs)
{
  using std::swap;
  swap(lhs._relay_id, rhs._relay_id);
  swap(lhs._admitting, rhs._admitting);
}

}

/* End STRUCT: RelayStatus */


/* Begin CONST: RELAY_PARTICIPANT_STATUS_TOPIC_NAME */


/* End CONST: RELAY_PARTICIPANT_STATUS_TOPIC_NAME */


/* Begin STRUCT: RelayParticipantStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayParticipantStatus_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(167, 183, 124, 126, 24, 20, 45, 94, 110, 196, 76, 156, 168, 174));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayParticipantStatus_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayParticipantStatus& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"relay_id",52683514},{"guid",27593758},{"active",73296583},{"alive",97899387},{"user_data",160271928},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 52683514: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relay_id() = x;
      }
      break;
    }
    case 27593758: {
      if (!vread(value_reader, value.guid())) return false;
      break;
    }
    case 73296583: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.active() = bx;
      }
      break;
    }
    case 97899387: {
      {
         ::CORBA::Boolean bx;
        if (!value_reader.read_boolean(bx)) return false;
        value.alive() = bx;
      }
      break;
    }
    case 160271928: {
      if (!vread(value_reader, value.user_data())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayParticipantStatus& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("relay_id");
  value_writer.write_string(value.relay_id());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("guid");
  vwrite(value_writer, value.guid());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("active");
  value_writer.write_boolean(value.active());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("alive");
  value_writer.write_boolean(value.alive());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("user_data");
  vwrite(value_writer, value.user_data());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::RelayParticipantStatus& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.relay_id() = "";
  set_default(stru.guid());
  stru.active() = 0;
  stru.alive() = 0;
  set_default(stru.user_data());
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::RelayParticipantStatus& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.relay_id().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.guid());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.active()));
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.alive()));
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.user_data());
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::RelayParticipantStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.relay_id())) {
    return false;
  }
    serialized_size(encoding, size, stru.guid());

    if (!strm.write_parameter_id(27593758, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.guid())) {
    return false;
  }
    primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.active()));

    if (!strm.write_parameter_id(73296583, size)) {
      return false;
    }
    size = 0;
    if (!(strm << ACE_OutputCDR::from_boolean(stru.active()))) {
    return false;
  }
    primitive_serialized_size(encoding, size, ACE_OutputCDR::from_boolean(stru.alive()));

    if (!strm.write_parameter_id(97899387, size)) {
      return false;
    }
    size = 0;
    if (!(strm << ACE_OutputCDR::from_boolean(stru.alive()))) {
    return false;
  }
    serialized_size(encoding, size, stru.user_data());

    if (!strm.write_parameter_id(160271928, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.user_data())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.relay_id())
    && (strm << stru.guid())
    && (strm << ACE_OutputCDR::from_boolean(stru.active()))
    && (strm << ACE_OutputCDR::from_boolean(stru.alive()))
    && (strm << stru.user_data());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::RelayParticipantStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 27593758: {
        if (!(strm >> stru.guid())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 73296583: {
        if (!(strm >> ACE_InputCDR::to_boolean(stru.active()))) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 97899387: {
        if (!(strm >> ACE_InputCDR::to_boolean(stru.alive()))) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 160271928: {
        if (!(strm >> stru.user_data())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::RelayParticipantStatus\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.relay_id())
    && (strm >> stru.guid())
    && (strm >> ACE_InputCDR::to_boolean(stru.active()))
    && (strm >> ACE_InputCDR::to_boolean(stru.alive()))
    && (strm >> stru.user_data());
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::RelayParticipantStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::RelayParticipantStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.relay_id())) {
    return false;
  }
    serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));

    if (!strm.write_parameter_id(27593758, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()))) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.value.relay_id())
    && (strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayParticipantStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.value.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 27593758: {
        if (!(strm >> stru_value_guid_nested_key_only)) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const NestedKeyOnly< ::RtpsRelay::RelayParticipantStatus>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
  return (strm >> stru.value.relay_id())
    && (strm >> stru_value_guid_nested_key_only);
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::RtpsRelay::RelayParticipantStatus>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::RtpsRelay::RelayParticipantStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.relay_id())) {
    return false;
  }
    serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));

    if (!strm.write_parameter_id(27593758, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()))) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.value.relay_id())
    && (strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));
}

bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayParticipantStatus>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.value.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 27593758: {
        if (!(strm >> stru_value_guid_nested_key_only)) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const KeyOnly< ::RtpsRelay::RelayParticipantStatus>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
  return (strm >> stru.value.relay_id())
    && (strm >> stru_value_guid_nested_key_only);
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
::DDS::DataWriter_ptr RelayParticipantStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<RelayParticipantStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr RelayParticipantStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayParticipantStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr RelayParticipantStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayParticipantStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<RelayParticipantStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& RelayParticipantStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<RelayParticipantStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool RelayParticipantStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* RelayParticipantStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void RelayParticipantStatusTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& RelayParticipantStatusTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::RtpsRelay_RelayParticipantStatus_xtag>();
}

const OpenDDS::XTypes::TypeMap& RelayParticipantStatusTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::RtpsRelay_RelayParticipantStatus_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& RelayParticipantStatusTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& RelayParticipantStatusTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility RelayParticipantStatusTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

RelayParticipantStatusTypeSupport::_ptr_type RelayParticipantStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::RelayParticipantStatus> : MetaStruct {
  typedef  ::RtpsRelay::RelayParticipantStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 17; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "relay_id")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.entityId.entityKind")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("relay_id", 52683514),
      std::make_pair("guid", 27593758),
      std::make_pair("active", 73296583),
      std::make_pair("alive", 97899387),
      std::make_pair("user_data", 160271928),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayParticipantStatus)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::RelayParticipantStatus& typed = *static_cast<const  ::RtpsRelay::RelayParticipantStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "relay_id") == 0) {
      return typed.relay_id();
    }
    if (std::strncmp(field, "guid.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::GUID_t>().getValue(&typed._guid, field + 5);
    }
    if (std::strcmp(field, "active") == 0) {
      return typed.active();
    }
    if (std::strcmp(field, "alive") == 0) {
      return typed.alive();
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(&typed._user_data, field + 10);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayParticipantStatus)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
      unsigned field_id = map_name_to_id(base_field.c_str());
      ACE_UNUSED_ARG(field_id);
      unsigned member_id;
      size_t field_size;
      const size_t end_of_struct = strm.rpos() + total_size;
      while (true) {
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
          break;
        }
        bool must_understand = false;
        if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " Deserialization Error for struct  ::RtpsRelay::RelayParticipantStatus");
        }
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::RtpsRelay::RelayParticipantStatus");
        }
        const size_t end_of_field = strm.rpos() + field_size;
        ACE_UNUSED_ARG(end_of_field);

        switch (member_id) {
        case 52683514: {
          if (field_id == member_id) {
            std::string val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'relay_id' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 27593758: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::GUID_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 73296583: {
          if (field_id == member_id) {
            ACE_CDR::Boolean val;
            if (!(strm >> ACE_InputCDR::to_boolean(val))) {
              throw std::runtime_error("Field 'active' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 97899387: {
          if (field_id == member_id) {
            ACE_CDR::Boolean val;
            if (!(strm >> ACE_InputCDR::to_boolean(val))) {
              throw std::runtime_error("Field 'alive' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 160271928: {
          if (field_id == member_id) {
            return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        default:
          if (must_understand) {
            if (DCPS_debug_level >= 8) {
              ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::RelayParticipantStatus\n"), member_id));
            }
            throw std::runtime_error("member id did not exist in getValue");
          }
          strm.skip(field_size);
          break;
        }
      }
      if (!field[0]) {
        return 0;
      }
      throw std::runtime_error("Did not find field in getValue");
    }
    if (base_field == "relay_id") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'relay_id' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relay_id' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relay_id' contents could not be skipped");
      }
    }
    if (base_field == "guid") {
      return getMetaStruct< ::RtpsRelay::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::GUID_t*>(0))) {
        throw std::runtime_error("Field 'guid' could not be skipped");
      }
    }
    if (base_field == "active") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'active' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'active' could not be skipped");
      }
    }
    if (base_field == "alive") {
      ACE_CDR::Boolean val;
      if (!(strm >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'alive' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  1 )) {
        throw std::runtime_error("Field 'alive' could not be skipped");
      }
    }
    if (base_field == "user_data") {
      return getMetaStruct< ::DDS::UserDataQosPolicy>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::DDS::UserDataQosPolicy*>(0))) {
        throw std::runtime_error("Field 'user_data' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "relay_id") == 0) {
      return make_field_cmp(&T::_relay_id, next);
    }
    if (std::strncmp(field, "guid.", 5) == 0) {
      return make_struct_cmp(&T::_guid, getMetaStruct< ::RtpsRelay::GUID_t>().create_qc_comparator(field + 5), next);
    }
    if (std::strcmp(field, "active") == 0) {
      return make_field_cmp(&T::_active, next);
    }
    if (std::strcmp(field, "alive") == 0) {
      return make_field_cmp(&T::_alive, next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::_user_data, getMetaStruct< ::DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayParticipantStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"relay_id", "guid", "active", "alive", "user_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "relay_id") == 0) {
      return &static_cast<const T*>(stru)->_relay_id;
    }
    if (std::strcmp(field, "guid") == 0) {
      return &static_cast<const T*>(stru)->_guid;
    }
    if (std::strcmp(field, "active") == 0) {
      return &static_cast<const T*>(stru)->_active;
    }
    if (std::strcmp(field, "alive") == 0) {
      return &static_cast<const T*>(stru)->_alive;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->_user_data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayParticipantStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "relay_id") == 0) {
      static_cast<T*>(lhs)->_relay_id = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guid") == 0) {
      static_cast<T*>(lhs)->_guid = *static_cast<const  ::RtpsRelay::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "active") == 0) {
      static_cast<T*>(lhs)->_active = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "alive") == 0) {
      static_cast<T*>(lhs)->_alive = *static_cast<const  ::CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->_user_data = *static_cast<const  ::DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayParticipantStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "relay_id") == 0) {
      return static_cast<const T*>(lhs)->_relay_id == static_cast<const T*>(rhs)->_relay_id;
    }
    if (std::strcmp(field, "active") == 0) {
      return static_cast<const T*>(lhs)->_active == static_cast<const T*>(rhs)->_active;
    }
    if (std::strcmp(field, "alive") == 0) {
      return static_cast<const T*>(lhs)->_alive == static_cast<const T*>(rhs)->_alive;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayParticipantStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayParticipantStatus>()
{
  static MetaStructImpl< ::RtpsRelay::RelayParticipantStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayParticipantStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::RelayParticipantStatus>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
RelayParticipantStatus::RelayParticipantStatus(const std::string& relay_id,
    const  ::RtpsRelay::GUID_t& guid,
    bool active,
    bool alive,
    const  ::DDS::UserDataQosPolicy& user_data)
  : _relay_id(relay_id)
  , _guid(guid)
  , _active(active)
  , _alive(alive)
  , _user_data(user_data)
{}

void swap(RelayParticipantStatus& lhs, RelayParticipantStatus& rhs)
{
  using std::swap;
  swap(lhs._relay_id, rhs._relay_id);
  swap(lhs._guid, rhs._guid);
  swap(lhs._active, rhs._active);
  swap(lhs._alive, rhs._alive);
  swap(lhs._user_data, rhs._user_data);
}

}

/* End STRUCT: RelayParticipantStatus */


/* Begin CONST: SPDP_REPLAY_TOPIC_NAME */


/* End CONST: SPDP_REPLAY_TOPIC_NAME */


/* Begin STRUCT: SpdpReplay */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_SpdpReplay_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(167, 1, 236, 210, 186, 165, 8, 12, 191, 99, 115, 152, 245, 212));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_SpdpReplay_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::SpdpReplay& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"partitions",0},{"address",1},{"guid",2},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (size_t i = 0; value_reader.elements_remaining(); ++i) {
        value.partitions().resize(value.partitions().size() + 1);
        if (!value_reader.begin_element()) return false;
        {
          String x;
          if (!value_reader.read_string(x)) return false;
          value.partitions()[i] = x;
        }
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 1: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.address() = x;
      }
      break;
    }
    case 2: {
      if (!vread(value_reader, value.guid())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::SpdpReplay& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("partitions");
  value_writer.begin_sequence();
  for (size_t i = 0; i != value.partitions().size(); ++i) {
    value_writer.begin_element(i);
    value_writer.write_string(value.partitions()[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("address");
  value_writer.write_string(value.address());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("guid");
  vwrite(value_writer, value.guid());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::SpdpReplay& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.partitions().resize(0);
  stru.address() = "";
  set_default(stru.guid());
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::SpdpReplay& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.partitions()));
  primitive_serialized_size_ulong(encoding, size);
  size += stru.address().size() + 1;
  serialized_size(encoding, size, stru.guid());
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::SpdpReplay& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.partitions()))
    && (strm << stru.address())
    && (strm << stru.guid());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::SpdpReplay& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> stru_partitions_distinct_type(stru.partitions());
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_partitions_distinct_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.address())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.guid())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::SpdpReplay>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.value.partitions()));
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.address().size() + 1;
  serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::SpdpReplay>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.value.partitions()))
    && (strm << stru.value.address())
    && (strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::SpdpReplay>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> stru_value_partitions_distinct_type(stru.value.partitions());
  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_partitions_distinct_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.address())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_guid_nested_key_only)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::RtpsRelay::SpdpReplay>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::RtpsRelay::SpdpReplay>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::SpdpReplay>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
::DDS::DataWriter_ptr SpdpReplayTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SpdpReplay> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SpdpReplayTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SpdpReplay> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SpdpReplayTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SpdpReplay> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SpdpReplay, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SpdpReplayTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SpdpReplay>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SpdpReplayTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* SpdpReplayTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void SpdpReplayTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& SpdpReplayTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::RtpsRelay_SpdpReplay_xtag>();
}

const OpenDDS::XTypes::TypeMap& SpdpReplayTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::RtpsRelay_SpdpReplay_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& SpdpReplayTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& SpdpReplayTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility SpdpReplayTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

SpdpReplayTypeSupport::_ptr_type SpdpReplayTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::SpdpReplay> : MetaStruct {
  typedef  ::RtpsRelay::SpdpReplay T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("partitions", 0),
      std::make_pair("address", 1),
      std::make_pair("guid", 2),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 3);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::SpdpReplay)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::SpdpReplay& typed = *static_cast<const  ::RtpsRelay::SpdpReplay*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "address") == 0) {
      return typed.address();
    }
    if (std::strncmp(field, "guid.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::GUID_t>().getValue(&typed._guid, field + 5);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::SpdpReplay)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast<IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (base_field == "address") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'address' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'address' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'address' contents could not be skipped");
      }
    }
    if (base_field == "guid") {
      return getMetaStruct< ::RtpsRelay::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::GUID_t*>(0))) {
        throw std::runtime_error("Field 'guid' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "address") == 0) {
      return make_field_cmp(&T::_address, next);
    }
    if (std::strncmp(field, "guid.", 5) == 0) {
      return make_struct_cmp(&T::_guid, getMetaStruct< ::RtpsRelay::GUID_t>().create_qc_comparator(field + 5), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::SpdpReplay)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"partitions", "address", "guid", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "partitions") == 0) {
      return &static_cast<const T*>(stru)->_partitions;
    }
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->_address;
    }
    if (std::strcmp(field, "guid") == 0) {
      return &static_cast<const T*>(stru)->_guid;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::SpdpReplay)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "partitions") == 0) {
      static_cast<T*>(lhs)->_partitions = *static_cast<const  ::RtpsRelay::StringSequence*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "address") == 0) {
      static_cast<T*>(lhs)->_address = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guid") == 0) {
      static_cast<T*>(lhs)->_guid = *static_cast<const  ::RtpsRelay::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::SpdpReplay)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "address") == 0) {
      return static_cast<const T*>(lhs)->_address == static_cast<const T*>(rhs)->_address;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::SpdpReplay)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::SpdpReplay>()
{
  static MetaStructImpl< ::RtpsRelay::SpdpReplay> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::SpdpReplay*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::SpdpReplay>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
SpdpReplay::SpdpReplay(const  ::RtpsRelay::StringSequence& partitions,
    const std::string& address,
    const  ::RtpsRelay::GUID_t& guid)
  : _partitions(partitions)
  , _address(address)
  , _guid(guid)
{}

void swap(SpdpReplay& lhs, SpdpReplay& rhs)
{
  using std::swap;
  swap(lhs._partitions, rhs._partitions);
  swap(lhs._address, rhs._address);
  swap(lhs._guid, rhs._guid);
}

}

/* End STRUCT: SpdpReplay */


/* Begin STRUCT: RelayHeader */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayHeader_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(12, 140, 21, 115, 253, 34, 228, 1, 111, 94, 79, 187, 0, 91));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayHeader_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayHeader& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"to_partitions",0},{"to_guids",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.begin_sequence()) return false;
      for (size_t i = 0; value_reader.elements_remaining(); ++i) {
        value.to_partitions().resize(value.to_partitions().size() + 1);
        if (!value_reader.begin_element()) return false;
        {
          String x;
          if (!value_reader.read_string(x)) return false;
          value.to_partitions()[i] = x;
        }
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    case 1: {
      if (!value_reader.begin_sequence()) return false;
      for (size_t i = 0; value_reader.elements_remaining(); ++i) {
        value.to_guids().resize(value.to_guids().size() + 1);
        if (!value_reader.begin_element()) return false;
        if (!vread(value_reader, value.to_guids()[i])) return false;
        if (!value_reader.end_element()) return false;
      }
      if (!value_reader.end_sequence()) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayHeader& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("to_partitions");
  value_writer.begin_sequence();
  for (size_t i = 0; i != value.to_partitions().size(); ++i) {
    value_writer.begin_element(i);
    value_writer.write_string(value.to_partitions()[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.begin_struct_member("to_guids");
  value_writer.begin_sequence();
  for (size_t i = 0; i != value.to_guids().size(); ++i) {
    value_writer.begin_element(i);
    vwrite(value_writer, value.to_guids()[i]);
    value_writer.end_element();
  }
  value_writer.end_sequence();
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::RelayHeader& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.to_partitions().resize(0);
  stru.to_guids().resize(0);
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::RelayHeader& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.to_partitions()));
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag>(stru.to_guids()));
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::RelayHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.to_partitions()))
    && (strm << IDL::DistinctType<const  ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag>(stru.to_guids()));
}

bool operator>>(Serializer& strm,  ::RtpsRelay::RelayHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> stru_to_9partitions_distinct_type(stru.to_partitions());
  IDL::DistinctType< ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag> stru_to_9guids_distinct_type(stru.to_guids());
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_to_9partitions_distinct_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_to_9guids_distinct_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::RelayHeader>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size(encoding, size, IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.value.to_partitions()));
  serialized_size(encoding, size, IDL::DistinctType<const NestedKeyOnly<const  ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag>(NestedKeyOnly<const  ::RtpsRelay::GuidSequence>(stru.value.to_guids())));
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::RelayHeader>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>(stru.value.to_partitions()))
    && (strm << IDL::DistinctType<const NestedKeyOnly<const  ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag>(NestedKeyOnly<const  ::RtpsRelay::GuidSequence>(stru.value.to_guids())));
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayHeader>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> stru_value_to_9partitions_distinct_type(stru.value.to_partitions());
  NestedKeyOnly< ::RtpsRelay::GuidSequence> stru_value_to_9guids_nested_key_only(stru.value.to_guids());
  IDL::DistinctType<NestedKeyOnly< ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag> stru_9value_9to_99guids_9nested_9key_9only_distinct_type(stru_value_to_9guids_nested_key_only);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_value_to_9partitions_distinct_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru_9value_9to_99guids_9nested_9key_9only_distinct_type)) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::RelayHeader> : MetaStruct {
  typedef  ::RtpsRelay::RelayHeader T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("to_partitions", 0),
      std::make_pair("to_guids", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayHeader)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::RelayHeader& typed = *static_cast<const  ::RtpsRelay::RelayHeader*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayHeader)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (!gen_skip_over(strm, static_cast<IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(strm, static_cast<IDL::DistinctType< ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag>*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayHeader)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"to_partitions", "to_guids", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "to_partitions") == 0) {
      return &static_cast<const T*>(stru)->_to_partitions;
    }
    if (std::strcmp(field, "to_guids") == 0) {
      return &static_cast<const T*>(stru)->_to_guids;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayHeader)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "to_partitions") == 0) {
      static_cast<T*>(lhs)->_to_partitions = *static_cast<const  ::RtpsRelay::StringSequence*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "to_guids") == 0) {
      static_cast<T*>(lhs)->_to_guids = *static_cast<const  ::RtpsRelay::GuidSequence*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayHeader)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayHeader)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayHeader>()
{
  static MetaStructImpl< ::RtpsRelay::RelayHeader> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayHeader*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::RelayHeader>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
RelayHeader::RelayHeader(const  ::RtpsRelay::StringSequence& to_partitions,
    const  ::RtpsRelay::GuidSequence& to_guids)
  : _to_partitions(to_partitions)
  , _to_guids(to_guids)
{}

void swap(RelayHeader& lhs, RelayHeader& rhs)
{
  using std::swap;
  swap(lhs._to_partitions, rhs._to_partitions);
  swap(lhs._to_guids, rhs._to_guids);
}

}

/* End STRUCT: RelayHeader */


/* Begin STRUCT: Duration_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_Duration_t_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_Duration_t_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::Duration_t& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"sec",0},{"nanosec",1},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 0: {
      if (!value_reader.read_int32(value.sec())) return false;
      break;
    }
    case 1: {
      if (!value_reader.read_uint32(value.nanosec())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::Duration_t& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("sec");
  value_writer.write_int32(value.sec());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("nanosec");
  value_writer.write_uint32(value.nanosec());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::Duration_t& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.sec() = 0;
  stru.nanosec() = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::Duration_t& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.sec());
  primitive_serialized_size(encoding, size, stru.nanosec());
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.sec())
    && (strm << stru.nanosec());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.sec())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.nanosec())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::Duration_t>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  primitive_serialized_size(encoding, size, stru.value.sec());
  primitive_serialized_size(encoding, size, stru.value.nanosec());
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::Duration_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  return (strm << stru.value.sec())
    && (strm << stru.value.nanosec());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::Duration_t>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.sec())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() >= end_of_struct) {
    return true;
  }
  if (!(strm >> stru.value.nanosec())) {
    return false;
  }
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
      strm.rpos() < end_of_struct) {
    strm.skip(end_of_struct - strm.rpos());
  }
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::Duration_t> : MetaStruct {
  typedef  ::RtpsRelay::Duration_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("sec", 0),
      std::make_pair("nanosec", 1),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 2);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::Duration_t)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::Duration_t& typed = *static_cast<const  ::RtpsRelay::Duration_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "sec") == 0) {
      return typed.sec();
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return typed.nanosec();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::Duration_t)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (base_field == "sec") {
      ACE_CDR::Long val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'sec' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'sec' could not be skipped");
      }
    }
    if (base_field == "nanosec") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'nanosec' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'nanosec' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sec") == 0) {
      return make_field_cmp(&T::_sec, next);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return make_field_cmp(&T::_nanosec, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::Duration_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"sec", "nanosec", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      return &static_cast<const T*>(stru)->_sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return &static_cast<const T*>(stru)->_nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::Duration_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sec") == 0) {
      static_cast<T*>(lhs)->_sec = *static_cast<const  ::CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      static_cast<T*>(lhs)->_nanosec = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::Duration_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sec") == 0) {
      return static_cast<const T*>(lhs)->_sec == static_cast<const T*>(rhs)->_sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return static_cast<const T*>(lhs)->_nanosec == static_cast<const T*>(rhs)->_nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::Duration_t)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::Duration_t>()
{
  static MetaStructImpl< ::RtpsRelay::Duration_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::Duration_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::Duration_t>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
Duration_t::Duration_t(int32_t sec,
    uint32_t nanosec)
  : _sec(sec)
  , _nanosec(nanosec)
{}

void swap(Duration_t& lhs, Duration_t& rhs)
{
  using std::swap;
  swap(lhs._sec, rhs._sec);
  swap(lhs._nanosec, rhs._nanosec);
}

}

/* End STRUCT: Duration_t */


/* Begin STRUCT: ProtocolStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_ProtocolStatistics_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 100, 191, 76, 102, 30, 34, 62, 147, 158, 182, 213, 240, 58));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_ProtocolStatistics_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::ProtocolStatistics& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"messages_in",146649702},{"bytes_in",257113707},{"messages_ignored",256318015},{"bytes_ignored",21653781},{"input_processing_time",133473638},{"messages_out",216241791},{"bytes_out",20755121},{"messages_dropped",71676468},{"bytes_dropped",266701231},{"output_processing_time",201631001},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 146649702: {
      if (!value_reader.read_uint32(value.messages_in())) return false;
      break;
    }
    case 257113707: {
      if (!value_reader.read_uint64(value.bytes_in())) return false;
      break;
    }
    case 256318015: {
      if (!value_reader.read_uint32(value.messages_ignored())) return false;
      break;
    }
    case 21653781: {
      if (!value_reader.read_uint64(value.bytes_ignored())) return false;
      break;
    }
    case 133473638: {
      if (!vread(value_reader, value.input_processing_time())) return false;
      break;
    }
    case 216241791: {
      if (!value_reader.read_uint32(value.messages_out())) return false;
      break;
    }
    case 20755121: {
      if (!value_reader.read_uint64(value.bytes_out())) return false;
      break;
    }
    case 71676468: {
      if (!value_reader.read_uint32(value.messages_dropped())) return false;
      break;
    }
    case 266701231: {
      if (!value_reader.read_uint64(value.bytes_dropped())) return false;
      break;
    }
    case 201631001: {
      if (!vread(value_reader, value.output_processing_time())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::ProtocolStatistics& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("messages_in");
  value_writer.write_uint32(value.messages_in());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("bytes_in");
  value_writer.write_uint64(value.bytes_in());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("messages_ignored");
  value_writer.write_uint32(value.messages_ignored());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("bytes_ignored");
  value_writer.write_uint64(value.bytes_ignored());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("input_processing_time");
  vwrite(value_writer, value.input_processing_time());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("messages_out");
  value_writer.write_uint32(value.messages_out());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("bytes_out");
  value_writer.write_uint64(value.bytes_out());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("messages_dropped");
  value_writer.write_uint32(value.messages_dropped());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("bytes_dropped");
  value_writer.write_uint64(value.bytes_dropped());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("output_processing_time");
  vwrite(value_writer, value.output_processing_time());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::ProtocolStatistics& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.messages_in() = 0;
  stru.bytes_in() = 0;
  stru.messages_ignored() = 0;
  stru.bytes_ignored() = 0;
  set_default(stru.input_processing_time());
  stru.messages_out() = 0;
  stru.bytes_out() = 0;
  stru.messages_dropped() = 0;
  stru.bytes_dropped() = 0;
  set_default(stru.output_processing_time());
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::ProtocolStatistics& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.messages_in());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.bytes_in());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.messages_ignored());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.bytes_ignored());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.input_processing_time());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.messages_out());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.bytes_out());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.messages_dropped());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.bytes_dropped());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.output_processing_time());
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::ProtocolStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size(encoding, size, stru.messages_in());

    if (!strm.write_parameter_id(146649702, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.messages_in())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.bytes_in());

    if (!strm.write_parameter_id(257113707, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.bytes_in())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.messages_ignored());

    if (!strm.write_parameter_id(256318015, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.messages_ignored())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.bytes_ignored());

    if (!strm.write_parameter_id(21653781, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.bytes_ignored())) {
    return false;
  }
    serialized_size(encoding, size, stru.input_processing_time());

    if (!strm.write_parameter_id(133473638, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.input_processing_time())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.messages_out());

    if (!strm.write_parameter_id(216241791, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.messages_out())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.bytes_out());

    if (!strm.write_parameter_id(20755121, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.bytes_out())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.messages_dropped());

    if (!strm.write_parameter_id(71676468, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.messages_dropped())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.bytes_dropped());

    if (!strm.write_parameter_id(266701231, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.bytes_dropped())) {
    return false;
  }
    serialized_size(encoding, size, stru.output_processing_time());

    if (!strm.write_parameter_id(201631001, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.output_processing_time())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.messages_in())
    && (strm << stru.bytes_in())
    && (strm << stru.messages_ignored())
    && (strm << stru.bytes_ignored())
    && (strm << stru.input_processing_time())
    && (strm << stru.messages_out())
    && (strm << stru.bytes_out())
    && (strm << stru.messages_dropped())
    && (strm << stru.bytes_dropped())
    && (strm << stru.output_processing_time());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::ProtocolStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 146649702: {
        if (!(strm >> stru.messages_in())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 257113707: {
        if (!(strm >> stru.bytes_in())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 256318015: {
        if (!(strm >> stru.messages_ignored())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 21653781: {
        if (!(strm >> stru.bytes_ignored())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 133473638: {
        if (!(strm >> stru.input_processing_time())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 216241791: {
        if (!(strm >> stru.messages_out())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 20755121: {
        if (!(strm >> stru.bytes_out())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 71676468: {
        if (!(strm >> stru.messages_dropped())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 266701231: {
        if (!(strm >> stru.bytes_dropped())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 201631001: {
        if (!(strm >> stru.output_processing_time())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::ProtocolStatistics\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.messages_in())
    && (strm >> stru.bytes_in())
    && (strm >> stru.messages_ignored())
    && (strm >> stru.bytes_ignored())
    && (strm >> stru.input_processing_time())
    && (strm >> stru.messages_out())
    && (strm >> stru.bytes_out())
    && (strm >> stru.messages_dropped())
    && (strm >> stru.bytes_dropped())
    && (strm >> stru.output_processing_time());
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::ProtocolStatistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.value.messages_in());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.value.bytes_in());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.value.messages_ignored());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.value.bytes_ignored());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.value.input_processing_time());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.value.messages_out());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.value.bytes_out());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.value.messages_dropped());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.value.bytes_dropped());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.value.output_processing_time());
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::ProtocolStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size(encoding, size, stru.value.messages_in());

    if (!strm.write_parameter_id(146649702, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.messages_in())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.value.bytes_in());

    if (!strm.write_parameter_id(257113707, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.bytes_in())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.value.messages_ignored());

    if (!strm.write_parameter_id(256318015, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.messages_ignored())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.value.bytes_ignored());

    if (!strm.write_parameter_id(21653781, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.bytes_ignored())) {
    return false;
  }
    serialized_size(encoding, size, stru.value.input_processing_time());

    if (!strm.write_parameter_id(133473638, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.input_processing_time())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.value.messages_out());

    if (!strm.write_parameter_id(216241791, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.messages_out())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.value.bytes_out());

    if (!strm.write_parameter_id(20755121, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.bytes_out())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.value.messages_dropped());

    if (!strm.write_parameter_id(71676468, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.messages_dropped())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.value.bytes_dropped());

    if (!strm.write_parameter_id(266701231, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.bytes_dropped())) {
    return false;
  }
    serialized_size(encoding, size, stru.value.output_processing_time());

    if (!strm.write_parameter_id(201631001, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.output_processing_time())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.value.messages_in())
    && (strm << stru.value.bytes_in())
    && (strm << stru.value.messages_ignored())
    && (strm << stru.value.bytes_ignored())
    && (strm << stru.value.input_processing_time())
    && (strm << stru.value.messages_out())
    && (strm << stru.value.bytes_out())
    && (strm << stru.value.messages_dropped())
    && (strm << stru.value.bytes_dropped())
    && (strm << stru.value.output_processing_time());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::ProtocolStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 146649702: {
        if (!(strm >> stru.value.messages_in())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 257113707: {
        if (!(strm >> stru.value.bytes_in())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 256318015: {
        if (!(strm >> stru.value.messages_ignored())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 21653781: {
        if (!(strm >> stru.value.bytes_ignored())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 133473638: {
        if (!(strm >> stru.value.input_processing_time())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 216241791: {
        if (!(strm >> stru.value.messages_out())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 20755121: {
        if (!(strm >> stru.value.bytes_out())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 71676468: {
        if (!(strm >> stru.value.messages_dropped())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 266701231: {
        if (!(strm >> stru.value.bytes_dropped())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 201631001: {
        if (!(strm >> stru.value.output_processing_time())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const NestedKeyOnly< ::RtpsRelay::ProtocolStatistics>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.value.messages_in())
    && (strm >> stru.value.bytes_in())
    && (strm >> stru.value.messages_ignored())
    && (strm >> stru.value.bytes_ignored())
    && (strm >> stru.value.input_processing_time())
    && (strm >> stru.value.messages_out())
    && (strm >> stru.value.bytes_out())
    && (strm >> stru.value.messages_dropped())
    && (strm >> stru.value.bytes_dropped())
    && (strm >> stru.value.output_processing_time());
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::ProtocolStatistics> : MetaStruct {
  typedef  ::RtpsRelay::ProtocolStatistics T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("messages_in", 146649702),
      std::make_pair("bytes_in", 257113707),
      std::make_pair("messages_ignored", 256318015),
      std::make_pair("bytes_ignored", 21653781),
      std::make_pair("input_processing_time", 133473638),
      std::make_pair("messages_out", 216241791),
      std::make_pair("bytes_out", 20755121),
      std::make_pair("messages_dropped", 71676468),
      std::make_pair("bytes_dropped", 266701231),
      std::make_pair("output_processing_time", 201631001),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 10);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ProtocolStatistics)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::ProtocolStatistics& typed = *static_cast<const  ::RtpsRelay::ProtocolStatistics*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "messages_in") == 0) {
      return typed.messages_in();
    }
    if (std::strcmp(field, "bytes_in") == 0) {
      return typed.bytes_in();
    }
    if (std::strcmp(field, "messages_ignored") == 0) {
      return typed.messages_ignored();
    }
    if (std::strcmp(field, "bytes_ignored") == 0) {
      return typed.bytes_ignored();
    }
    if (std::strncmp(field, "input_processing_time.", 22) == 0) {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(&typed._input_processing_time, field + 22);
    }
    if (std::strcmp(field, "messages_out") == 0) {
      return typed.messages_out();
    }
    if (std::strcmp(field, "bytes_out") == 0) {
      return typed.bytes_out();
    }
    if (std::strcmp(field, "messages_dropped") == 0) {
      return typed.messages_dropped();
    }
    if (std::strcmp(field, "bytes_dropped") == 0) {
      return typed.bytes_dropped();
    }
    if (std::strncmp(field, "output_processing_time.", 23) == 0) {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(&typed._output_processing_time, field + 23);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ProtocolStatistics)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
      unsigned field_id = map_name_to_id(base_field.c_str());
      ACE_UNUSED_ARG(field_id);
      unsigned member_id;
      size_t field_size;
      const size_t end_of_struct = strm.rpos() + total_size;
      while (true) {
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
          break;
        }
        bool must_understand = false;
        if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " Deserialization Error for struct  ::RtpsRelay::ProtocolStatistics");
        }
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::RtpsRelay::ProtocolStatistics");
        }
        const size_t end_of_field = strm.rpos() + field_size;
        ACE_UNUSED_ARG(end_of_field);

        switch (member_id) {
        case 146649702: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'messages_in' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 257113707: {
          if (field_id == member_id) {
            ACE_CDR::ULongLong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'bytes_in' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 256318015: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'messages_ignored' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 21653781: {
          if (field_id == member_id) {
            ACE_CDR::ULongLong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'bytes_ignored' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 133473638: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 216241791: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'messages_out' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 20755121: {
          if (field_id == member_id) {
            ACE_CDR::ULongLong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'bytes_out' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 71676468: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'messages_dropped' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 266701231: {
          if (field_id == member_id) {
            ACE_CDR::ULongLong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'bytes_dropped' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 201631001: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        default:
          if (must_understand) {
            if (DCPS_debug_level >= 8) {
              ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::ProtocolStatistics\n"), member_id));
            }
            throw std::runtime_error("member id did not exist in getValue");
          }
          strm.skip(field_size);
          break;
        }
      }
      if (!field[0]) {
        return 0;
      }
      throw std::runtime_error("Did not find field in getValue");
    }
    if (base_field == "messages_in") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'messages_in' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'messages_in' could not be skipped");
      }
    }
    if (base_field == "bytes_in") {
      ACE_CDR::ULongLong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'bytes_in' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'bytes_in' could not be skipped");
      }
    }
    if (base_field == "messages_ignored") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'messages_ignored' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'messages_ignored' could not be skipped");
      }
    }
    if (base_field == "bytes_ignored") {
      ACE_CDR::ULongLong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'bytes_ignored' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'bytes_ignored' could not be skipped");
      }
    }
    if (base_field == "input_processing_time") {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::Duration_t*>(0))) {
        throw std::runtime_error("Field 'input_processing_time' could not be skipped");
      }
    }
    if (base_field == "messages_out") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'messages_out' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'messages_out' could not be skipped");
      }
    }
    if (base_field == "bytes_out") {
      ACE_CDR::ULongLong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'bytes_out' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'bytes_out' could not be skipped");
      }
    }
    if (base_field == "messages_dropped") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'messages_dropped' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'messages_dropped' could not be skipped");
      }
    }
    if (base_field == "bytes_dropped") {
      ACE_CDR::ULongLong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'bytes_dropped' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  8 )) {
        throw std::runtime_error("Field 'bytes_dropped' could not be skipped");
      }
    }
    if (base_field == "output_processing_time") {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::Duration_t*>(0))) {
        throw std::runtime_error("Field 'output_processing_time' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "messages_in") == 0) {
      return make_field_cmp(&T::_messages_in, next);
    }
    if (std::strcmp(field, "bytes_in") == 0) {
      return make_field_cmp(&T::_bytes_in, next);
    }
    if (std::strcmp(field, "messages_ignored") == 0) {
      return make_field_cmp(&T::_messages_ignored, next);
    }
    if (std::strcmp(field, "bytes_ignored") == 0) {
      return make_field_cmp(&T::_bytes_ignored, next);
    }
    if (std::strncmp(field, "input_processing_time.", 22) == 0) {
      return make_struct_cmp(&T::_input_processing_time, getMetaStruct< ::RtpsRelay::Duration_t>().create_qc_comparator(field + 22), next);
    }
    if (std::strcmp(field, "messages_out") == 0) {
      return make_field_cmp(&T::_messages_out, next);
    }
    if (std::strcmp(field, "bytes_out") == 0) {
      return make_field_cmp(&T::_bytes_out, next);
    }
    if (std::strcmp(field, "messages_dropped") == 0) {
      return make_field_cmp(&T::_messages_dropped, next);
    }
    if (std::strcmp(field, "bytes_dropped") == 0) {
      return make_field_cmp(&T::_bytes_dropped, next);
    }
    if (std::strncmp(field, "output_processing_time.", 23) == 0) {
      return make_struct_cmp(&T::_output_processing_time, getMetaStruct< ::RtpsRelay::Duration_t>().create_qc_comparator(field + 23), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ProtocolStatistics)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"messages_in", "bytes_in", "messages_ignored", "bytes_ignored", "input_processing_time", "messages_out", "bytes_out", "messages_dropped", "bytes_dropped", "output_processing_time", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "messages_in") == 0) {
      return &static_cast<const T*>(stru)->_messages_in;
    }
    if (std::strcmp(field, "bytes_in") == 0) {
      return &static_cast<const T*>(stru)->_bytes_in;
    }
    if (std::strcmp(field, "messages_ignored") == 0) {
      return &static_cast<const T*>(stru)->_messages_ignored;
    }
    if (std::strcmp(field, "bytes_ignored") == 0) {
      return &static_cast<const T*>(stru)->_bytes_ignored;
    }
    if (std::strcmp(field, "input_processing_time") == 0) {
      return &static_cast<const T*>(stru)->_input_processing_time;
    }
    if (std::strcmp(field, "messages_out") == 0) {
      return &static_cast<const T*>(stru)->_messages_out;
    }
    if (std::strcmp(field, "bytes_out") == 0) {
      return &static_cast<const T*>(stru)->_bytes_out;
    }
    if (std::strcmp(field, "messages_dropped") == 0) {
      return &static_cast<const T*>(stru)->_messages_dropped;
    }
    if (std::strcmp(field, "bytes_dropped") == 0) {
      return &static_cast<const T*>(stru)->_bytes_dropped;
    }
    if (std::strcmp(field, "output_processing_time") == 0) {
      return &static_cast<const T*>(stru)->_output_processing_time;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ProtocolStatistics)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "messages_in") == 0) {
      static_cast<T*>(lhs)->_messages_in = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bytes_in") == 0) {
      static_cast<T*>(lhs)->_bytes_in = *static_cast<const  ::CORBA::ULongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "messages_ignored") == 0) {
      static_cast<T*>(lhs)->_messages_ignored = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bytes_ignored") == 0) {
      static_cast<T*>(lhs)->_bytes_ignored = *static_cast<const  ::CORBA::ULongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "input_processing_time") == 0) {
      static_cast<T*>(lhs)->_input_processing_time = *static_cast<const  ::RtpsRelay::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "messages_out") == 0) {
      static_cast<T*>(lhs)->_messages_out = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bytes_out") == 0) {
      static_cast<T*>(lhs)->_bytes_out = *static_cast<const  ::CORBA::ULongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "messages_dropped") == 0) {
      static_cast<T*>(lhs)->_messages_dropped = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bytes_dropped") == 0) {
      static_cast<T*>(lhs)->_bytes_dropped = *static_cast<const  ::CORBA::ULongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "output_processing_time") == 0) {
      static_cast<T*>(lhs)->_output_processing_time = *static_cast<const  ::RtpsRelay::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ProtocolStatistics)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "messages_in") == 0) {
      return static_cast<const T*>(lhs)->_messages_in == static_cast<const T*>(rhs)->_messages_in;
    }
    if (std::strcmp(field, "bytes_in") == 0) {
      return static_cast<const T*>(lhs)->_bytes_in == static_cast<const T*>(rhs)->_bytes_in;
    }
    if (std::strcmp(field, "messages_ignored") == 0) {
      return static_cast<const T*>(lhs)->_messages_ignored == static_cast<const T*>(rhs)->_messages_ignored;
    }
    if (std::strcmp(field, "bytes_ignored") == 0) {
      return static_cast<const T*>(lhs)->_bytes_ignored == static_cast<const T*>(rhs)->_bytes_ignored;
    }
    if (std::strcmp(field, "messages_out") == 0) {
      return static_cast<const T*>(lhs)->_messages_out == static_cast<const T*>(rhs)->_messages_out;
    }
    if (std::strcmp(field, "bytes_out") == 0) {
      return static_cast<const T*>(lhs)->_bytes_out == static_cast<const T*>(rhs)->_bytes_out;
    }
    if (std::strcmp(field, "messages_dropped") == 0) {
      return static_cast<const T*>(lhs)->_messages_dropped == static_cast<const T*>(rhs)->_messages_dropped;
    }
    if (std::strcmp(field, "bytes_dropped") == 0) {
      return static_cast<const T*>(lhs)->_bytes_dropped == static_cast<const T*>(rhs)->_bytes_dropped;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ProtocolStatistics)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::ProtocolStatistics>()
{
  static MetaStructImpl< ::RtpsRelay::ProtocolStatistics> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::ProtocolStatistics*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::ProtocolStatistics>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
ProtocolStatistics::ProtocolStatistics(uint32_t messages_in,
    uint64_t bytes_in,
    uint32_t messages_ignored,
    uint64_t bytes_ignored,
    const  ::RtpsRelay::Duration_t& input_processing_time,
    uint32_t messages_out,
    uint64_t bytes_out,
    uint32_t messages_dropped,
    uint64_t bytes_dropped,
    const  ::RtpsRelay::Duration_t& output_processing_time)
  : _messages_in(messages_in)
  , _bytes_in(bytes_in)
  , _messages_ignored(messages_ignored)
  , _bytes_ignored(bytes_ignored)
  , _input_processing_time(input_processing_time)
  , _messages_out(messages_out)
  , _bytes_out(bytes_out)
  , _messages_dropped(messages_dropped)
  , _bytes_dropped(bytes_dropped)
  , _output_processing_time(output_processing_time)
{}

void swap(ProtocolStatistics& lhs, ProtocolStatistics& rhs)
{
  using std::swap;
  swap(lhs._messages_in, rhs._messages_in);
  swap(lhs._bytes_in, rhs._bytes_in);
  swap(lhs._messages_ignored, rhs._messages_ignored);
  swap(lhs._bytes_ignored, rhs._bytes_ignored);
  swap(lhs._input_processing_time, rhs._input_processing_time);
  swap(lhs._messages_out, rhs._messages_out);
  swap(lhs._bytes_out, rhs._bytes_out);
  swap(lhs._messages_dropped, rhs._messages_dropped);
  swap(lhs._bytes_dropped, rhs._bytes_dropped);
  swap(lhs._output_processing_time, rhs._output_processing_time);
}

}

/* End STRUCT: ProtocolStatistics */


/* Begin CONST: PARTICIPANT_STATISTICS_TOPIC_NAME */


/* End CONST: PARTICIPANT_STATISTICS_TOPIC_NAME */


/* Begin STRUCT: ParticipantStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_ParticipantStatistics_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(136, 97, 254, 8, 10, 7, 82, 97, 214, 72, 61, 0, 18, 55));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_ParticipantStatistics_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::ParticipantStatistics& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"guid",27593758},{"name",210987184},{"session_time",101278124},{"rtps",23054614},{"stun",80367312},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 27593758: {
      if (!vread(value_reader, value.guid())) return false;
      break;
    }
    case 210987184: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.name() = x;
      }
      break;
    }
    case 101278124: {
      if (!vread(value_reader, value.session_time())) return false;
      break;
    }
    case 23054614: {
      if (!vread(value_reader, value.rtps())) return false;
      break;
    }
    case 80367312: {
      if (!vread(value_reader, value.stun())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::ParticipantStatistics& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("guid");
  vwrite(value_writer, value.guid());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("name");
  value_writer.write_string(value.name());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("session_time");
  vwrite(value_writer, value.session_time());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("rtps");
  vwrite(value_writer, value.rtps());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("stun");
  vwrite(value_writer, value.stun());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::ParticipantStatistics& stru)
{
  ACE_UNUSED_ARG(stru);
  set_default(stru.guid());
  stru.name() = "";
  set_default(stru.session_time());
  set_default(stru.rtps());
  set_default(stru.stun());
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::ParticipantStatistics& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.guid());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.name().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.session_time());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.rtps());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.stun());
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::ParticipantStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    serialized_size(encoding, size, stru.guid());

    if (!strm.write_parameter_id(27593758, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.guid())) {
    return false;
  }
    primitive_serialized_size_ulong(encoding, size);
    size += stru.name().size() + 1;

    if (!strm.write_parameter_id(210987184, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.name())) {
    return false;
  }
    serialized_size(encoding, size, stru.session_time());

    if (!strm.write_parameter_id(101278124, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.session_time())) {
    return false;
  }
    serialized_size(encoding, size, stru.rtps());

    if (!strm.write_parameter_id(23054614, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.rtps())) {
    return false;
  }
    serialized_size(encoding, size, stru.stun());

    if (!strm.write_parameter_id(80367312, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.stun())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.guid())
    && (strm << stru.name())
    && (strm << stru.session_time())
    && (strm << stru.rtps())
    && (strm << stru.stun());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::ParticipantStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 27593758: {
        if (!(strm >> stru.guid())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 210987184: {
        if (!(strm >> stru.name())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 101278124: {
        if (!(strm >> stru.session_time())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 23054614: {
        if (!(strm >> stru.rtps())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 80367312: {
        if (!(strm >> stru.stun())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::ParticipantStatistics\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.guid())
    && (strm >> stru.name())
    && (strm >> stru.session_time())
    && (strm >> stru.rtps())
    && (strm >> stru.stun());
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::ParticipantStatistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.name().size() + 1;
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::ParticipantStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));

    if (!strm.write_parameter_id(27593758, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()))) {
    return false;
  }
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.name().size() + 1;

    if (!strm.write_parameter_id(210987184, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.name())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()))
    && (strm << stru.value.name());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::ParticipantStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
      switch (member_id) {
      case 27593758: {
        if (!(strm >> stru_value_guid_nested_key_only)) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 210987184: {
        if (!(strm >> stru.value.name())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const NestedKeyOnly< ::RtpsRelay::ParticipantStatistics>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
  return (strm >> stru_value_guid_nested_key_only)
    && (strm >> stru.value.name());
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::RtpsRelay::ParticipantStatistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.name().size() + 1;
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::RtpsRelay::ParticipantStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    serialized_size(encoding, size, NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()));

    if (!strm.write_parameter_id(27593758, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()))) {
    return false;
  }
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.name().size() + 1;

    if (!strm.write_parameter_id(210987184, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.name())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << NestedKeyOnly<const  ::RtpsRelay::GUID_t>(stru.value.guid()))
    && (strm << stru.value.name());
}

bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::ParticipantStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
      switch (member_id) {
      case 27593758: {
        if (!(strm >> stru_value_guid_nested_key_only)) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 210987184: {
        if (!(strm >> stru.value.name())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const KeyOnly< ::RtpsRelay::ParticipantStatistics>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  NestedKeyOnly< ::RtpsRelay::GUID_t> stru_value_guid_nested_key_only(stru.value.guid());
  return (strm >> stru_value_guid_nested_key_only)
    && (strm >> stru.value.name());
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
::DDS::DataWriter_ptr ParticipantStatisticsTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ParticipantStatistics> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr ParticipantStatisticsTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantStatistics> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ParticipantStatisticsTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantStatistics> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ParticipantStatistics, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ParticipantStatisticsTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ParticipantStatistics>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool ParticipantStatisticsTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* ParticipantStatisticsTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void ParticipantStatisticsTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& ParticipantStatisticsTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::RtpsRelay_ParticipantStatistics_xtag>();
}

const OpenDDS::XTypes::TypeMap& ParticipantStatisticsTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::RtpsRelay_ParticipantStatistics_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& ParticipantStatisticsTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& ParticipantStatisticsTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility ParticipantStatisticsTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

ParticipantStatisticsTypeSupport::_ptr_type ParticipantStatisticsTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::ParticipantStatistics> : MetaStruct {
  typedef  ::RtpsRelay::ParticipantStatistics T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 17; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[3]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[4]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[5]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[6]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[7]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[8]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[9]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[10]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.guidPrefix[11]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.entityId.entityKey[0]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.entityId.entityKey[1]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.entityId.entityKey[2]")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "guid.entityId.entityKind")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "name")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("guid", 27593758),
      std::make_pair("name", 210987184),
      std::make_pair("session_time", 101278124),
      std::make_pair("rtps", 23054614),
      std::make_pair("stun", 80367312),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 5);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ParticipantStatistics)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::ParticipantStatistics& typed = *static_cast<const  ::RtpsRelay::ParticipantStatistics*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "guid.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::GUID_t>().getValue(&typed._guid, field + 5);
    }
    if (std::strcmp(field, "name") == 0) {
      return typed.name();
    }
    if (std::strncmp(field, "session_time.", 13) == 0) {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(&typed._session_time, field + 13);
    }
    if (std::strncmp(field, "rtps.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(&typed._rtps, field + 5);
    }
    if (std::strncmp(field, "stun.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(&typed._stun, field + 5);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ParticipantStatistics)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
      unsigned field_id = map_name_to_id(base_field.c_str());
      ACE_UNUSED_ARG(field_id);
      unsigned member_id;
      size_t field_size;
      const size_t end_of_struct = strm.rpos() + total_size;
      while (true) {
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
          break;
        }
        bool must_understand = false;
        if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " Deserialization Error for struct  ::RtpsRelay::ParticipantStatistics");
        }
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::RtpsRelay::ParticipantStatistics");
        }
        const size_t end_of_field = strm.rpos() + field_size;
        ACE_UNUSED_ARG(end_of_field);

        switch (member_id) {
        case 27593758: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::GUID_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 210987184: {
          if (field_id == member_id) {
            std::string val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'name' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 101278124: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 23054614: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 80367312: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        default:
          if (must_understand) {
            if (DCPS_debug_level >= 8) {
              ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::ParticipantStatistics\n"), member_id));
            }
            throw std::runtime_error("member id did not exist in getValue");
          }
          strm.skip(field_size);
          break;
        }
      }
      if (!field[0]) {
        return 0;
      }
      throw std::runtime_error("Did not find field in getValue");
    }
    if (base_field == "guid") {
      return getMetaStruct< ::RtpsRelay::GUID_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::GUID_t*>(0))) {
        throw std::runtime_error("Field 'guid' could not be skipped");
      }
    }
    if (base_field == "name") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (base_field == "session_time") {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::Duration_t*>(0))) {
        throw std::runtime_error("Field 'session_time' could not be skipped");
      }
    }
    if (base_field == "rtps") {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::ProtocolStatistics*>(0))) {
        throw std::runtime_error("Field 'rtps' could not be skipped");
      }
    }
    if (base_field == "stun") {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::ProtocolStatistics*>(0))) {
        throw std::runtime_error("Field 'stun' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "guid.", 5) == 0) {
      return make_struct_cmp(&T::_guid, getMetaStruct< ::RtpsRelay::GUID_t>().create_qc_comparator(field + 5), next);
    }
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::_name, next);
    }
    if (std::strncmp(field, "session_time.", 13) == 0) {
      return make_struct_cmp(&T::_session_time, getMetaStruct< ::RtpsRelay::Duration_t>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "rtps.", 5) == 0) {
      return make_struct_cmp(&T::_rtps, getMetaStruct< ::RtpsRelay::ProtocolStatistics>().create_qc_comparator(field + 5), next);
    }
    if (std::strncmp(field, "stun.", 5) == 0) {
      return make_struct_cmp(&T::_stun, getMetaStruct< ::RtpsRelay::ProtocolStatistics>().create_qc_comparator(field + 5), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ParticipantStatistics)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"guid", "name", "session_time", "rtps", "stun", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "guid") == 0) {
      return &static_cast<const T*>(stru)->_guid;
    }
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->_name;
    }
    if (std::strcmp(field, "session_time") == 0) {
      return &static_cast<const T*>(stru)->_session_time;
    }
    if (std::strcmp(field, "rtps") == 0) {
      return &static_cast<const T*>(stru)->_rtps;
    }
    if (std::strcmp(field, "stun") == 0) {
      return &static_cast<const T*>(stru)->_stun;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ParticipantStatistics)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "guid") == 0) {
      static_cast<T*>(lhs)->_guid = *static_cast<const  ::RtpsRelay::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->_name = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "session_time") == 0) {
      static_cast<T*>(lhs)->_session_time = *static_cast<const  ::RtpsRelay::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "rtps") == 0) {
      static_cast<T*>(lhs)->_rtps = *static_cast<const  ::RtpsRelay::ProtocolStatistics*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "stun") == 0) {
      static_cast<T*>(lhs)->_stun = *static_cast<const  ::RtpsRelay::ProtocolStatistics*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ParticipantStatistics)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return static_cast<const T*>(lhs)->_name == static_cast<const T*>(rhs)->_name;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::ParticipantStatistics)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::ParticipantStatistics>()
{
  static MetaStructImpl< ::RtpsRelay::ParticipantStatistics> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::ParticipantStatistics*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::ParticipantStatistics>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
ParticipantStatistics::ParticipantStatistics(const  ::RtpsRelay::GUID_t& guid,
    const std::string& name,
    const  ::RtpsRelay::Duration_t& session_time,
    const  ::RtpsRelay::ProtocolStatistics& rtps,
    const  ::RtpsRelay::ProtocolStatistics& stun)
  : _guid(guid)
  , _name(name)
  , _session_time(session_time)
  , _rtps(rtps)
  , _stun(stun)
{}

void swap(ParticipantStatistics& lhs, ParticipantStatistics& rhs)
{
  using std::swap;
  swap(lhs._guid, rhs._guid);
  swap(lhs._name, rhs._name);
  swap(lhs._session_time, rhs._session_time);
  swap(lhs._rtps, rhs._rtps);
  swap(lhs._stun, rhs._stun);
}

}

/* End STRUCT: ParticipantStatistics */


/* Begin CONST: HANDLER_STATISTICS_TOPIC_NAME */


/* End CONST: HANDLER_STATISTICS_TOPIC_NAME */


/* Begin STRUCT: HandlerStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_HandlerStatistics_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(71, 157, 116, 45, 116, 235, 83, 107, 21, 192, 226, 39, 164, 162));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_HandlerStatistics_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::HandlerStatistics& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"relay_id",52683514},{"name",210987184},{"interval",258859474},{"rtps",23054614},{"stun",80367312},{"max_gain",103250334},{"error_count",139299553},{"max_queue_size",87684088},{"max_queue_latency",197940087},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 52683514: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relay_id() = x;
      }
      break;
    }
    case 210987184: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.name() = x;
      }
      break;
    }
    case 258859474: {
      if (!vread(value_reader, value.interval())) return false;
      break;
    }
    case 23054614: {
      if (!vread(value_reader, value.rtps())) return false;
      break;
    }
    case 80367312: {
      if (!vread(value_reader, value.stun())) return false;
      break;
    }
    case 103250334: {
      if (!value_reader.read_uint32(value.max_gain())) return false;
      break;
    }
    case 139299553: {
      if (!value_reader.read_uint32(value.error_count())) return false;
      break;
    }
    case 87684088: {
      if (!value_reader.read_uint32(value.max_queue_size())) return false;
      break;
    }
    case 197940087: {
      if (!vread(value_reader, value.max_queue_latency())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::HandlerStatistics& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("relay_id");
  value_writer.write_string(value.relay_id());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("name");
  value_writer.write_string(value.name());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("interval");
  vwrite(value_writer, value.interval());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("rtps");
  vwrite(value_writer, value.rtps());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("stun");
  vwrite(value_writer, value.stun());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_gain");
  value_writer.write_uint32(value.max_gain());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("error_count");
  value_writer.write_uint32(value.error_count());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_queue_size");
  value_writer.write_uint32(value.max_queue_size());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_queue_latency");
  vwrite(value_writer, value.max_queue_latency());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::HandlerStatistics& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.relay_id() = "";
  stru.name() = "";
  set_default(stru.interval());
  set_default(stru.rtps());
  set_default(stru.stun());
  stru.max_gain() = 0;
  stru.error_count() = 0;
  stru.max_queue_size() = 0;
  set_default(stru.max_queue_latency());
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::HandlerStatistics& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.relay_id().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.name().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.interval());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.rtps());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.stun());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.max_gain());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.error_count());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.max_queue_size());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.max_queue_latency());
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::HandlerStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.relay_id())) {
    return false;
  }
    primitive_serialized_size_ulong(encoding, size);
    size += stru.name().size() + 1;

    if (!strm.write_parameter_id(210987184, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.name())) {
    return false;
  }
    serialized_size(encoding, size, stru.interval());

    if (!strm.write_parameter_id(258859474, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.interval())) {
    return false;
  }
    serialized_size(encoding, size, stru.rtps());

    if (!strm.write_parameter_id(23054614, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.rtps())) {
    return false;
  }
    serialized_size(encoding, size, stru.stun());

    if (!strm.write_parameter_id(80367312, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.stun())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.max_gain());

    if (!strm.write_parameter_id(103250334, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.max_gain())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.error_count());

    if (!strm.write_parameter_id(139299553, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.error_count())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.max_queue_size());

    if (!strm.write_parameter_id(87684088, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.max_queue_size())) {
    return false;
  }
    serialized_size(encoding, size, stru.max_queue_latency());

    if (!strm.write_parameter_id(197940087, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.max_queue_latency())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.relay_id())
    && (strm << stru.name())
    && (strm << stru.interval())
    && (strm << stru.rtps())
    && (strm << stru.stun())
    && (strm << stru.max_gain())
    && (strm << stru.error_count())
    && (strm << stru.max_queue_size())
    && (strm << stru.max_queue_latency());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::HandlerStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 210987184: {
        if (!(strm >> stru.name())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 258859474: {
        if (!(strm >> stru.interval())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 23054614: {
        if (!(strm >> stru.rtps())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 80367312: {
        if (!(strm >> stru.stun())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 103250334: {
        if (!(strm >> stru.max_gain())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 139299553: {
        if (!(strm >> stru.error_count())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 87684088: {
        if (!(strm >> stru.max_queue_size())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 197940087: {
        if (!(strm >> stru.max_queue_latency())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::HandlerStatistics\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.relay_id())
    && (strm >> stru.name())
    && (strm >> stru.interval())
    && (strm >> stru.rtps())
    && (strm >> stru.stun())
    && (strm >> stru.max_gain())
    && (strm >> stru.error_count())
    && (strm >> stru.max_queue_size())
    && (strm >> stru.max_queue_latency());
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::HandlerStatistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.name().size() + 1;
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::HandlerStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.relay_id())) {
    return false;
  }
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.name().size() + 1;

    if (!strm.write_parameter_id(210987184, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.name())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.value.relay_id())
    && (strm << stru.value.name());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::HandlerStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.value.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 210987184: {
        if (!(strm >> stru.value.name())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const NestedKeyOnly< ::RtpsRelay::HandlerStatistics>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.value.relay_id())
    && (strm >> stru.value.name());
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::RtpsRelay::HandlerStatistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.name().size() + 1;
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::RtpsRelay::HandlerStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.relay_id())) {
    return false;
  }
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.name().size() + 1;

    if (!strm.write_parameter_id(210987184, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.name())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.value.relay_id())
    && (strm << stru.value.name());
}

bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::HandlerStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.value.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 210987184: {
        if (!(strm >> stru.value.name())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const KeyOnly< ::RtpsRelay::HandlerStatistics>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.value.relay_id())
    && (strm >> stru.value.name());
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
::DDS::DataWriter_ptr HandlerStatisticsTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<HandlerStatistics> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr HandlerStatisticsTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<HandlerStatistics> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr HandlerStatisticsTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<HandlerStatistics> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<HandlerStatistics, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& HandlerStatisticsTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<HandlerStatistics>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool HandlerStatisticsTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* HandlerStatisticsTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void HandlerStatisticsTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& HandlerStatisticsTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::RtpsRelay_HandlerStatistics_xtag>();
}

const OpenDDS::XTypes::TypeMap& HandlerStatisticsTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::RtpsRelay_HandlerStatistics_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& HandlerStatisticsTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& HandlerStatisticsTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility HandlerStatisticsTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

HandlerStatisticsTypeSupport::_ptr_type HandlerStatisticsTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::HandlerStatistics> : MetaStruct {
  typedef  ::RtpsRelay::HandlerStatistics T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 2; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "relay_id")) {
      return true;
    }
    if (!ACE_OS::strcmp(field, "name")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("relay_id", 52683514),
      std::make_pair("name", 210987184),
      std::make_pair("interval", 258859474),
      std::make_pair("rtps", 23054614),
      std::make_pair("stun", 80367312),
      std::make_pair("max_gain", 103250334),
      std::make_pair("error_count", 139299553),
      std::make_pair("max_queue_size", 87684088),
      std::make_pair("max_queue_latency", 197940087),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 9);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::HandlerStatistics)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::HandlerStatistics& typed = *static_cast<const  ::RtpsRelay::HandlerStatistics*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "relay_id") == 0) {
      return typed.relay_id();
    }
    if (std::strcmp(field, "name") == 0) {
      return typed.name();
    }
    if (std::strncmp(field, "interval.", 9) == 0) {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(&typed._interval, field + 9);
    }
    if (std::strncmp(field, "rtps.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(&typed._rtps, field + 5);
    }
    if (std::strncmp(field, "stun.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(&typed._stun, field + 5);
    }
    if (std::strcmp(field, "max_gain") == 0) {
      return typed.max_gain();
    }
    if (std::strcmp(field, "error_count") == 0) {
      return typed.error_count();
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      return typed.max_queue_size();
    }
    if (std::strncmp(field, "max_queue_latency.", 18) == 0) {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(&typed._max_queue_latency, field + 18);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::HandlerStatistics)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
      unsigned field_id = map_name_to_id(base_field.c_str());
      ACE_UNUSED_ARG(field_id);
      unsigned member_id;
      size_t field_size;
      const size_t end_of_struct = strm.rpos() + total_size;
      while (true) {
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
          break;
        }
        bool must_understand = false;
        if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " Deserialization Error for struct  ::RtpsRelay::HandlerStatistics");
        }
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::RtpsRelay::HandlerStatistics");
        }
        const size_t end_of_field = strm.rpos() + field_size;
        ACE_UNUSED_ARG(end_of_field);

        switch (member_id) {
        case 52683514: {
          if (field_id == member_id) {
            std::string val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'relay_id' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 210987184: {
          if (field_id == member_id) {
            std::string val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'name' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 258859474: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 23054614: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 80367312: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 103250334: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'max_gain' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 139299553: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'error_count' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 87684088: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'max_queue_size' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 197940087: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        default:
          if (must_understand) {
            if (DCPS_debug_level >= 8) {
              ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::HandlerStatistics\n"), member_id));
            }
            throw std::runtime_error("member id did not exist in getValue");
          }
          strm.skip(field_size);
          break;
        }
      }
      if (!field[0]) {
        return 0;
      }
      throw std::runtime_error("Did not find field in getValue");
    }
    if (base_field == "relay_id") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'relay_id' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relay_id' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relay_id' contents could not be skipped");
      }
    }
    if (base_field == "name") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (base_field == "interval") {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::Duration_t*>(0))) {
        throw std::runtime_error("Field 'interval' could not be skipped");
      }
    }
    if (base_field == "rtps") {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::ProtocolStatistics*>(0))) {
        throw std::runtime_error("Field 'rtps' could not be skipped");
      }
    }
    if (base_field == "stun") {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::ProtocolStatistics*>(0))) {
        throw std::runtime_error("Field 'stun' could not be skipped");
      }
    }
    if (base_field == "max_gain") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_gain' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_gain' could not be skipped");
      }
    }
    if (base_field == "error_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'error_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'error_count' could not be skipped");
      }
    }
    if (base_field == "max_queue_size") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_queue_size' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_queue_size' could not be skipped");
      }
    }
    if (base_field == "max_queue_latency") {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::Duration_t*>(0))) {
        throw std::runtime_error("Field 'max_queue_latency' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "relay_id") == 0) {
      return make_field_cmp(&T::_relay_id, next);
    }
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::_name, next);
    }
    if (std::strncmp(field, "interval.", 9) == 0) {
      return make_struct_cmp(&T::_interval, getMetaStruct< ::RtpsRelay::Duration_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "rtps.", 5) == 0) {
      return make_struct_cmp(&T::_rtps, getMetaStruct< ::RtpsRelay::ProtocolStatistics>().create_qc_comparator(field + 5), next);
    }
    if (std::strncmp(field, "stun.", 5) == 0) {
      return make_struct_cmp(&T::_stun, getMetaStruct< ::RtpsRelay::ProtocolStatistics>().create_qc_comparator(field + 5), next);
    }
    if (std::strcmp(field, "max_gain") == 0) {
      return make_field_cmp(&T::_max_gain, next);
    }
    if (std::strcmp(field, "error_count") == 0) {
      return make_field_cmp(&T::_error_count, next);
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      return make_field_cmp(&T::_max_queue_size, next);
    }
    if (std::strncmp(field, "max_queue_latency.", 18) == 0) {
      return make_struct_cmp(&T::_max_queue_latency, getMetaStruct< ::RtpsRelay::Duration_t>().create_qc_comparator(field + 18), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::HandlerStatistics)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"relay_id", "name", "interval", "rtps", "stun", "max_gain", "error_count", "max_queue_size", "max_queue_latency", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "relay_id") == 0) {
      return &static_cast<const T*>(stru)->_relay_id;
    }
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->_name;
    }
    if (std::strcmp(field, "interval") == 0) {
      return &static_cast<const T*>(stru)->_interval;
    }
    if (std::strcmp(field, "rtps") == 0) {
      return &static_cast<const T*>(stru)->_rtps;
    }
    if (std::strcmp(field, "stun") == 0) {
      return &static_cast<const T*>(stru)->_stun;
    }
    if (std::strcmp(field, "max_gain") == 0) {
      return &static_cast<const T*>(stru)->_max_gain;
    }
    if (std::strcmp(field, "error_count") == 0) {
      return &static_cast<const T*>(stru)->_error_count;
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      return &static_cast<const T*>(stru)->_max_queue_size;
    }
    if (std::strcmp(field, "max_queue_latency") == 0) {
      return &static_cast<const T*>(stru)->_max_queue_latency;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::HandlerStatistics)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "relay_id") == 0) {
      static_cast<T*>(lhs)->_relay_id = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->_name = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "interval") == 0) {
      static_cast<T*>(lhs)->_interval = *static_cast<const  ::RtpsRelay::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "rtps") == 0) {
      static_cast<T*>(lhs)->_rtps = *static_cast<const  ::RtpsRelay::ProtocolStatistics*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "stun") == 0) {
      static_cast<T*>(lhs)->_stun = *static_cast<const  ::RtpsRelay::ProtocolStatistics*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_gain") == 0) {
      static_cast<T*>(lhs)->_max_gain = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "error_count") == 0) {
      static_cast<T*>(lhs)->_error_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      static_cast<T*>(lhs)->_max_queue_size = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_queue_latency") == 0) {
      static_cast<T*>(lhs)->_max_queue_latency = *static_cast<const  ::RtpsRelay::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::HandlerStatistics)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "relay_id") == 0) {
      return static_cast<const T*>(lhs)->_relay_id == static_cast<const T*>(rhs)->_relay_id;
    }
    if (std::strcmp(field, "name") == 0) {
      return static_cast<const T*>(lhs)->_name == static_cast<const T*>(rhs)->_name;
    }
    if (std::strcmp(field, "max_gain") == 0) {
      return static_cast<const T*>(lhs)->_max_gain == static_cast<const T*>(rhs)->_max_gain;
    }
    if (std::strcmp(field, "error_count") == 0) {
      return static_cast<const T*>(lhs)->_error_count == static_cast<const T*>(rhs)->_error_count;
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      return static_cast<const T*>(lhs)->_max_queue_size == static_cast<const T*>(rhs)->_max_queue_size;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::HandlerStatistics)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::HandlerStatistics>()
{
  static MetaStructImpl< ::RtpsRelay::HandlerStatistics> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::HandlerStatistics*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::HandlerStatistics>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
HandlerStatistics::HandlerStatistics(const std::string& relay_id,
    const std::string& name,
    const  ::RtpsRelay::Duration_t& interval,
    const  ::RtpsRelay::ProtocolStatistics& rtps,
    const  ::RtpsRelay::ProtocolStatistics& stun,
    uint32_t max_gain,
    uint32_t error_count,
    uint32_t max_queue_size,
    const  ::RtpsRelay::Duration_t& max_queue_latency)
  : _relay_id(relay_id)
  , _name(name)
  , _interval(interval)
  , _rtps(rtps)
  , _stun(stun)
  , _max_gain(max_gain)
  , _error_count(error_count)
  , _max_queue_size(max_queue_size)
  , _max_queue_latency(max_queue_latency)
{}

void swap(HandlerStatistics& lhs, HandlerStatistics& rhs)
{
  using std::swap;
  swap(lhs._relay_id, rhs._relay_id);
  swap(lhs._name, rhs._name);
  swap(lhs._interval, rhs._interval);
  swap(lhs._rtps, rhs._rtps);
  swap(lhs._stun, rhs._stun);
  swap(lhs._max_gain, rhs._max_gain);
  swap(lhs._error_count, rhs._error_count);
  swap(lhs._max_queue_size, rhs._max_queue_size);
  swap(lhs._max_queue_latency, rhs._max_queue_latency);
}

}

/* End STRUCT: HandlerStatistics */


/* Begin CONST: RELAY_STATISTICS_TOPIC_NAME */


/* End CONST: RELAY_STATISTICS_TOPIC_NAME */


/* Begin STRUCT: RelayStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayStatistics_xtag>()
{
  static XTypes::TypeIdentifier ti;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), ti);
  if (ti.kind() == XTypes::TK_NONE) {
    ti = XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(70, 79, 187, 18, 204, 170, 180, 133, 243, 59, 87, 186, 17, 243));
  }
  return ti;
}

template<> const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayStatistics_xtag>()
{
  return get_minimal_type_map();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayStatistics& value)
{
  ACE_UNUSED_ARG(value_reader);
  ACE_UNUSED_ARG(value);
  static const ListMemberHelper::Pair pairs[] = {{"relay_id",52683514},{"interval",258859474},{"rtps",23054614},{"stun",80367312},{"max_gain",103250334},{"error_count",139299553},{"local_active_participants",268340515},{"new_address_count",135028760},{"expired_address_count",119852735},{"max_queue_size",87684088},{"max_queue_latency",197940087},{"local_participants",260514907},{"local_writers",150026670},{"local_readers",229080076},{"relay_partitions_pub_count",6490862},{"relay_address_pub_count",43326945},{"spdp_replay_pub_count",16464170},{0,0}};
  ListMemberHelper helper(pairs);
  if (!value_reader.begin_struct()) return false;
  XTypes::MemberId member_id;
  while (value_reader.begin_struct_member(member_id, helper)) {
    switch (member_id) {
    case 52683514: {
      {
        String x;
        if (!value_reader.read_string(x)) return false;
        value.relay_id() = x;
      }
      break;
    }
    case 258859474: {
      if (!vread(value_reader, value.interval())) return false;
      break;
    }
    case 23054614: {
      if (!vread(value_reader, value.rtps())) return false;
      break;
    }
    case 80367312: {
      if (!vread(value_reader, value.stun())) return false;
      break;
    }
    case 103250334: {
      if (!value_reader.read_uint32(value.max_gain())) return false;
      break;
    }
    case 139299553: {
      if (!value_reader.read_uint32(value.error_count())) return false;
      break;
    }
    case 268340515: {
      if (!value_reader.read_uint32(value.local_active_participants())) return false;
      break;
    }
    case 135028760: {
      if (!value_reader.read_uint32(value.new_address_count())) return false;
      break;
    }
    case 119852735: {
      if (!value_reader.read_uint32(value.expired_address_count())) return false;
      break;
    }
    case 87684088: {
      if (!value_reader.read_uint32(value.max_queue_size())) return false;
      break;
    }
    case 197940087: {
      if (!vread(value_reader, value.max_queue_latency())) return false;
      break;
    }
    case 260514907: {
      if (!value_reader.read_uint32(value.local_participants())) return false;
      break;
    }
    case 150026670: {
      if (!value_reader.read_uint32(value.local_writers())) return false;
      break;
    }
    case 229080076: {
      if (!value_reader.read_uint32(value.local_readers())) return false;
      break;
    }
    case 6490862: {
      if (!value_reader.read_uint32(value.relay_partitions_pub_count())) return false;
      break;
    }
    case 43326945: {
      if (!value_reader.read_uint32(value.relay_address_pub_count())) return false;
      break;
    }
    case 16464170: {
      if (!value_reader.read_uint32(value.spdp_replay_pub_count())) return false;
      break;
    }
    }
    if (!value_reader.end_struct_member()) return false;
  }
  if (!value_reader.end_struct()) return false;
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayStatistics& value)
{
  ACE_UNUSED_ARG(value_writer);
  ACE_UNUSED_ARG(value);
  value_writer.begin_struct();
  value_writer.begin_struct_member("relay_id");
  value_writer.write_string(value.relay_id());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("interval");
  vwrite(value_writer, value.interval());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("rtps");
  vwrite(value_writer, value.rtps());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("stun");
  vwrite(value_writer, value.stun());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_gain");
  value_writer.write_uint32(value.max_gain());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("error_count");
  value_writer.write_uint32(value.error_count());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("local_active_participants");
  value_writer.write_uint32(value.local_active_participants());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("new_address_count");
  value_writer.write_uint32(value.new_address_count());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("expired_address_count");
  value_writer.write_uint32(value.expired_address_count());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_queue_size");
  value_writer.write_uint32(value.max_queue_size());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("max_queue_latency");
  vwrite(value_writer, value.max_queue_latency());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("local_participants");
  value_writer.write_uint32(value.local_participants());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("local_writers");
  value_writer.write_uint32(value.local_writers());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("local_readers");
  value_writer.write_uint32(value.local_readers());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("relay_partitions_pub_count");
  value_writer.write_uint32(value.relay_partitions_pub_count());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("relay_address_pub_count");
  value_writer.write_uint32(value.relay_address_pub_count());
  value_writer.end_struct_member();
  value_writer.begin_struct_member("spdp_replay_pub_count");
  value_writer.write_uint32(value.spdp_replay_pub_count());
  value_writer.end_struct_member();
  value_writer.end_struct();
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> void set_default( ::RtpsRelay::RelayStatistics& stru)
{
  ACE_UNUSED_ARG(stru);
  stru.relay_id() = "";
  set_default(stru.interval());
  set_default(stru.rtps());
  set_default(stru.stun());
  stru.max_gain() = 0;
  stru.error_count() = 0;
  stru.local_active_participants() = 0;
  stru.new_address_count() = 0;
  stru.expired_address_count() = 0;
  stru.max_queue_size() = 0;
  set_default(stru.max_queue_latency());
  stru.local_participants() = 0;
  stru.local_writers() = 0;
  stru.local_readers() = 0;
  stru.relay_partitions_pub_count() = 0;
  stru.relay_address_pub_count() = 0;
  stru.spdp_replay_pub_count() = 0;
}

void serialized_size(const Encoding& encoding, size_t& size, const  ::RtpsRelay::RelayStatistics& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.relay_id().size() + 1;
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.interval());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.rtps());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.stun());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.max_gain());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.error_count());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.local_active_participants());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.new_address_count());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.expired_address_count());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.max_queue_size());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  serialized_size(encoding, size, stru.max_queue_latency());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.local_participants());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.local_writers());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.local_readers());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.relay_partitions_pub_count());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.relay_address_pub_count());
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size(encoding, size, stru.spdp_replay_pub_count());
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const  ::RtpsRelay::RelayStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.relay_id())) {
    return false;
  }
    serialized_size(encoding, size, stru.interval());

    if (!strm.write_parameter_id(258859474, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.interval())) {
    return false;
  }
    serialized_size(encoding, size, stru.rtps());

    if (!strm.write_parameter_id(23054614, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.rtps())) {
    return false;
  }
    serialized_size(encoding, size, stru.stun());

    if (!strm.write_parameter_id(80367312, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.stun())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.max_gain());

    if (!strm.write_parameter_id(103250334, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.max_gain())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.error_count());

    if (!strm.write_parameter_id(139299553, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.error_count())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.local_active_participants());

    if (!strm.write_parameter_id(268340515, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.local_active_participants())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.new_address_count());

    if (!strm.write_parameter_id(135028760, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.new_address_count())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.expired_address_count());

    if (!strm.write_parameter_id(119852735, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.expired_address_count())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.max_queue_size());

    if (!strm.write_parameter_id(87684088, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.max_queue_size())) {
    return false;
  }
    serialized_size(encoding, size, stru.max_queue_latency());

    if (!strm.write_parameter_id(197940087, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.max_queue_latency())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.local_participants());

    if (!strm.write_parameter_id(260514907, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.local_participants())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.local_writers());

    if (!strm.write_parameter_id(150026670, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.local_writers())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.local_readers());

    if (!strm.write_parameter_id(229080076, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.local_readers())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.relay_partitions_pub_count());

    if (!strm.write_parameter_id(6490862, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.relay_partitions_pub_count())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.relay_address_pub_count());

    if (!strm.write_parameter_id(43326945, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.relay_address_pub_count())) {
    return false;
  }
    primitive_serialized_size(encoding, size, stru.spdp_replay_pub_count());

    if (!strm.write_parameter_id(16464170, size)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.spdp_replay_pub_count())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.relay_id())
    && (strm << stru.interval())
    && (strm << stru.rtps())
    && (strm << stru.stun())
    && (strm << stru.max_gain())
    && (strm << stru.error_count())
    && (strm << stru.local_active_participants())
    && (strm << stru.new_address_count())
    && (strm << stru.expired_address_count())
    && (strm << stru.max_queue_size())
    && (strm << stru.max_queue_latency())
    && (strm << stru.local_participants())
    && (strm << stru.local_writers())
    && (strm << stru.local_readers())
    && (strm << stru.relay_partitions_pub_count())
    && (strm << stru.relay_address_pub_count())
    && (strm << stru.spdp_replay_pub_count());
}

bool operator>>(Serializer& strm,  ::RtpsRelay::RelayStatistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      case 258859474: {
        if (!(strm >> stru.interval())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 23054614: {
        if (!(strm >> stru.rtps())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 80367312: {
        if (!(strm >> stru.stun())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 103250334: {
        if (!(strm >> stru.max_gain())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 139299553: {
        if (!(strm >> stru.error_count())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 268340515: {
        if (!(strm >> stru.local_active_participants())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 135028760: {
        if (!(strm >> stru.new_address_count())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 119852735: {
        if (!(strm >> stru.expired_address_count())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 87684088: {
        if (!(strm >> stru.max_queue_size())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 197940087: {
        if (!(strm >> stru.max_queue_latency())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 260514907: {
        if (!(strm >> stru.local_participants())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 150026670: {
        if (!(strm >> stru.local_writers())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 229080076: {
        if (!(strm >> stru.local_readers())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 6490862: {
        if (!(strm >> stru.relay_partitions_pub_count())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 43326945: {
        if (!(strm >> stru.relay_address_pub_count())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      case 16464170: {
        if (!(strm >> stru.spdp_replay_pub_count())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          strm.skip(end_of_field - strm.rpos());
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::RelayStatistics\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.relay_id())
    && (strm >> stru.interval())
    && (strm >> stru.rtps())
    && (strm >> stru.stun())
    && (strm >> stru.max_gain())
    && (strm >> stru.error_count())
    && (strm >> stru.local_active_participants())
    && (strm >> stru.new_address_count())
    && (strm >> stru.expired_address_count())
    && (strm >> stru.max_queue_size())
    && (strm >> stru.max_queue_latency())
    && (strm >> stru.local_participants())
    && (strm >> stru.local_writers())
    && (strm >> stru.local_readers())
    && (strm >> stru.relay_partitions_pub_count())
    && (strm >> stru.relay_address_pub_count())
    && (strm >> stru.spdp_replay_pub_count());
}

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::RtpsRelay::RelayStatistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::RtpsRelay::RelayStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.relay_id())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.value.relay_id());
}

bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.value.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const NestedKeyOnly< ::RtpsRelay::RelayStatistics>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.value.relay_id());
}

void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::RtpsRelay::RelayStatistics>& stru)
{
  ACE_UNUSED_ARG(encoding);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(stru);
  size_t mutable_running_total = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size_delimiter(encoding, size);
  }
  serialized_size_parameter_id(encoding, size, mutable_running_total);
  primitive_serialized_size_ulong(encoding, size);
  size += stru.value.relay_id().size() + 1;
  serialized_size_list_end_parameter_id(encoding, size, mutable_running_total);
}

bool operator<<(Serializer& strm, const KeyOnly<const  ::RtpsRelay::RelayStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    serialized_size(encoding, total_size, stru);
    if (!strm.write_delimiter(total_size)) {
      return false;
    }
  }
  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    size_t size = 0;
    ACE_UNUSED_ARG(size);
    primitive_serialized_size_ulong(encoding, size);
    size += stru.value.relay_id().size() + 1;

    if (!strm.write_parameter_id(52683514, size, true)) {
      return false;
    }
    size = 0;
    if (!(strm << stru.value.relay_id())) {
    return false;
  }

    if (!strm.write_list_end_parameter_id()) {
      return false;
    }
    return true;
  }
  return (strm << stru.value.relay_id());
}

bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayStatistics>& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  const Encoding& encoding = strm.encoding();
  ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      return false;
    }
  }
  const size_t end_of_struct = strm.rpos() + total_size;

  if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
    set_default(stru.value);

    unsigned member_id;
    size_t field_size;
    while (true) {
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
        return true;
      }
      bool must_understand = false;
      if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
        return false;
      }
      if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
        return true;
      }
      const size_t end_of_field = strm.rpos() + field_size;
      ACE_UNUSED_ARG(end_of_field);

      switch (member_id) {
      case 52683514: {
        if (!(strm >> stru.value.relay_id())) {
          strm.set_construction_status(Serializer::ElementConstructionFailure);
          return false;
        }
        break;
      }
      default:
        if (must_understand) {
          if (DCPS_debug_level >= 8) {
            ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in const KeyOnly< ::RtpsRelay::RelayStatistics>\n"), member_id));
          }
          return false;
        }
        strm.skip(field_size);
        break;
      }
    }
    return false;
  }

  return (strm >> stru.value.relay_id());
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
::DDS::DataWriter_ptr RelayStatisticsTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<RelayStatistics> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr RelayStatisticsTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayStatistics> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr RelayStatisticsTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RelayStatistics> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<RelayStatistics, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& RelayStatisticsTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<RelayStatistics>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool RelayStatisticsTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key();
}

const char* RelayStatisticsTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

void RelayStatisticsTypeSupportImpl::representations_allowed_by_type(
  ::DDS::DataRepresentationIdSeq& seq)
{
  MarshalTraitsType::representations_allowed_by_type(seq);
}

const OpenDDS::XTypes::TypeIdentifier& RelayStatisticsTypeSupportImpl::getMinimalTypeIdentifier() const
{
  return OpenDDS::DCPS::getMinimalTypeIdentifier<OpenDDS::DCPS::RtpsRelay_RelayStatistics_xtag>();
}

const OpenDDS::XTypes::TypeMap& RelayStatisticsTypeSupportImpl::getMinimalTypeMap() const
{
  return OpenDDS::DCPS::getMinimalTypeMap<OpenDDS::DCPS::RtpsRelay_RelayStatistics_xtag>();
}

const OpenDDS::XTypes::TypeIdentifier& RelayStatisticsTypeSupportImpl::getCompleteTypeIdentifier() const
{
  static OpenDDS::XTypes::TypeIdentifier ti;
  return ti;
}

const OpenDDS::XTypes::TypeMap& RelayStatisticsTypeSupportImpl::getCompleteTypeMap() const
{
  static OpenDDS::XTypes::TypeMap tm;
  return tm;
}

OpenDDS::DCPS::Extensibility RelayStatisticsTypeSupportImpl::getExtensibility() const
{
  return MarshalTraitsType::extensibility();
}

RelayStatisticsTypeSupport::_ptr_type RelayStatisticsTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl< ::RtpsRelay::RelayStatistics> : MetaStruct {
  typedef  ::RtpsRelay::RelayStatistics T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 1; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "relay_id")) {
      return true;
    }
    return false;
  }

  ACE_CDR::ULong map_name_to_id(const char* field) const
  {
    static const std::pair<std::string, ACE_CDR::ULong> name_to_id_pairs[] = {
      std::make_pair("relay_id", 52683514),
      std::make_pair("interval", 258859474),
      std::make_pair("rtps", 23054614),
      std::make_pair("stun", 80367312),
      std::make_pair("max_gain", 103250334),
      std::make_pair("error_count", 139299553),
      std::make_pair("local_active_participants", 268340515),
      std::make_pair("new_address_count", 135028760),
      std::make_pair("expired_address_count", 119852735),
      std::make_pair("max_queue_size", 87684088),
      std::make_pair("max_queue_latency", 197940087),
      std::make_pair("local_participants", 260514907),
      std::make_pair("local_writers", 150026670),
      std::make_pair("local_readers", 229080076),
      std::make_pair("relay_partitions_pub_count", 6490862),
      std::make_pair("relay_address_pub_count", 43326945),
      std::make_pair("spdp_replay_pub_count", 16464170),
    };
    static const std::map<std::string, ACE_CDR::ULong> name_to_id_map(name_to_id_pairs, name_to_id_pairs + 17);
    std::map<std::string, ACE_CDR::ULong>::const_iterator it = name_to_id_map.find(field);
    if (it == name_to_id_map.end()) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatistics)");
    } else {
      return it->second;
    }
  }

  Value getValue(const void* stru, const char* field) const
  {
    const  ::RtpsRelay::RelayStatistics& typed = *static_cast<const  ::RtpsRelay::RelayStatistics*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "relay_id") == 0) {
      return typed.relay_id();
    }
    if (std::strncmp(field, "interval.", 9) == 0) {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(&typed._interval, field + 9);
    }
    if (std::strncmp(field, "rtps.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(&typed._rtps, field + 5);
    }
    if (std::strncmp(field, "stun.", 5) == 0) {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(&typed._stun, field + 5);
    }
    if (std::strcmp(field, "max_gain") == 0) {
      return typed.max_gain();
    }
    if (std::strcmp(field, "error_count") == 0) {
      return typed.error_count();
    }
    if (std::strcmp(field, "local_active_participants") == 0) {
      return typed.local_active_participants();
    }
    if (std::strcmp(field, "new_address_count") == 0) {
      return typed.new_address_count();
    }
    if (std::strcmp(field, "expired_address_count") == 0) {
      return typed.expired_address_count();
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      return typed.max_queue_size();
    }
    if (std::strncmp(field, "max_queue_latency.", 18) == 0) {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(&typed._max_queue_latency, field + 18);
    }
    if (std::strcmp(field, "local_participants") == 0) {
      return typed.local_participants();
    }
    if (std::strcmp(field, "local_writers") == 0) {
      return typed.local_writers();
    }
    if (std::strcmp(field, "local_readers") == 0) {
      return typed.local_readers();
    }
    if (std::strcmp(field, "relay_partitions_pub_count") == 0) {
      return typed.relay_partitions_pub_count();
    }
    if (std::strcmp(field, "relay_address_pub_count") == 0) {
      return typed.relay_address_pub_count();
    }
    if (std::strcmp(field, "spdp_replay_pub_count") == 0) {
      return typed.spdp_replay_pub_count();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatistics)");
  }

  Value getValue(Serializer& strm, const char* field) const
  {
    const Encoding& encoding = strm.encoding();
    ACE_UNUSED_ARG(encoding);
  size_t total_size = 0;
  if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2) {
    if (!strm.read_delimiter(total_size)) {
      throw std::runtime_error("Unable to reader delimiter in getValue");
    }
  }
    std::string base_field = field;
    size_t index = base_field.find('.');
    std::string subfield;
    if (index != std::string::npos) {
      subfield = base_field.substr(index + 1);
      base_field = base_field.substr(0, index);
    }
    if (encoding.xcdr_version() != Encoding::XCDR_VERSION_NONE) {
      unsigned field_id = map_name_to_id(base_field.c_str());
      ACE_UNUSED_ARG(field_id);
      unsigned member_id;
      size_t field_size;
      const size_t end_of_struct = strm.rpos() + total_size;
      while (true) {
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_2 &&
            strm.rpos() >= end_of_struct) {
          break;
        }
        bool must_understand = false;
        if (!strm.read_parameter_id(member_id, field_size, must_understand)) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " Deserialization Error for struct  ::RtpsRelay::RelayStatistics");
        }
        if (encoding.xcdr_version() == Encoding::XCDR_VERSION_1 &&
            member_id == Serializer::pid_list_end) {
          throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct  ::RtpsRelay::RelayStatistics");
        }
        const size_t end_of_field = strm.rpos() + field_size;
        ACE_UNUSED_ARG(end_of_field);

        switch (member_id) {
        case 52683514: {
          if (field_id == member_id) {
            std::string val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'relay_id' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 258859474: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 23054614: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 80367312: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 103250334: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'max_gain' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 139299553: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'error_count' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 268340515: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'local_active_participants' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 135028760: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'new_address_count' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 119852735: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'expired_address_count' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 87684088: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'max_queue_size' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 197940087: {
          if (field_id == member_id) {
            return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 260514907: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'local_participants' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 150026670: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'local_writers' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 229080076: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'local_readers' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 6490862: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'relay_partitions_pub_count' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 43326945: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'relay_address_pub_count' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        case 16464170: {
          if (field_id == member_id) {
            ACE_CDR::ULong val;
            if (!(strm >> val)) {
              throw std::runtime_error("Field 'spdp_replay_pub_count' could not be deserialized");
            }
            return val;
          } else {
            strm.skip(field_size);
          }
          break;
        }
        default:
          if (must_understand) {
            if (DCPS_debug_level >= 8) {
              ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) unknown must_understand field(%u) in  ::RtpsRelay::RelayStatistics\n"), member_id));
            }
            throw std::runtime_error("member id did not exist in getValue");
          }
          strm.skip(field_size);
          break;
        }
      }
      if (!field[0]) {
        return 0;
      }
      throw std::runtime_error("Did not find field in getValue");
    }
    if (base_field == "relay_id") {
      std::string val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'relay_id' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(strm >> len)) {
        throw std::runtime_error("String 'relay_id' length could not be deserialized");
      }
      if (!strm.skip(len)) {
        throw std::runtime_error("String 'relay_id' contents could not be skipped");
      }
    }
    if (base_field == "interval") {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::Duration_t*>(0))) {
        throw std::runtime_error("Field 'interval' could not be skipped");
      }
    }
    if (base_field == "rtps") {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::ProtocolStatistics*>(0))) {
        throw std::runtime_error("Field 'rtps' could not be skipped");
      }
    }
    if (base_field == "stun") {
      return getMetaStruct< ::RtpsRelay::ProtocolStatistics>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::ProtocolStatistics*>(0))) {
        throw std::runtime_error("Field 'stun' could not be skipped");
      }
    }
    if (base_field == "max_gain") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_gain' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_gain' could not be skipped");
      }
    }
    if (base_field == "error_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'error_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'error_count' could not be skipped");
      }
    }
    if (base_field == "local_active_participants") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'local_active_participants' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'local_active_participants' could not be skipped");
      }
    }
    if (base_field == "new_address_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'new_address_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'new_address_count' could not be skipped");
      }
    }
    if (base_field == "expired_address_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'expired_address_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'expired_address_count' could not be skipped");
      }
    }
    if (base_field == "max_queue_size") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'max_queue_size' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'max_queue_size' could not be skipped");
      }
    }
    if (base_field == "max_queue_latency") {
      return getMetaStruct< ::RtpsRelay::Duration_t>().getValue(strm, subfield.c_str());
    } else {
      if (!gen_skip_over(strm, static_cast< ::RtpsRelay::Duration_t*>(0))) {
        throw std::runtime_error("Field 'max_queue_latency' could not be skipped");
      }
    }
    if (base_field == "local_participants") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'local_participants' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'local_participants' could not be skipped");
      }
    }
    if (base_field == "local_writers") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'local_writers' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'local_writers' could not be skipped");
      }
    }
    if (base_field == "local_readers") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'local_readers' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'local_readers' could not be skipped");
      }
    }
    if (base_field == "relay_partitions_pub_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'relay_partitions_pub_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'relay_partitions_pub_count' could not be skipped");
      }
    }
    if (base_field == "relay_address_pub_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'relay_address_pub_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'relay_address_pub_count' could not be skipped");
      }
    }
    if (base_field == "spdp_replay_pub_count") {
      ACE_CDR::ULong val;
      if (!(strm >> val)) {
        throw std::runtime_error("Field 'spdp_replay_pub_count' could not be deserialized");
      }
      return val;
    } else {
      if (!strm.skip(1,  4 )) {
        throw std::runtime_error("Field 'spdp_replay_pub_count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Did not find field in getValue");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "relay_id") == 0) {
      return make_field_cmp(&T::_relay_id, next);
    }
    if (std::strncmp(field, "interval.", 9) == 0) {
      return make_struct_cmp(&T::_interval, getMetaStruct< ::RtpsRelay::Duration_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "rtps.", 5) == 0) {
      return make_struct_cmp(&T::_rtps, getMetaStruct< ::RtpsRelay::ProtocolStatistics>().create_qc_comparator(field + 5), next);
    }
    if (std::strncmp(field, "stun.", 5) == 0) {
      return make_struct_cmp(&T::_stun, getMetaStruct< ::RtpsRelay::ProtocolStatistics>().create_qc_comparator(field + 5), next);
    }
    if (std::strcmp(field, "max_gain") == 0) {
      return make_field_cmp(&T::_max_gain, next);
    }
    if (std::strcmp(field, "error_count") == 0) {
      return make_field_cmp(&T::_error_count, next);
    }
    if (std::strcmp(field, "local_active_participants") == 0) {
      return make_field_cmp(&T::_local_active_participants, next);
    }
    if (std::strcmp(field, "new_address_count") == 0) {
      return make_field_cmp(&T::_new_address_count, next);
    }
    if (std::strcmp(field, "expired_address_count") == 0) {
      return make_field_cmp(&T::_expired_address_count, next);
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      return make_field_cmp(&T::_max_queue_size, next);
    }
    if (std::strncmp(field, "max_queue_latency.", 18) == 0) {
      return make_struct_cmp(&T::_max_queue_latency, getMetaStruct< ::RtpsRelay::Duration_t>().create_qc_comparator(field + 18), next);
    }
    if (std::strcmp(field, "local_participants") == 0) {
      return make_field_cmp(&T::_local_participants, next);
    }
    if (std::strcmp(field, "local_writers") == 0) {
      return make_field_cmp(&T::_local_writers, next);
    }
    if (std::strcmp(field, "local_readers") == 0) {
      return make_field_cmp(&T::_local_readers, next);
    }
    if (std::strcmp(field, "relay_partitions_pub_count") == 0) {
      return make_field_cmp(&T::_relay_partitions_pub_count, next);
    }
    if (std::strcmp(field, "relay_address_pub_count") == 0) {
      return make_field_cmp(&T::_relay_address_pub_count, next);
    }
    if (std::strcmp(field, "spdp_replay_pub_count") == 0) {
      return make_field_cmp(&T::_spdp_replay_pub_count, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatistics)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"relay_id", "interval", "rtps", "stun", "max_gain", "error_count", "local_active_participants", "new_address_count", "expired_address_count", "max_queue_size", "max_queue_latency", "local_participants", "local_writers", "local_readers", "relay_partitions_pub_count", "relay_address_pub_count", "spdp_replay_pub_count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "relay_id") == 0) {
      return &static_cast<const T*>(stru)->_relay_id;
    }
    if (std::strcmp(field, "interval") == 0) {
      return &static_cast<const T*>(stru)->_interval;
    }
    if (std::strcmp(field, "rtps") == 0) {
      return &static_cast<const T*>(stru)->_rtps;
    }
    if (std::strcmp(field, "stun") == 0) {
      return &static_cast<const T*>(stru)->_stun;
    }
    if (std::strcmp(field, "max_gain") == 0) {
      return &static_cast<const T*>(stru)->_max_gain;
    }
    if (std::strcmp(field, "error_count") == 0) {
      return &static_cast<const T*>(stru)->_error_count;
    }
    if (std::strcmp(field, "local_active_participants") == 0) {
      return &static_cast<const T*>(stru)->_local_active_participants;
    }
    if (std::strcmp(field, "new_address_count") == 0) {
      return &static_cast<const T*>(stru)->_new_address_count;
    }
    if (std::strcmp(field, "expired_address_count") == 0) {
      return &static_cast<const T*>(stru)->_expired_address_count;
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      return &static_cast<const T*>(stru)->_max_queue_size;
    }
    if (std::strcmp(field, "max_queue_latency") == 0) {
      return &static_cast<const T*>(stru)->_max_queue_latency;
    }
    if (std::strcmp(field, "local_participants") == 0) {
      return &static_cast<const T*>(stru)->_local_participants;
    }
    if (std::strcmp(field, "local_writers") == 0) {
      return &static_cast<const T*>(stru)->_local_writers;
    }
    if (std::strcmp(field, "local_readers") == 0) {
      return &static_cast<const T*>(stru)->_local_readers;
    }
    if (std::strcmp(field, "relay_partitions_pub_count") == 0) {
      return &static_cast<const T*>(stru)->_relay_partitions_pub_count;
    }
    if (std::strcmp(field, "relay_address_pub_count") == 0) {
      return &static_cast<const T*>(stru)->_relay_address_pub_count;
    }
    if (std::strcmp(field, "spdp_replay_pub_count") == 0) {
      return &static_cast<const T*>(stru)->_spdp_replay_pub_count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatistics)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "relay_id") == 0) {
      static_cast<T*>(lhs)->_relay_id = *static_cast<const std::string*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "interval") == 0) {
      static_cast<T*>(lhs)->_interval = *static_cast<const  ::RtpsRelay::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "rtps") == 0) {
      static_cast<T*>(lhs)->_rtps = *static_cast<const  ::RtpsRelay::ProtocolStatistics*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "stun") == 0) {
      static_cast<T*>(lhs)->_stun = *static_cast<const  ::RtpsRelay::ProtocolStatistics*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_gain") == 0) {
      static_cast<T*>(lhs)->_max_gain = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "error_count") == 0) {
      static_cast<T*>(lhs)->_error_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "local_active_participants") == 0) {
      static_cast<T*>(lhs)->_local_active_participants = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "new_address_count") == 0) {
      static_cast<T*>(lhs)->_new_address_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expired_address_count") == 0) {
      static_cast<T*>(lhs)->_expired_address_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      static_cast<T*>(lhs)->_max_queue_size = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_queue_latency") == 0) {
      static_cast<T*>(lhs)->_max_queue_latency = *static_cast<const  ::RtpsRelay::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "local_participants") == 0) {
      static_cast<T*>(lhs)->_local_participants = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "local_writers") == 0) {
      static_cast<T*>(lhs)->_local_writers = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "local_readers") == 0) {
      static_cast<T*>(lhs)->_local_readers = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relay_partitions_pub_count") == 0) {
      static_cast<T*>(lhs)->_relay_partitions_pub_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relay_address_pub_count") == 0) {
      static_cast<T*>(lhs)->_relay_address_pub_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "spdp_replay_pub_count") == 0) {
      static_cast<T*>(lhs)->_spdp_replay_pub_count = *static_cast<const  ::CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatistics)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "relay_id") == 0) {
      return static_cast<const T*>(lhs)->_relay_id == static_cast<const T*>(rhs)->_relay_id;
    }
    if (std::strcmp(field, "max_gain") == 0) {
      return static_cast<const T*>(lhs)->_max_gain == static_cast<const T*>(rhs)->_max_gain;
    }
    if (std::strcmp(field, "error_count") == 0) {
      return static_cast<const T*>(lhs)->_error_count == static_cast<const T*>(rhs)->_error_count;
    }
    if (std::strcmp(field, "local_active_participants") == 0) {
      return static_cast<const T*>(lhs)->_local_active_participants == static_cast<const T*>(rhs)->_local_active_participants;
    }
    if (std::strcmp(field, "new_address_count") == 0) {
      return static_cast<const T*>(lhs)->_new_address_count == static_cast<const T*>(rhs)->_new_address_count;
    }
    if (std::strcmp(field, "expired_address_count") == 0) {
      return static_cast<const T*>(lhs)->_expired_address_count == static_cast<const T*>(rhs)->_expired_address_count;
    }
    if (std::strcmp(field, "max_queue_size") == 0) {
      return static_cast<const T*>(lhs)->_max_queue_size == static_cast<const T*>(rhs)->_max_queue_size;
    }
    if (std::strcmp(field, "local_participants") == 0) {
      return static_cast<const T*>(lhs)->_local_participants == static_cast<const T*>(rhs)->_local_participants;
    }
    if (std::strcmp(field, "local_writers") == 0) {
      return static_cast<const T*>(lhs)->_local_writers == static_cast<const T*>(rhs)->_local_writers;
    }
    if (std::strcmp(field, "local_readers") == 0) {
      return static_cast<const T*>(lhs)->_local_readers == static_cast<const T*>(rhs)->_local_readers;
    }
    if (std::strcmp(field, "relay_partitions_pub_count") == 0) {
      return static_cast<const T*>(lhs)->_relay_partitions_pub_count == static_cast<const T*>(rhs)->_relay_partitions_pub_count;
    }
    if (std::strcmp(field, "relay_address_pub_count") == 0) {
      return static_cast<const T*>(lhs)->_relay_address_pub_count == static_cast<const T*>(rhs)->_relay_address_pub_count;
    }
    if (std::strcmp(field, "spdp_replay_pub_count") == 0) {
      return static_cast<const T*>(lhs)->_spdp_replay_pub_count == static_cast<const T*>(rhs)->_spdp_replay_pub_count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct ::RtpsRelay::RelayStatistics)");
  }
};

template<>
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayStatistics>()
{
  static MetaStructImpl< ::RtpsRelay::RelayStatistics> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayStatistics*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl< ::RtpsRelay::RelayStatistics>().getValue(ser, "");
  return true;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace RtpsRelay {
RelayStatistics::RelayStatistics(const std::string& relay_id,
    const  ::RtpsRelay::Duration_t& interval,
    const  ::RtpsRelay::ProtocolStatistics& rtps,
    const  ::RtpsRelay::ProtocolStatistics& stun,
    uint32_t max_gain,
    uint32_t error_count,
    uint32_t local_active_participants,
    uint32_t new_address_count,
    uint32_t expired_address_count,
    uint32_t max_queue_size,
    const  ::RtpsRelay::Duration_t& max_queue_latency,
    uint32_t local_participants,
    uint32_t local_writers,
    uint32_t local_readers,
    uint32_t relay_partitions_pub_count,
    uint32_t relay_address_pub_count,
    uint32_t spdp_replay_pub_count)
  : _relay_id(relay_id)
  , _interval(interval)
  , _rtps(rtps)
  , _stun(stun)
  , _max_gain(max_gain)
  , _error_count(error_count)
  , _local_active_participants(local_active_participants)
  , _new_address_count(new_address_count)
  , _expired_address_count(expired_address_count)
  , _max_queue_size(max_queue_size)
  , _max_queue_latency(max_queue_latency)
  , _local_participants(local_participants)
  , _local_writers(local_writers)
  , _local_readers(local_readers)
  , _relay_partitions_pub_count(relay_partitions_pub_count)
  , _relay_address_pub_count(relay_address_pub_count)
  , _spdp_replay_pub_count(spdp_replay_pub_count)
{}

void swap(RelayStatistics& lhs, RelayStatistics& rhs)
{
  using std::swap;
  swap(lhs._relay_id, rhs._relay_id);
  swap(lhs._interval, rhs._interval);
  swap(lhs._rtps, rhs._rtps);
  swap(lhs._stun, rhs._stun);
  swap(lhs._max_gain, rhs._max_gain);
  swap(lhs._error_count, rhs._error_count);
  swap(lhs._local_active_participants, rhs._local_active_participants);
  swap(lhs._new_address_count, rhs._new_address_count);
  swap(lhs._expired_address_count, rhs._expired_address_count);
  swap(lhs._max_queue_size, rhs._max_queue_size);
  swap(lhs._max_queue_latency, rhs._max_queue_latency);
  swap(lhs._local_participants, rhs._local_participants);
  swap(lhs._local_writers, rhs._local_writers);
  swap(lhs._local_readers, rhs._local_readers);
  swap(lhs._relay_partitions_pub_count, rhs._relay_partitions_pub_count);
  swap(lhs._relay_address_pub_count, rhs._relay_address_pub_count);
  swap(lhs._spdp_replay_pub_count, rhs._spdp_replay_pub_count);
}

}

/* End STRUCT: RelayStatistics */

/* End MODULE: RtpsRelay */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

namespace {
XTypes::TypeObject minimal_to0()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(3), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to1()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(141, 77, 82, 5))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))), XTypes::MinimalMemberDetail(127, 106, 154, 79))))));
}

XTypes::TypeObject minimal_to2()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(250, 226, 35, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(136, 77, 152, 4))))));
}

XTypes::TypeObject minimal_to3()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_INT32)), XTypes::MinimalMemberDetail(116, 69, 156, 163))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(226, 4, 100, 213))))));
}

XTypes::TypeObject minimal_to4()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_MUTABLE | XTypes::IS_AUTOID_HASH, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(6490862, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(238, 10, 99, 160))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(16464170, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(42, 57, 251, 160))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(23054614, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 100, 191, 76, 102, 30, 34, 62, 147, 158, 182, 213, 240, 58))), XTypes::MinimalMemberDetail(22, 201, 95, 1))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(43326945, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(225, 29, 149, 82))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(52683514, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(250, 226, 35, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80367312, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 100, 191, 76, 102, 30, 34, 62, 147, 158, 182, 213, 240, 58))), XTypes::MinimalMemberDetail(208, 78, 202, 148))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(87684088, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(248, 243, 57, 149))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(103250334, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(158, 121, 39, 54))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(119852735, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(191, 206, 36, 103))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(135028760, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(24, 96, 12, 88))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(139299553, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(225, 138, 77, 72))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(150026670, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(174, 57, 241, 104))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(197940087, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(119, 83, 204, 59))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(229080076, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(12, 124, 167, 189))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(258859474, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(210, 225, 109, 63))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(260514907, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(91, 36, 135, 239))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(268340515, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(35, 141, 254, 31))))));
}

XTypes::TypeObject minimal_to5()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_MUTABLE | XTypes::IS_AUTOID_HASH, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(23054614, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 100, 191, 76, 102, 30, 34, 62, 147, 158, 182, 213, 240, 58))), XTypes::MinimalMemberDetail(22, 201, 95, 1))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(52683514, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(250, 226, 35, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80367312, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 100, 191, 76, 102, 30, 34, 62, 147, 158, 182, 213, 240, 58))), XTypes::MinimalMemberDetail(208, 78, 202, 148))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(87684088, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(248, 243, 57, 149))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(103250334, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(158, 121, 39, 54))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(139299553, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(225, 138, 77, 72))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(197940087, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(119, 83, 204, 59))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(210987184, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(258859474, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(210, 225, 109, 63))))));
}

XTypes::TypeObject minimal_to6()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(250, 226, 35, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(57, 239, 232, 143))))));
}

XTypes::TypeObject minimal_to7()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to8()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_MUTABLE | XTypes::IS_AUTOID_HASH, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(23054614, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 100, 191, 76, 102, 30, 34, 62, 147, 158, 182, 213, 240, 58))), XTypes::MinimalMemberDetail(22, 201, 95, 1))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(27593758, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(30, 12, 165, 177))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(80367312, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 100, 191, 76, 102, 30, 34, 62, 147, 158, 182, 213, 240, 58))), XTypes::MinimalMemberDetail(208, 78, 202, 148))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(101278124, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(172, 97, 9, 86))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(210987184, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(176, 104, 147, 28))))));
}

XTypes::TypeObject minimal_to9()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0)))))))));
}

XTypes::TypeObject minimal_to10()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))), XTypes::MinimalMemberDetail(157, 112, 43, 158))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))), XTypes::MinimalMemberDetail(177, 178, 109, 157))))));
}

XTypes::TypeObject minimal_to11()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_ARRAY_SMALL, XTypes::PlainArraySElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_BOTH, XTypes::TRY_CONSTRUCT1), XTypes::SBoundSeq().append(12), XTypes::TypeIdentifier(XTypes::TK_BYTE))))))));
}

XTypes::TypeObject minimal_to12()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(174, 164, 103, 225))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(136, 77, 152, 4))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(30, 12, 165, 177))))));
}

XTypes::TypeObject minimal_to13()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(250, 226, 35, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(94, 151, 153, 78))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(2, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))), XTypes::MinimalMemberDetail(174, 164, 103, 225))))));
}

XTypes::TypeObject minimal_to14()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_MUTABLE | XTypes::IS_AUTOID_HASH, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(27593758, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))), XTypes::MinimalMemberDetail(30, 12, 165, 177))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(52683514, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TI_STRING8_SMALL, XTypes::StringSTypeDefn(0))), XTypes::MinimalMemberDetail(250, 226, 35, 179))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(73296583, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(199, 106, 94, 132))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(97899387, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_BOOLEAN)), XTypes::MinimalMemberDetail(123, 211, 213, 245))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(160271928, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))), XTypes::MinimalMemberDetail(56, 142, 141, 25))))));
}

XTypes::TypeObject minimal_to15()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_MUTABLE | XTypes::IS_NESTED | XTypes::IS_AUTOID_HASH, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(20755121, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT64)), XTypes::MinimalMemberDetail(177, 178, 60, 209))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(21653781, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT64)), XTypes::MinimalMemberDetail(21, 105, 74, 65))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(71676468, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(52, 178, 69, 100))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(133473638, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(102, 165, 244, 23))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(146649702, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(102, 178, 189, 40))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(201631001, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))), XTypes::MinimalMemberDetail(25, 165, 4, 172))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(216241791, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(127, 150, 227, 44))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(256318015, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT32)), XTypes::MinimalMemberDetail(63, 26, 71, 143))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(257113707, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT64)), XTypes::MinimalMemberDetail(107, 62, 83, 95))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(266701231, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::TK_UINT64)), XTypes::MinimalMemberDetail(175, 137, 229, 207))))));
}

XTypes::TypeObject minimal_to16()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalAliasType(0, XTypes::MinimalAliasHeader(), XTypes::MinimalAliasBody(XTypes::CommonAliasBody(0, XTypes::TypeIdentifier(XTypes::TI_PLAIN_SEQUENCE_SMALL, XTypes::PlainSequenceSElemDefn(XTypes::PlainCollectionHeader(XTypes::EK_MINIMAL, XTypes::TRY_CONSTRUCT1), 0, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253)))))))));
}

XTypes::TypeObject minimal_to17()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_APPENDABLE | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))), XTypes::MinimalMemberDetail(32, 99, 193, 96))))));
}

XTypes::TypeObject minimal_to18()
{
  return XTypes::TypeObject(XTypes::MinimalTypeObject(XTypes::MinimalStructType(XTypes::IS_FINAL | XTypes::IS_NESTED, XTypes::MinimalStructHeader(XTypes::TypeIdentifier(XTypes::TK_NONE), XTypes::MinimalTypeDetail()), XTypes::MinimalStructMemberSeq().append(XTypes::MinimalStructMember(XTypes::CommonStructMember(0, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))), XTypes::MinimalMemberDetail(87, 2, 74, 74))).append(XTypes::MinimalStructMember(XTypes::CommonStructMember(1, XTypes::TRY_CONSTRUCT1 | XTypes::IS_KEY, XTypes::TypeIdentifier(XTypes::TK_BYTE)), XTypes::MinimalMemberDetail(61, 5, 144, 205))))));
}

XTypes::TypeMap get_minimal_type_map_private()
{
  XTypes::TypeMap tm;
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(10, 230, 147, 187, 255, 15, 178, 29, 139, 101, 226, 215, 223, 44))] = minimal_to0();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(12, 140, 21, 115, 253, 34, 228, 1, 111, 94, 79, 187, 0, 91))] = minimal_to1();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(40, 115, 44, 121, 247, 153, 9, 247, 20, 247, 224, 100, 254, 136))] = minimal_to2();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(68, 251, 76, 240, 12, 193, 103, 94, 35, 185, 214, 132, 72, 150))] = minimal_to3();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(70, 79, 187, 18, 204, 170, 180, 133, 243, 59, 87, 186, 17, 243))] = minimal_to4();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(71, 157, 116, 45, 116, 235, 83, 107, 21, 192, 226, 39, 164, 162))] = minimal_to5();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(81, 10, 91, 75, 77, 139, 48, 187, 15, 190, 19, 210, 177, 240))] = minimal_to6();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(120, 137, 249, 174, 25, 230, 75, 33, 116, 39, 204, 87, 125, 85))] = minimal_to7();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(136, 97, 254, 8, 10, 7, 82, 97, 214, 72, 61, 0, 18, 55))] = minimal_to8();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(158, 69, 47, 201, 4, 49, 53, 18, 62, 98, 81, 112, 219, 57))] = minimal_to9();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(161, 246, 92, 76, 74, 229, 72, 164, 39, 201, 223, 110, 41, 253))] = minimal_to10();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(165, 173, 118, 203, 157, 101, 145, 117, 30, 199, 19, 174, 160, 45))] = minimal_to11();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(167, 1, 236, 210, 186, 165, 8, 12, 191, 99, 115, 152, 245, 212))] = minimal_to12();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(167, 66, 191, 138, 175, 21, 47, 188, 150, 90, 174, 31, 217, 250))] = minimal_to13();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(167, 183, 124, 126, 24, 20, 45, 94, 110, 196, 76, 156, 168, 174))] = minimal_to14();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(184, 100, 191, 76, 102, 30, 34, 62, 147, 158, 182, 213, 240, 58))] = minimal_to15();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(195, 25, 137, 69, 3, 84, 84, 11, 184, 186, 216, 104, 203, 134))] = minimal_to16();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(209, 232, 20, 211, 202, 90, 192, 71, 75, 28, 36, 160, 70, 23))] = minimal_to17();
  tm[XTypes::TypeIdentifier(XTypes::EK_MINIMAL, XTypes::EquivalenceHashWrapper(233, 193, 171, 70, 109, 161, 107, 219, 39, 127, 52, 90, 149, 159))] = minimal_to18();
  return tm;
}

}

const XTypes::TypeMap& get_minimal_type_map()
{
  static XTypes::TypeMap tm;
  ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, TheServiceParticipant->get_static_xtypes_lock(), tm);
  if (tm.empty()) {
    tm = get_minimal_type_map_private();
  }
  return tm;
}

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

